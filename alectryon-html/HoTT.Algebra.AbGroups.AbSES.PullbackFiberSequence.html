<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>PullbackFiberSequence.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Basics Types HSet HFiber Limits.Pullback Cubical.PathSquare.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> WildCat Pointed Homotopy.ExactSequence.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> AbGroups.AbelianGroup AbSES.Core AbSES.Pullback.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Modalities.Identity.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** * The fiber sequence induced by pulling back along a short exact sequence *)</span>

<span class="sd">(** We show that pulling back along a short exact sequence [E : AbSES C B] produces a fiber sequence [AbSES C A -&gt; AbSES E A -&gt; AbSES B A]. The associated long exact sequence of homotopy groups recovers the usual (contravariant) six-term exact sequence of Ext groups.</span>

<span class="sd">We will prove the analog of exactness in terms of path data, and deduce the usual notion. *)</span>

<span class="sd">(** If a short exact sequence [A -&gt; F -&gt; E] becomes trivial after pulling back along an inclusion [i : B -&gt; E], then there is a &quot;transpose&quot; short exact sequence [B -&gt; F -&gt; F/B]. We begin by constructing the endpoint [F/B]. *)</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk0"><span class="highlight"><span class="kn">Definition</span> <span class="nf">abses_pullback_inclusion_transpose_subgroup</span> `{Univalence} {A B E : AbGroup}
      (i : B $-&gt; E) `{IsEmbedding i}
      (F : AbSES E A) (p : abses_pullback0 i F $== point _)
  : NormalSubgroup F.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsEmbedding0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEmbedding i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 i F $== point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">NormalSubgroup F</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsEmbedding0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEmbedding i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 i F $== point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">NormalSubgroup F</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk2"><span class="highlight">srapply (ab_image_embedding (grp_pullback_pr1 _ _ $o (grp_iso_inverse p.<span class="mi">1</span>) $o ab_biprod_inr)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsEmbedding0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEmbedding i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 i F $== point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Is01Cat Group</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsEmbedding0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEmbedding i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 i F $== point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk3"><hr></label><div class="goal-conclusion"><span class="highlight">Is01Cat Group</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsEmbedding0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEmbedding i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 i F $== point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk4"><hr></label><div class="goal-conclusion"><span class="highlight">IsEmbedding
  (grp_pullback_pr1 (projection F) i $o
   grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk5"><span class="highlight"><span class="mi">1</span>,<span class="mi">2</span>: <span class="bp">exact</span> _. <span class="c">(* Why doesn&#39;t Coq find Group&#39;s [Is01Cat] instance? *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsEmbedding0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEmbedding i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 i F $== point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEmbedding
  (grp_pullback_pr1 (projection F) i $o
   grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk6"><span class="highlight">nrapply (istruncmap_compose _ (grp_iso_inverse p.<span class="mi">1</span> o ab_biprod_inr)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsEmbedding0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEmbedding i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 i F $== point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEmbedding (grp_pullback_pr1 (projection F) i)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsEmbedding0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEmbedding i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 i F $== point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk7"><hr></label><div class="goal-conclusion"><span class="highlight">IsEmbedding
  (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; grp_iso_inverse p.<span class="mi">1</span> (ab_biprod_inr x))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">all</span> : rapply istruncmap_mapinO_tr.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">abses_pullback_inclusion_transpose_endpoint&#39;</span> `{Univalence} {A B E : AbGroup}
           (i : B $-&gt; E) `{IsEmbedding i}
           (F : AbSES E A) (p : abses_pullback0 i F $== point _)
  : AbGroup := QuotientAbGroup F (abses_pullback_inclusion_transpose_subgroup i F p).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** By [abses_from_inclusion] we get a short exact sequence [B -&gt; F -&gt; F/B] associated to the subgroup and quotient just above. *)</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk8"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">abses_pullback_inclusion_transpose_beta</span> `{Univalence} {A B E : AbGroup}
      (i : B $-&gt; E) `{IsEmbedding i}
      (F : AbSES E A) (p : abses_pullback0 i F $== point _)
  : projection F $o (grp_pullback_pr1 (projection F) _ $o p^$.<span class="mi">1</span> $o ab_biprod_inr) == i.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsEmbedding0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEmbedding i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 i F $== point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection F $o
(grp_pullback_pr1 (projection F) i $o (p^$).<span class="mi">1</span> $o
 ab_biprod_inr) == i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsEmbedding0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEmbedding i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 i F $== point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection F $o
(grp_pullback_pr1 (projection F) i $o (p^$).<span class="mi">1</span> $o
 ab_biprod_inr) == i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka"><span class="highlight">rapply (conn_map_elim _ (ab_biprod_pr2 (A:=A))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsEmbedding0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEmbedding i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 i F $== point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : ab_biprod A B,
(projection F $o
 (grp_pullback_pr1 (projection F) i $o (p^$).<span class="mi">1</span> $o
  ab_biprod_inr)) (ab_biprod_pr2 a) =
i (ab_biprod_pr2 a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb"><span class="highlight"><span class="nb">intro</span> ab.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsEmbedding0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEmbedding i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 i F $== point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ab</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ab_biprod A B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(projection F $o
 (grp_pullback_pr1 (projection F) i $o (p^$).<span class="mi">1</span> $o
  ab_biprod_inr)) (ab_biprod_pr2 ab) =
i (ab_biprod_pr2 ab)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc"><span class="highlight"><span class="nb">refine</span> (pullback_commsq _ _ _ @ ap i _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsEmbedding0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEmbedding i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 i F $== point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ab</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ab_biprod A B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pullback_pr2
  ((p^$).<span class="mi">1</span> (ab_biprod_inr (ab_biprod_pr2 ab))) =
ab_biprod_pr2 ab</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (snd p^$.<span class="mi">2</span> _)^.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Short exact sequences in the fiber of [inclusion E] descend along [projection E]. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd"><span class="highlight"><span class="kn">Definition</span> <span class="nf">abses_pullback_trivial_preimage</span> `{Univalence} {A B C : AbGroup} (E : AbSES C B)
           (F : AbSES (middle E) A) (p : abses_pullback0 (inclusion E) F $== point _)
  : AbSES C A.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">AbSES C A</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chke"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">AbSES C A</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf"><span class="highlight">snrapply Build_AbSES.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">AbGroup</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk10"><hr></label><div class="goal-conclusion"><span class="highlight">A $-&gt; <span class="nl">?middle</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk11"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?middle</span> $-&gt; C</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk12"><hr></label><div class="goal-conclusion"><span class="highlight">IsEmbedding <span class="nl">?inclusion</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk13"><hr></label><div class="goal-conclusion"><span class="highlight">IsConnMap (Tr (-<span class="mi">1</span>)) <span class="nl">?projection</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk14"><hr></label><div class="goal-conclusion"><span class="highlight">IsExact (Tr (-<span class="mi">1</span>)) <span class="nl">?inclusion</span> <span class="nl">?projection</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk15"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">AbGroup</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (abses_pullback_inclusion_transpose_endpoint&#39; (inclusion E) F p).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk16"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A $-&gt;
abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (grp_quotient_map $o inclusion F).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk17"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p $-&gt; C</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk18"><span class="highlight">snrapply grp_quotient_rec.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">F $-&gt; C</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk19" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk19"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : F,
{|
  normalsubgroup_subgroup :=
    abses_pullback_inclusion_transpose_subgroup
      (inclusion E) F p;
  normalsubgroup_isnormal :=
    isnormal_ab_subgroup F
      (abses_pullback_inclusion_transpose_subgroup
         (inclusion E) F p)
|} n -&gt; <span class="nl">?f</span> n = mon_unit</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk1a"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">F $-&gt; C</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (projection E $o projection F).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk1b"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : F,
{|
  normalsubgroup_subgroup :=
    abses_pullback_inclusion_transpose_subgroup
      (inclusion E) F p;
  normalsubgroup_isnormal :=
    isnormal_ab_subgroup F
      (abses_pullback_inclusion_transpose_subgroup
         (inclusion E) F p)
|} n -&gt; (projection E $o projection F) n = mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk1c"><span class="highlight"><span class="nb">intros</span> f [b q].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b = f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(projection E $o projection F) f = mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk1d"><span class="highlight"><span class="nb">rewrite</span> &lt;- q.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b = f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(projection E $o projection F)
  ((grp_pullback_pr1 (projection F) (inclusion E) $o
    grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b) =
mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk1e"><span class="highlight"><span class="nb">refine</span> (ap (projection E) (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b = f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection E (inclusion E b) = mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> iscomplex_abses.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk1f"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEmbedding (grp_quotient_map $o inclusion F)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk20"><span class="highlight"><span class="nb">apply</span> isembedding_grouphomomorphism.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : A,
(grp_quotient_map $o inclusion F) a = group_unit -&gt;
a = group_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk21"><span class="highlight"><span class="nb">intros</span> a q0.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a = group_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="c">(* Since [inclusion F a] is killed by [grp_quotient_map], its in the image of [B]. *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk22"><span class="highlight"><span class="nb">assert</span> (in_coset :  in_cosetL (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)
                           (inclusion F a) mon_unit).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">in_cosetL
  (abses_pullback_inclusion_transpose_subgroup
     (inclusion E) F p) (inclusion F a) mon_unit</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">in_coset</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">in_cosetL
  (abses_pullback_inclusion_transpose_subgroup
     (inclusion E) F p) 
  (inclusion F a) mon_unit</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk23"><hr></label><div class="goal-conclusion"><span class="highlight">a = group_unit</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk24"><span class="highlight"><span class="mi">1</span>:{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">in_cosetL
  (abses_pullback_inclusion_transpose_subgroup
     (inclusion E) F p) 
  (inclusion F a) mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk25"><span class="highlight">nrapply related_quotient_paths.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_mere_relation F
  (in_cosetL
     (abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk26" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk26"><hr></label><div class="goal-conclusion"><span class="highlight">Transitive
  (in_cosetL
     (abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p))</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk27"><hr></label><div class="goal-conclusion"><span class="highlight">Symmetric
  (in_cosetL
     (abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p))</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk28"><hr></label><div class="goal-conclusion"><span class="highlight">Reflexive
  (in_cosetL
     (abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p))</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk29"><hr></label><div class="goal-conclusion"><span class="highlight">class_of
  (in_cosetL
     (abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p)) 
  (inclusion F a) =
class_of
  (in_cosetL
     (abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p)) mon_unit</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk2a"><span class="highlight"><span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>: <span class="bp">exact</span> _.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">class_of
  (in_cosetL
     (abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p)) 
  (inclusion F a) =
class_of
  (in_cosetL
     (abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p)) mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> q0.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk2b"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">in_coset</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">in_cosetL
  (abses_pullback_inclusion_transpose_subgroup
     (inclusion E) F p) 
  (inclusion F a) mon_unit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a = group_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="c">(* Cleaning up the context facilitates later steps. *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk2c"><span class="highlight"><span class="nb">destruct</span> in_coset <span class="kr">as</span> [b q1]; <span class="nb">rewrite</span> grp_unit_r <span class="kr">in</span> q1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
- inclusion F a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a = group_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="c">(* Since both [inclusion F] and [B -&gt; F] factor through the mono [ab_biprod A B -&gt; F], we can lift [q1] to [ab_biprod A B]. *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk2d"><span class="highlight"><span class="nb">assert</span> (q2 : ab_biprod_inr  b = ab_biprod_inl (-a)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
- inclusion F a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab_biprod_inr b = ab_biprod_inl (- a)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
- inclusion F a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ab_biprod_inr b = ab_biprod_inl (- a)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk2e"><hr></label><div class="goal-conclusion"><span class="highlight">a = group_unit</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk2f"><span class="highlight"><span class="mi">1</span>: {</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
- inclusion F a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab_biprod_inr b = ab_biprod_inl (- a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk30"><span class="highlight"><span class="nb">apply</span> (isinj_embedding (grp_pullback_pr1 _ _ $o p^$.<span class="mi">1</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
- inclusion F a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEmbedding
  (grp_pullback_pr1 (projection F) (inclusion E) $o
   (p^$).<span class="mi">1</span>)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk31" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
- inclusion F a</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk31"><hr></label><div class="goal-conclusion"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 (p^$).<span class="mi">1</span>) (ab_biprod_inr b) =
(grp_pullback_pr1 (projection F) (inclusion E) $o
 (p^$).<span class="mi">1</span>) (ab_biprod_inl (- a))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk32"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
- inclusion F a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEmbedding
  (grp_pullback_pr1 (projection F) (inclusion E) $o
   (p^$).<span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk33"><span class="highlight">nrapply (istruncmap_compose (-<span class="mi">1</span>) p^$.<span class="mi">1</span> (grp_pullback_pr1 (projection F) (inclusion E))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
- inclusion F a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEmbedding
  (grp_pullback_pr1 (projection F) (inclusion E))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
- inclusion F a</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk34"><hr></label><div class="goal-conclusion"><span class="highlight">IsEmbedding (p^$).<span class="mi">1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">all</span>: rapply istruncmap_mapinO_tr.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">         </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk35"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
- inclusion F a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 (p^$).<span class="mi">1</span>) (ab_biprod_inr b) =
(grp_pullback_pr1 (projection F) (inclusion E) $o
 (p^$).<span class="mi">1</span>) (ab_biprod_inl (- a))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk36"><span class="highlight">nrefine (q1 @ _); <span class="nb">symmetry</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
- inclusion F a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 (p^$).<span class="mi">1</span>) (ab_biprod_inl (- a)) = 
- inclusion F a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk37"><span class="highlight"><span class="nb">refine</span> (ap (grp_pullback_pr1 _ _) (fst p^$.<span class="mi">2</span> (-a)) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
- inclusion F a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">grp_pullback_pr1 (projection F) 
  (inclusion E)
  (inclusion (abses_pullback0 (inclusion E) F) (- a)) =
- inclusion F a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (grp_homo_inv _ _).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk38"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
- inclusion F a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ab_biprod_inr b = ab_biprod_inl (- a)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a = group_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="c">(* Using [q2], we conclude. *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk39"><span class="highlight"><span class="nb">pose proof</span> (q3 := ap (-) (fst ((equiv_path_prod _ _)^-<span class="mi">1</span> q2))); <span class="nb">cbn</span> <span class="kr">in</span> q3.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_quotient_map $o inclusion F) a = group_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
- inclusion F a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ab_biprod_inr b = ab_biprod_inl (- a)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">- mon_unit = - - a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a = group_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> ((negate_involutive _)^ @ q3^ @ negate_mon_unit).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk3a"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap (Tr (-<span class="mi">1</span>))
  (grp_quotient_rec F
     {|
       normalsubgroup_subgroup :=
         abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p;
       normalsubgroup_isnormal :=
         isnormal_ab_subgroup F
           (abses_pullback_inclusion_transpose_subgroup
              (inclusion E) F p)
     |} (projection E $o projection F)
     (<span class="kr">fun</span> (<span class="nv">f</span> : F)
        (<span class="nv">X</span> : {|
               normalsubgroup_subgroup :=
                 abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p;
               normalsubgroup_isnormal :=
                 isnormal_ab_subgroup F
                   (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
             |} f) =&gt;
      (<span class="kr">fun</span> (<span class="nv">b</span> : B)
         (<span class="nv">q</span> : (grp_pullback_pr1 
                 (projection F) 
                 (inclusion E) $o 
               grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
              f) =&gt;
       internal_paths_rew F
         ((grp_pullback_pr1 
             (projection F) 
             (inclusion E) $o 
           grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b)
         (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
          (projection E $o projection F) f0 = mon_unit)
         (ap (projection E)
            (abses_pullback_inclusion_transpose_beta
               (inclusion E) F p b) @
          (<span class="kr">let</span> <span class="nv">X0</span> :=
             <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
             pointed_fun (iscomplex_abses E) <span class="kr">in</span>
           X0 E b)) f q) X.<span class="mi">1</span> X.<span class="mi">2</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk3b"><span class="highlight"><span class="nb">apply</span> (cancelR_conn_map (Tr (-<span class="mi">1</span>)) grp_quotient_map).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap (Tr (-<span class="mi">1</span>)) grp_quotient_map</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk3c"><hr></label><div class="goal-conclusion"><span class="highlight">IsConnMap (Tr (-<span class="mi">1</span>))
  (<span class="kr">fun</span> <span class="nv">x</span> : F =&gt;
   grp_quotient_rec F
     {|
       normalsubgroup_subgroup :=
         abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p;
       normalsubgroup_isnormal :=
         isnormal_ab_subgroup F
           (abses_pullback_inclusion_transpose_subgroup
              (inclusion E) F p)
     |} (projection E $o projection F)
     (<span class="kr">fun</span> (<span class="nv">f</span> : F)
        (<span class="nv">X</span> : {|
               normalsubgroup_subgroup :=
                 abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p;
               normalsubgroup_isnormal :=
                 isnormal_ab_subgroup F
                   (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
             |} f) =&gt;
      internal_paths_rew F
        ((grp_pullback_pr1 
            (projection F) 
            (inclusion E) $o 
          grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
        (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
         (projection E $o projection F) f0 = mon_unit)
        (ap (projection E)
           (abses_pullback_inclusion_transpose_beta
              (inclusion E) F p X.<span class="mi">1</span>) @
         (<span class="kr">let</span> <span class="nv">X0</span> :=
            <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
            pointed_fun (iscomplex_abses E) <span class="kr">in</span>
          X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) 
     (grp_quotient_map x))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk3d"><span class="highlight"><span class="mi">1</span>: <span class="bp">exact</span> _.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap (Tr (-<span class="mi">1</span>))
  (<span class="kr">fun</span> <span class="nv">x</span> : F =&gt;
   grp_quotient_rec F
     {|
       normalsubgroup_subgroup :=
         abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p;
       normalsubgroup_isnormal :=
         isnormal_ab_subgroup F
           (abses_pullback_inclusion_transpose_subgroup
              (inclusion E) F p)
     |} (projection E $o projection F)
     (<span class="kr">fun</span> (<span class="nv">f</span> : F)
        (<span class="nv">X</span> : {|
               normalsubgroup_subgroup :=
                 abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p;
               normalsubgroup_isnormal :=
                 isnormal_ab_subgroup F
                   (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
             |} f) =&gt;
      internal_paths_rew F
        ((grp_pullback_pr1 
            (projection F) 
            (inclusion E) $o 
          grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
        (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
         (projection E $o projection F) f0 = mon_unit)
        (ap (projection E)
           (abses_pullback_inclusion_transpose_beta
              (inclusion E) F p X.<span class="mi">1</span>) @
         (<span class="kr">let</span> <span class="nv">X0</span> :=
            <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
            pointed_fun (iscomplex_abses E) <span class="kr">in</span>
          X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) 
     (grp_quotient_map x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk3e"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap (Tr (-<span class="mi">1</span>))
  (<span class="kr">fun</span> <span class="nv">x</span> : F =&gt; projection E (projection F x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk3f"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsExact (Tr (-<span class="mi">1</span>)) (grp_quotient_map $o inclusion F)
  (grp_quotient_rec F
     {|
       normalsubgroup_subgroup :=
         abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p;
       normalsubgroup_isnormal :=
         isnormal_ab_subgroup F
           (abses_pullback_inclusion_transpose_subgroup
              (inclusion E) F p)
     |} (projection E $o projection F)
     (<span class="kr">fun</span> (<span class="nv">f</span> : F)
        (<span class="nv">X</span> : {|
               normalsubgroup_subgroup :=
                 abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p;
               normalsubgroup_isnormal :=
                 isnormal_ab_subgroup F
                   (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
             |} f) =&gt;
      (<span class="kr">fun</span> (<span class="nv">b</span> : B)
         (<span class="nv">q</span> : (grp_pullback_pr1 
                 (projection F) 
                 (inclusion E) $o 
               grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
              f) =&gt;
       internal_paths_rew F
         ((grp_pullback_pr1 
             (projection F) 
             (inclusion E) $o 
           grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b)
         (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
          (projection E $o projection F) f0 = mon_unit)
         (ap (projection E)
            (abses_pullback_inclusion_transpose_beta
               (inclusion E) F p b) @
          (<span class="kr">let</span> <span class="nv">X0</span> :=
             <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
             pointed_fun (iscomplex_abses E) <span class="kr">in</span>
           X0 E b)) f q) X.<span class="mi">1</span> X.<span class="mi">2</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk40"><span class="highlight">snrapply Build_IsExact.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsComplex (grp_quotient_map $o inclusion F)
  (grp_quotient_rec F
     {|
       normalsubgroup_subgroup :=
         abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p;
       normalsubgroup_isnormal :=
         isnormal_ab_subgroup F
           (abses_pullback_inclusion_transpose_subgroup
              (inclusion E) F p)
     |} (projection E $o projection F)
     (<span class="kr">fun</span> (<span class="nv">f</span> : F)
        (<span class="nv">X</span> : {|
               normalsubgroup_subgroup :=
                 abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p;
               normalsubgroup_isnormal :=
                 isnormal_ab_subgroup F
                   (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
             |} f) =&gt;
      (<span class="kr">fun</span> (<span class="nv">b</span> : B)
         (<span class="nv">q</span> : (grp_pullback_pr1 
                 (projection F) 
                 (inclusion E) $o 
               grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
              f) =&gt;
       internal_paths_rew F
         ((grp_pullback_pr1 
             (projection F) 
             (inclusion E) $o 
           grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b)
         (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
          (projection E $o projection F) f0 = mon_unit)
         (ap (projection E)
            (abses_pullback_inclusion_transpose_beta
               (inclusion E) F p b) @
          (<span class="kr">let</span> <span class="nv">X0</span> :=
             <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
             pointed_fun (iscomplex_abses E) <span class="kr">in</span>
           X0 E b)) f q) X.<span class="mi">1</span> X.<span class="mi">2</span>))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk41"><hr></label><div class="goal-conclusion"><span class="highlight">IsConnMap (Tr (-<span class="mi">1</span>)) (cxfib <span class="nl">?cx_isexact</span>)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk42"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsComplex (grp_quotient_map $o inclusion F)
  (grp_quotient_rec F
     {|
       normalsubgroup_subgroup :=
         abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p;
       normalsubgroup_isnormal :=
         isnormal_ab_subgroup F
           (abses_pullback_inclusion_transpose_subgroup
              (inclusion E) F p)
     |} (projection E $o projection F)
     (<span class="kr">fun</span> (<span class="nv">f</span> : F)
        (<span class="nv">X</span> : {|
               normalsubgroup_subgroup :=
                 abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p;
               normalsubgroup_isnormal :=
                 isnormal_ab_subgroup F
                   (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
             |} f) =&gt;
      (<span class="kr">fun</span> (<span class="nv">b</span> : B)
         (<span class="nv">q</span> : (grp_pullback_pr1 
                 (projection F) 
                 (inclusion E) $o 
               grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
              f) =&gt;
       internal_paths_rew F
         ((grp_pullback_pr1 
             (projection F) 
             (inclusion E) $o 
           grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b)
         (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
          (projection E $o projection F) f0 = mon_unit)
         (ap (projection E)
            (abses_pullback_inclusion_transpose_beta
               (inclusion E) F p b) @
          (<span class="kr">let</span> <span class="nv">X0</span> :=
             <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
             pointed_fun (iscomplex_abses E) <span class="kr">in</span>
           X0 E b)) f q) X.<span class="mi">1</span> X.<span class="mi">2</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk43"><span class="highlight">srapply Build_pHomotopy.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   (<span class="kr">fun</span> (<span class="nv">b</span> : B)
      (<span class="nv">q</span> : (grp_pullback_pr1 
              (projection F) 
              (inclusion E) $o 
            grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
           f) =&gt;
    internal_paths_rew F
      ((grp_pullback_pr1 (projection F) (inclusion E) $o
        grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b)
      (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
       (projection E $o projection F) f0 = mon_unit)
      (ap (projection E)
         (abses_pullback_inclusion_transpose_beta
            (inclusion E) F p b) @
       (<span class="kr">let</span> <span class="nv">X0</span> :=
          <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
          pointed_fun (iscomplex_abses E) <span class="kr">in</span>
        X0 E b)) f q) X.<span class="mi">1</span> X.<span class="mi">2</span>)
o* (grp_quotient_map $o inclusion F) == pconst</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk44" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk44"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?p</span> (point A) =
dpoint_eq
  (grp_quotient_rec F
     {|
       normalsubgroup_subgroup :=
         abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p;
       normalsubgroup_isnormal :=
         isnormal_ab_subgroup F
           (abses_pullback_inclusion_transpose_subgroup
              (inclusion E) F p)
     |} (projection E $o projection F)
     (<span class="kr">fun</span> (<span class="nv">f</span> : F)
        (<span class="nv">X</span> : {|
               normalsubgroup_subgroup :=
                 abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p;
               normalsubgroup_isnormal :=
                 isnormal_ab_subgroup F
                   (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
             |} f) =&gt;
      (<span class="kr">fun</span> (<span class="nv">b</span> : B)
         (<span class="nv">q</span> : (grp_pullback_pr1 
                 (projection F) 
                 (inclusion E) $o 
               grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
              f) =&gt;
       internal_paths_rew F
         ((grp_pullback_pr1 
             (projection F) 
             (inclusion E) $o 
           grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b)
         (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
          (projection E $o projection F) f0 = mon_unit)
         (ap (projection E)
            (abses_pullback_inclusion_transpose_beta
               (inclusion E) F p b) @
          (<span class="kr">let</span> <span class="nv">X0</span> :=
             <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
             pointed_fun (iscomplex_abses E) <span class="kr">in</span>
           X0 E b)) f q) X.<span class="mi">1</span> X.<span class="mi">2</span>)
   o* (grp_quotient_map $o inclusion F)) @
(dpoint_eq pconst)^</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk45"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   (<span class="kr">fun</span> (<span class="nv">b</span> : B)
      (<span class="nv">q</span> : (grp_pullback_pr1 
              (projection F) 
              (inclusion E) $o 
            grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
           f) =&gt;
    internal_paths_rew F
      ((grp_pullback_pr1 (projection F) (inclusion E) $o
        grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b)
      (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
       (projection E $o projection F) f0 = mon_unit)
      (ap (projection E)
         (abses_pullback_inclusion_transpose_beta
            (inclusion E) F p b) @
       (<span class="kr">let</span> <span class="nv">X0</span> :=
          <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
          pointed_fun (iscomplex_abses E) <span class="kr">in</span>
        X0 E b)) f q) X.<span class="mi">1</span> X.<span class="mi">2</span>)
o* (grp_quotient_map $o inclusion F) == pconst</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk46"><span class="highlight"><span class="nb">intro</span> a; <span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection E (projection F (inclusion F a)) = point C</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk47"><span class="highlight"><span class="nb">refine</span> (ap (projection E) _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection F (inclusion F a) = <span class="nl">?Goal</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk48"><hr></label><div class="goal-conclusion"><span class="highlight">projection E <span class="nl">?Goal</span> = point C</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk49"><span class="highlight"><span class="mi">1</span>: <span class="nb">apply</span> iscomplex_abses.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection E (pconst a) = point C</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> grp_homo_unit.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk4a"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
  ap (projection E)
    (<span class="kr">let</span> <span class="nv">X</span> :=
       <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
       pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
     X F a) @ grp_homo_unit (projection E)
  :
  (grp_quotient_rec F
     {|
       normalsubgroup_subgroup :=
         abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p;
       normalsubgroup_isnormal :=
         isnormal_ab_subgroup F
           (abses_pullback_inclusion_transpose_subgroup
              (inclusion E) F p)
     |} (projection E $o projection F)
     (<span class="kr">fun</span> (<span class="nv">f</span> : F)
        (<span class="nv">X</span> : {|
               normalsubgroup_subgroup :=
                 abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p;
               normalsubgroup_isnormal :=
                 isnormal_ab_subgroup F
                   (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
             |} f) =&gt;
      internal_paths_rew F
        ((grp_pullback_pr1 
            (projection F) 
            (inclusion E) $o 
          grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
        (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
         (projection E $o projection F) f0 = mon_unit)
        (ap (projection E)
           (abses_pullback_inclusion_transpose_beta
              (inclusion E) F p X.<span class="mi">1</span>) @
         (<span class="kr">let</span> <span class="nv">X0</span> :=
            <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
            pointed_fun (iscomplex_abses E) <span class="kr">in</span>
          X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
   o* (grp_quotient_map $o inclusion F)) a = 
  pconst a)
 :
 grp_quotient_rec F
   {|
     normalsubgroup_subgroup :=
       abses_pullback_inclusion_transpose_subgroup
         (inclusion E) F p;
     normalsubgroup_isnormal :=
       isnormal_ab_subgroup F
         (abses_pullback_inclusion_transpose_subgroup
            (inclusion E) F p)
   |} (projection E $o projection F)
   (<span class="kr">fun</span> (<span class="nv">f</span> : F)
      (<span class="nv">X</span> : {|
             normalsubgroup_subgroup :=
               abses_pullback_inclusion_transpose_subgroup
                 (inclusion E) F p;
             normalsubgroup_isnormal :=
               isnormal_ab_subgroup F
                 (abses_pullback_inclusion_transpose_subgroup
                    (inclusion E) F p)
           |} f) =&gt;
    (<span class="kr">fun</span> (<span class="nv">b</span> : B)
       (<span class="nv">q</span> : (grp_pullback_pr1 
               (projection F) 
               (inclusion E) $o 
             grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
            f) =&gt;
     internal_paths_rew F
       ((grp_pullback_pr1 (projection F) (inclusion E) $o
         grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b)
       (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
        (projection E $o projection F) f0 = mon_unit)
       (ap (projection E)
          (abses_pullback_inclusion_transpose_beta
             (inclusion E) F p b) @
        (<span class="kr">let</span> <span class="nv">X0</span> :=
           <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
           pointed_fun (iscomplex_abses E) <span class="kr">in</span>
         X0 E b)) f q) X.<span class="mi">1</span> X.<span class="mi">2</span>)
 o* (grp_quotient_map $o inclusion F) == pconst)
  (point A) =
dpoint_eq
  (grp_quotient_rec F
     {|
       normalsubgroup_subgroup :=
         abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p;
       normalsubgroup_isnormal :=
         isnormal_ab_subgroup F
           (abses_pullback_inclusion_transpose_subgroup
              (inclusion E) F p)
     |} (projection E $o projection F)
     (<span class="kr">fun</span> (<span class="nv">f</span> : F)
        (<span class="nv">X</span> : {|
               normalsubgroup_subgroup :=
                 abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p;
               normalsubgroup_isnormal :=
                 isnormal_ab_subgroup F
                   (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
             |} f) =&gt;
      (<span class="kr">fun</span> (<span class="nv">b</span> : B)
         (<span class="nv">q</span> : (grp_pullback_pr1 
                 (projection F) 
                 (inclusion E) $o 
               grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
              f) =&gt;
       internal_paths_rew F
         ((grp_pullback_pr1 
             (projection F) 
             (inclusion E) $o 
           grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b)
         (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
          (projection E $o projection F) f0 = mon_unit)
         (ap (projection E)
            (abses_pullback_inclusion_transpose_beta
               (inclusion E) F p b) @
          (<span class="kr">let</span> <span class="nv">X0</span> :=
             <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
             pointed_fun (iscomplex_abses E) <span class="kr">in</span>
           X0 E b)) f q) X.<span class="mi">1</span> X.<span class="mi">2</span>)
   o* (grp_quotient_map $o inclusion F)) @
(dpoint_eq pconst)^</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> path_ishprop.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk4b"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap (Tr (-<span class="mi">1</span>))
  (cxfib
     (Build_pHomotopy
        ((<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
          ap (projection E)
            (<span class="kr">let</span> <span class="nv">X</span> :=
               <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
               pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
             X F a) @ grp_homo_unit (projection E)
          :
          (grp_quotient_rec F
             {|
               normalsubgroup_subgroup :=
                 abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p;
               normalsubgroup_isnormal :=
                 isnormal_ab_subgroup F
                   (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
             |} (projection E $o projection F)
             (<span class="kr">fun</span> (<span class="nv">f</span> : F)
                (<span class="nv">X</span> : {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (...) F p)
                     |} f) =&gt;
              internal_paths_rew F
                ((grp_pullback_pr1 
                    (projection F) 
                    (inclusion E) $o
                  grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr)
                   X.<span class="mi">1</span>)
                (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                 (projection E $o projection F) f0 =
                 mon_unit)
                (ap (projection E)
                   (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                 (<span class="kr">let</span> <span class="nv">X0</span> :=
                    <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                    pointed_fun (iscomplex_abses E) <span class="kr">in</span>
                  X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
           o* (grp_quotient_map $o inclusion F)) a =
          pconst a)
         :
         grp_quotient_rec F
           {|
             normalsubgroup_subgroup :=
               abses_pullback_inclusion_transpose_subgroup
                 (inclusion E) F p;
             normalsubgroup_isnormal :=
               isnormal_ab_subgroup F
                 (abses_pullback_inclusion_transpose_subgroup
                    (inclusion E) F p)
           |} (projection E $o projection F)
           (<span class="kr">fun</span> (<span class="nv">f</span> : F)
              (<span class="nv">X</span> : {|
                     normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                     normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                   |} f) =&gt;
            (<span class="kr">fun</span> (<span class="nv">b</span> : B)
               (<span class="nv">q</span> : (grp_pullback_pr1 
                      (projection F) 
                      (inclusion E) $o
                     grp_iso_inverse p.<span class="mi">1</span> $o
                     ab_biprod_inr) b = f) =&gt;
             internal_paths_rew F
               ((grp_pullback_pr1 
                   (projection F) 
                   (inclusion E) $o
                 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr)
                  b)
               (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                (projection E $o projection F) f0 =
                mon_unit)
               (ap (projection E)
                  (abses_pullback_inclusion_transpose_beta
                     (inclusion E) F p b) @
                (<span class="kr">let</span> <span class="nv">X0</span> :=
                   <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                   pointed_fun (iscomplex_abses E) <span class="kr">in</span>
                 X0 E b)) f q) X.<span class="mi">1</span> X.<span class="mi">2</span>)
         o* (grp_quotient_map $o inclusion F) ==
         pconst)
        (path_ishprop
           (ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F (point A)) @
            grp_homo_unit (projection E))
           (dpoint_eq
              (grp_quotient_rec F
                 {|
                   normalsubgroup_subgroup :=
                     abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                   normalsubgroup_isnormal :=
                     isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                 |} (projection E $o projection F)
                 (<span class="kr">fun</span> (<span class="nv">f</span> : F)
                    (<span class="nv">X</span> : 
                     {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                     |} f) =&gt;
                  internal_paths_rew F
                    ((grp_pullback_pr1 
                      (projection F) 
                      (inclusion E) $o
                      grp_iso_inverse p.<span class="mi">1</span> $o
                      ab_biprod_inr) X.<span class="mi">1</span>)
                    (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                     (projection E $o projection F) f0 =
                     mon_unit)
                    (ap 
                      (projection E)
                      (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                     (<span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                      pointed_fun (iscomplex_abses E)
                      <span class="kr">in</span>
                      X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
               o* (grp_quotient_map $o inclusion F)) @
            (dpoint_eq pconst)^))))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk4c"><span class="highlight"><span class="nb">intros</span> [y q].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnected (Tr (-<span class="mi">1</span>))
  (hfiber
     (cxfib
        (Build_pHomotopy
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E))
           (path_ishprop
              (ap (projection E)
                 (<span class="kr">let</span> <span class="nv">X</span> :=
                    <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                    pointed_fun (iscomplex_abses E0)
                    <span class="kr">in</span>
                  X F (point A)) @
               grp_homo_unit (projection E))
              (dpoint_eq
                 (grp_quotient_rec F
                    {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                    |} 
                    (projection E $o projection F)
                    (<span class="kr">fun</span> 
                      (<span class="nv">f</span> : F)
                      (<span class="nv">X</span> : 
                      {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (...) F p)
                      |} f) =&gt;
                     internal_paths_rew F
                      ((grp_pullback_pr1
                      (projection F) 
                      (inclusion E) $o
                      grp_iso_inverse p.<span class="mi">1</span> $o
                      ab_biprod_inr) X.<span class="mi">1</span>)
                      (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                      (projection E $o projection F)
                      f0 = mon_unit)
                      (ap 
                      (projection E)
                      (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                      (<span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                      pointed_fun (iscomplex_abses E)
                      <span class="kr">in</span>
                      X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
                  o* (grp_quotient_map $o inclusion F)) @
               (dpoint_eq pconst)^)))) 
     (y; q))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk4d"><span class="highlight"><span class="nb">apply</span> (@contr_inhabited_hprop _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (Build_pHomotopy
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E))
           (path_ishprop
              (ap (projection E)
                 (<span class="kr">let</span> <span class="nv">X</span> :=
                    <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                    pointed_fun (iscomplex_abses E0)
                    <span class="kr">in</span>
                  X F (point A)) @
               grp_homo_unit (projection E))
              (dpoint_eq
                 (grp_quotient_rec F
                    {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                    |} 
                    (projection E $o projection F)
                    (<span class="kr">fun</span> 
                      (<span class="nv">f</span> : F)
                      (<span class="nv">X</span> : 
                      {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (...) F p)
                      |} f) =&gt;
                     internal_paths_rew F
                      ((grp_pullback_pr1
                      (projection F) 
                      (inclusion E) $o
                      grp_iso_inverse p.<span class="mi">1</span> $o
                      ab_biprod_inr) X.<span class="mi">1</span>)
                      (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                      (projection E $o projection F)
                      f0 = mon_unit)
                      (ap 
                      (projection E)
                      (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                      (<span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                      pointed_fun (iscomplex_abses E)
                      <span class="kr">in</span>
                      X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
                  o* (grp_quotient_map $o inclusion F)) @
               (dpoint_eq pconst)^)))) 
     (y; q))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">      <span class="c">(* We choose a preimage by [grp_quotient_map]. *)</span>
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk4e"><span class="highlight"><span class="nb">assert</span> (f : merely (hfiber grp_quotient_map y)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">merely (hfiber grp_quotient_map y)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">merely (hfiber grp_quotient_map y)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk4f"><hr></label><div class="goal-conclusion"><span class="highlight">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (Build_pHomotopy
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E))
           (path_ishprop
              (ap (projection E)
                 (<span class="kr">let</span> <span class="nv">X</span> :=
                    <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                    pointed_fun (iscomplex_abses E0)
                    <span class="kr">in</span>
                  X F (point A)) @
               grp_homo_unit (projection E))
              (dpoint_eq
                 (grp_quotient_rec F
                    {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                    |} 
                    (projection E $o projection F)
                    (<span class="kr">fun</span> 
                      (<span class="nv">f</span> : F)
                      (<span class="nv">X</span> : 
                      {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (...) F p)
                      |} f) =&gt;
                     internal_paths_rew F
                      ((grp_pullback_pr1
                      (projection F) 
                      (inclusion E) $o
                      grp_iso_inverse p.<span class="mi">1</span> $o
                      ab_biprod_inr) X.<span class="mi">1</span>)
                      (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                      (projection E $o projection F)
                      f0 = mon_unit)
                      (ap 
                      (projection E)
                      (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                      (<span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                      pointed_fun (iscomplex_abses E)
                      <span class="kr">in</span>
                      X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
                  o* (grp_quotient_map $o inclusion F)) @
               (dpoint_eq pconst)^)))) 
     (y; q))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk50"><span class="highlight"><span class="mi">1</span>: <span class="nb">apply</span> center, issurj_class_of.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">merely (hfiber grp_quotient_map y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (Build_pHomotopy
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E))
           (path_ishprop
              (ap (projection E)
                 (<span class="kr">let</span> <span class="nv">X</span> :=
                    <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                    pointed_fun (iscomplex_abses E0)
                    <span class="kr">in</span>
                  X F (point A)) @
               grp_homo_unit (projection E))
              (dpoint_eq
                 (grp_quotient_rec F
                    {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                    |} 
                    (projection E $o projection F)
                    (<span class="kr">fun</span> 
                      (<span class="nv">f</span> : F)
                      (<span class="nv">X</span> : 
                      {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (...) F p)
                      |} f) =&gt;
                     internal_paths_rew F
                      ((grp_pullback_pr1
                      (projection F) 
                      (inclusion E) $o
                      grp_iso_inverse p.<span class="mi">1</span> $o
                      ab_biprod_inr) X.<span class="mi">1</span>)
                      (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                      (projection E $o projection F)
                      f0 = mon_unit)
                      (ap 
                      (projection E)
                      (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                      (<span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                      pointed_fun (iscomplex_abses E)
                      <span class="kr">in</span>
                      X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
                  o* (grp_quotient_map $o inclusion F)) @
               (dpoint_eq pconst)^)))) 
     (y; q))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk51"><span class="highlight">revert_opaque f; <span class="nb">apply</span> Trunc_rec; <span class="nb">intros</span> [f q0].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (Build_pHomotopy
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E))
           (path_ishprop
              (ap (projection E)
                 (<span class="kr">let</span> <span class="nv">X</span> :=
                    <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                    pointed_fun (iscomplex_abses E0)
                    <span class="kr">in</span>
                  X F (point A)) @
               grp_homo_unit (projection E))
              (dpoint_eq
                 (grp_quotient_rec F
                    {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                    |} 
                    (projection E $o projection F)
                    (<span class="kr">fun</span> 
                      (<span class="nv">f</span> : F)
                      (<span class="nv">X</span> : 
                      {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (...) F p)
                      |} f) =&gt;
                     internal_paths_rew F
                      ((grp_pullback_pr1
                      (projection F) 
                      (inclusion E) $o
                      grp_iso_inverse p.<span class="mi">1</span> $o
                      ab_biprod_inr) X.<span class="mi">1</span>)
                      (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                      (projection E $o projection F)
                      f0 = mon_unit)
                      (ap 
                      (projection E)
                      (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                      (<span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                      pointed_fun (iscomplex_abses E)
                      <span class="kr">in</span>
                      X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
                  o* (grp_quotient_map $o inclusion F)) @
               (dpoint_eq pconst)^)))) 
     (y; q))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">      <span class="c">(* Since [projection F f] is in the kernel of [projection E], we find a preimage in [B]. *)</span>
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk52"><span class="highlight"><span class="nb">assert</span> (b : merely (hfiber (inclusion E) (projection F f))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">merely (hfiber (inclusion E) (projection F f))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">merely (hfiber (inclusion E) (projection F f))</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk53"><hr></label><div class="goal-conclusion"><span class="highlight">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (Build_pHomotopy
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E))
           (path_ishprop
              (ap (projection E)
                 (<span class="kr">let</span> <span class="nv">X</span> :=
                    <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                    pointed_fun (iscomplex_abses E0)
                    <span class="kr">in</span>
                  X F (point A)) @
               grp_homo_unit (projection E))
              (dpoint_eq
                 (grp_quotient_rec F
                    {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                    |} 
                    (projection E $o projection F)
                    (<span class="kr">fun</span> 
                      (<span class="nv">f</span> : F)
                      (<span class="nv">X</span> : 
                      {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (...) F p)
                      |} f) =&gt;
                     internal_paths_rew F
                      ((grp_pullback_pr1
                      (projection F) 
                      (inclusion E) $o
                      grp_iso_inverse p.<span class="mi">1</span> $o
                      ab_biprod_inr) X.<span class="mi">1</span>)
                      (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                      (projection E $o projection F)
                      f0 = mon_unit)
                      (ap 
                      (projection E)
                      (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                      (<span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                      pointed_fun (iscomplex_abses E)
                      <span class="kr">in</span>
                      X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
                  o* (grp_quotient_map $o inclusion F)) @
               (dpoint_eq pconst)^)))) 
     (y; q))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk54"><span class="highlight"><span class="mi">1</span>: {</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">merely (hfiber (inclusion E) (projection F f))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk55"><span class="highlight">rapply isexact_preimage.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection E (projection F f) = point C</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (ap _ q0 @ q).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk56"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">merely (hfiber (inclusion E) (projection F f))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (Build_pHomotopy
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E))
           (path_ishprop
              (ap (projection E)
                 (<span class="kr">let</span> <span class="nv">X</span> :=
                    <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                    pointed_fun (iscomplex_abses E0)
                    <span class="kr">in</span>
                  X F (point A)) @
               grp_homo_unit (projection E))
              (dpoint_eq
                 (grp_quotient_rec F
                    {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                    |} 
                    (projection E $o projection F)
                    (<span class="kr">fun</span> 
                      (<span class="nv">f</span> : F)
                      (<span class="nv">X</span> : 
                      {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (...) F p)
                      |} f) =&gt;
                     internal_paths_rew F
                      ((grp_pullback_pr1
                      (projection F) 
                      (inclusion E) $o
                      grp_iso_inverse p.<span class="mi">1</span> $o
                      ab_biprod_inr) X.<span class="mi">1</span>)
                      (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                      (projection E $o projection F)
                      f0 = mon_unit)
                      (ap 
                      (projection E)
                      (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                      (<span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                      pointed_fun (iscomplex_abses E)
                      <span class="kr">in</span>
                      X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
                  o* (grp_quotient_map $o inclusion F)) @
               (dpoint_eq pconst)^)))) 
     (y; q))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk57"><span class="highlight">revert_opaque b; <span class="nb">apply</span> Trunc_rec; <span class="nb">intros</span> [b q1].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (Build_pHomotopy
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E))
           (path_ishprop
              (ap (projection E)
                 (<span class="kr">let</span> <span class="nv">X</span> :=
                    <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                    pointed_fun (iscomplex_abses E0)
                    <span class="kr">in</span>
                  X F (point A)) @
               grp_homo_unit (projection E))
              (dpoint_eq
                 (grp_quotient_rec F
                    {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                    |} 
                    (projection E $o projection F)
                    (<span class="kr">fun</span> 
                      (<span class="nv">f</span> : F)
                      (<span class="nv">X</span> : 
                      {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (...) F p)
                      |} f) =&gt;
                     internal_paths_rew F
                      ((grp_pullback_pr1
                      (projection F) 
                      (inclusion E) $o
                      grp_iso_inverse p.<span class="mi">1</span> $o
                      ab_biprod_inr) X.<span class="mi">1</span>)
                      (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                      (projection E $o projection F)
                      f0 = mon_unit)
                      (ap 
                      (projection E)
                      (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                      (<span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                      pointed_fun (iscomplex_abses E)
                      <span class="kr">in</span>
                      X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
                  o* (grp_quotient_map $o inclusion F)) @
               (dpoint_eq pconst)^)))) 
     (y; q))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">      <span class="c">(* The difference [f - b] in [F] is in the kernel of [projection F], hence lies in [A]. *)</span>
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk58"><span class="highlight"><span class="nb">assert</span> (a : merely (hfiber (inclusion F)
                                 (sg_op f (-(grp_pullback_pr1 _ _ (p^$.<span class="mi">1</span> (ab_biprod_inr b))))))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">merely
  (hfiber (inclusion F)
     (sg_op f
        (-
         grp_pullback_pr1 
           (projection F) 
           (inclusion E) 
           ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">merely
  (hfiber (inclusion F)
     (sg_op f
        (-
         grp_pullback_pr1 
           (projection F) 
           (inclusion E)
           ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))))</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk59"><hr></label><div class="goal-conclusion"><span class="highlight">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (Build_pHomotopy
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E))
           (path_ishprop
              (ap (projection E)
                 (<span class="kr">let</span> <span class="nv">X</span> :=
                    <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                    pointed_fun (iscomplex_abses E0)
                    <span class="kr">in</span>
                  X F (point A)) @
               grp_homo_unit (projection E))
              (dpoint_eq
                 (grp_quotient_rec F
                    {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                    |} 
                    (projection E $o projection F)
                    (<span class="kr">fun</span> 
                      (<span class="nv">f</span> : F)
                      (<span class="nv">X</span> : 
                      {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (...) F p)
                      |} f) =&gt;
                     internal_paths_rew F
                      ((grp_pullback_pr1
                      (projection F) 
                      (inclusion E) $o
                      grp_iso_inverse p.<span class="mi">1</span> $o
                      ab_biprod_inr) X.<span class="mi">1</span>)
                      (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                      (projection E $o projection F)
                      f0 = mon_unit)
                      (ap 
                      (projection E)
                      (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                      (<span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                      pointed_fun (iscomplex_abses E)
                      <span class="kr">in</span>
                      X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
                  o* (grp_quotient_map $o inclusion F)) @
               (dpoint_eq pconst)^)))) 
     (y; q))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk5a"><span class="highlight"><span class="mi">1</span>: {</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">merely
  (hfiber (inclusion F)
     (sg_op f
        (-
         grp_pullback_pr1 
           (projection F) 
           (inclusion E) 
           ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk5b"><span class="highlight">rapply isexact_preimage.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection F
  (sg_op f
     (-
      grp_pullback_pr1 
        (projection F) 
        (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))) =
point E</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk5c"><span class="highlight"><span class="nb">refine</span> (grp_homo_op _ _ _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sg_op (projection F f)
  (projection F
     (-
      grp_pullback_pr1 
        (projection F) 
        (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))) =
point E</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk5d"><span class="highlight"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; _ + x) (grp_homo_inv _ _) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection F f -
projection F
  (grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))) =
point E</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk5e"><span class="highlight"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; _ - x) (abses_pullback_inclusion_transpose_beta (inclusion E) F p b @ q1) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection F f - projection F f = point E</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">           </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> right_inverse.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk5f"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">merely
  (hfiber (inclusion F)
     (sg_op f
        (-
         grp_pullback_pr1 
           (projection F) 
           (inclusion E)
           ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (Build_pHomotopy
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E))
           (path_ishprop
              (ap (projection E)
                 (<span class="kr">let</span> <span class="nv">X</span> :=
                    <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                    pointed_fun (iscomplex_abses E0)
                    <span class="kr">in</span>
                  X F (point A)) @
               grp_homo_unit (projection E))
              (dpoint_eq
                 (grp_quotient_rec F
                    {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                    |} 
                    (projection E $o projection F)
                    (<span class="kr">fun</span> 
                      (<span class="nv">f</span> : F)
                      (<span class="nv">X</span> : 
                      {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (...) F p)
                      |} f) =&gt;
                     internal_paths_rew F
                      ((grp_pullback_pr1
                      (projection F) 
                      (inclusion E) $o
                      grp_iso_inverse p.<span class="mi">1</span> $o
                      ab_biprod_inr) X.<span class="mi">1</span>)
                      (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                      (projection E $o projection F)
                      f0 = mon_unit)
                      (ap 
                      (projection E)
                      (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                      (<span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                      pointed_fun (iscomplex_abses E)
                      <span class="kr">in</span>
                      X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
                  o* (grp_quotient_map $o inclusion F)) @
               (dpoint_eq pconst)^)))) 
     (y; q))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk60"><span class="highlight">revert_opaque a; <span class="nb">apply</span> Trunc_rec; <span class="nb">intros</span> [a q2].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion F a =
sg_op f
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Tr (-<span class="mi">1</span>)
  (hfiber
     (cxfib
        (Build_pHomotopy
           (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
            ap (projection E)
              (<span class="kr">let</span> <span class="nv">X</span> :=
                 <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                 pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
               X F a) @ 
            grp_homo_unit (projection E))
           (path_ishprop
              (ap (projection E)
                 (<span class="kr">let</span> <span class="nv">X</span> :=
                    <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
                    pointed_fun (iscomplex_abses E0)
                    <span class="kr">in</span>
                  X F (point A)) @
               grp_homo_unit (projection E))
              (dpoint_eq
                 (grp_quotient_rec F
                    {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                    |} 
                    (projection E $o projection F)
                    (<span class="kr">fun</span> 
                      (<span class="nv">f</span> : F)
                      (<span class="nv">X</span> : 
                      {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (...) F p)
                      |} f) =&gt;
                     internal_paths_rew F
                      ((grp_pullback_pr1
                      (projection F) 
                      (inclusion E) $o
                      grp_iso_inverse p.<span class="mi">1</span> $o
                      ab_biprod_inr) X.<span class="mi">1</span>)
                      (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                      (projection E $o projection F)
                      f0 = mon_unit)
                      (ap 
                      (projection E)
                      (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                      (<span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                      pointed_fun (iscomplex_abses E)
                      <span class="kr">in</span>
                      X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
                  o* (grp_quotient_map $o inclusion F)) @
               (dpoint_eq pconst)^)))) 
     (y; q))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">      <span class="c">(* It remains to show that [a] is the desired preimage. *)</span>
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk61"><span class="highlight"><span class="nb">refine</span> (tr (a; _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion F a =
sg_op f
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">cxfib
  (Build_pHomotopy
     (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
      ap (projection E)
        (<span class="kr">let</span> <span class="nv">X</span> :=
           <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
           pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
         X F a) @ grp_homo_unit (projection E))
     (path_ishprop
        (ap (projection E)
           (<span class="kr">let</span> <span class="nv">X</span> :=
              <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
              pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
            X F (point A)) @
         grp_homo_unit (projection E))
        (dpoint_eq
           (grp_quotient_rec F
              {|
                normalsubgroup_subgroup :=
                  abses_pullback_inclusion_transpose_subgroup
                    (inclusion E) F p;
                normalsubgroup_isnormal :=
                  isnormal_ab_subgroup F
                    (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
              |} (projection E $o projection F)
              (<span class="kr">fun</span> (<span class="nv">f</span> : F)
                 (<span class="nv">X</span> : {|
                      normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                      normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                      |} f) =&gt;
               internal_paths_rew F
                 ((grp_pullback_pr1 
                     (projection F) 
                     (inclusion E) $o
                   grp_iso_inverse p.<span class="mi">1</span> $o
                   ab_biprod_inr) X.<span class="mi">1</span>)
                 (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                  (projection E $o projection F) f0 =
                  mon_unit)
                 (ap (projection E)
                    (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                  (<span class="kr">let</span> <span class="nv">X0</span> :=
                     <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                     pointed_fun (iscomplex_abses E)
                     <span class="kr">in</span>
                   X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
            o* (grp_quotient_map $o inclusion F)) @
         (dpoint_eq pconst)^))) a = 
(y; q)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk62"><span class="highlight"><span class="kr">let</span> <span class="nv">T</span> := <span class="kp">type of</span> y <span class="kr">in</span> <span class="nb">apply</span> (@path_sigma_hprop T).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion F a =
sg_op f
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span>
<span class="nv">x</span> : abses_pullback_inclusion_transpose_endpoint&#39;
      (inclusion E) F p,
IsHProp
  (grp_quotient_rec F
     {|
       normalsubgroup_subgroup :=
         abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p;
       normalsubgroup_isnormal :=
         isnormal_ab_subgroup F
           (abses_pullback_inclusion_transpose_subgroup
              (inclusion E) F p)
     |} (projection E $o projection F)
     (<span class="kr">fun</span> (<span class="nv">f</span> : F)
        (<span class="nv">X</span> : {|
               normalsubgroup_subgroup :=
                 abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p;
               normalsubgroup_isnormal :=
                 isnormal_ab_subgroup F
                   (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
             |} f) =&gt;
      internal_paths_rew F
        ((grp_pullback_pr1 
            (projection F) 
            (inclusion E) $o 
          grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
        (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
         (projection E $o projection F) f0 = mon_unit)
        (ap (projection E)
           (abses_pullback_inclusion_transpose_beta
              (inclusion E) F p X.<span class="mi">1</span>) @
         (<span class="kr">let</span> <span class="nv">X0</span> :=
            <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
            pointed_fun (iscomplex_abses E) <span class="kr">in</span>
          X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) x = 
   point C)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk63" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion F a =
sg_op f
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk63"><hr></label><div class="goal-conclusion"><span class="highlight">(cxfib
   (Build_pHomotopy
      (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
       ap (projection E)
         (<span class="kr">let</span> <span class="nv">X</span> :=
            <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
            pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
          X F a) @ grp_homo_unit (projection E))
      (path_ishprop
         (ap (projection E)
            (<span class="kr">let</span> <span class="nv">X</span> :=
               <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
               pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
             X F (point A)) @
          grp_homo_unit (projection E))
         (dpoint_eq
            (grp_quotient_rec F
               {|
                 normalsubgroup_subgroup :=
                   abses_pullback_inclusion_transpose_subgroup
                     (inclusion E) F p;
                 normalsubgroup_isnormal :=
                   isnormal_ab_subgroup F
                     (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
               |} (projection E $o projection F)
               (<span class="kr">fun</span> (<span class="nv">f</span> : F)
                  (<span class="nv">X</span> : 
                   {|
                     normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                     normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                   |} f) =&gt;
                internal_paths_rew F
                  ((grp_pullback_pr1 
                      (projection F) 
                      (inclusion E) $o
                    grp_iso_inverse p.<span class="mi">1</span> $o
                    ab_biprod_inr) X.<span class="mi">1</span>)
                  (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                   (projection E $o projection F) f0 =
                   mon_unit)
                  (ap (projection E)
                     (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                   (<span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                      pointed_fun (iscomplex_abses E)
                      <span class="kr">in</span>
                    X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
             o* (grp_quotient_map $o inclusion F)) @
          (dpoint_eq pconst)^))) a).<span class="mi">1</span> = 
(y; q).<span class="mi">1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk64"><span class="highlight"><span class="mi">1</span>: <span class="nb">intros</span> ?; <span class="nb">apply</span> istrunc_paths; <span class="nb">apply</span> group_isgroup.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion F a =
sg_op f
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(cxfib
   (Build_pHomotopy
      (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
       ap (projection E)
         (<span class="kr">let</span> <span class="nv">X</span> :=
            <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
            pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
          X F a) @ grp_homo_unit (projection E))
      (path_ishprop
         (ap (projection E)
            (<span class="kr">let</span> <span class="nv">X</span> :=
               <span class="kr">fun</span> <span class="nv">E0</span> : AbSES&#39; E A =&gt;
               pointed_fun (iscomplex_abses E0) <span class="kr">in</span>
             X F (point A)) @
          grp_homo_unit (projection E))
         (dpoint_eq
            (grp_quotient_rec F
               {|
                 normalsubgroup_subgroup :=
                   abses_pullback_inclusion_transpose_subgroup
                     (inclusion E) F p;
                 normalsubgroup_isnormal :=
                   isnormal_ab_subgroup F
                     (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
               |} (projection E $o projection F)
               (<span class="kr">fun</span> (<span class="nv">f</span> : F)
                  (<span class="nv">X</span> : 
                   {|
                     normalsubgroup_subgroup :=
                      abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p;
                     normalsubgroup_isnormal :=
                      isnormal_ab_subgroup F
                      (abses_pullback_inclusion_transpose_subgroup
                      (inclusion E) F p)
                   |} f) =&gt;
                internal_paths_rew F
                  ((grp_pullback_pr1 
                      (projection F) 
                      (inclusion E) $o
                    grp_iso_inverse p.<span class="mi">1</span> $o
                    ab_biprod_inr) X.<span class="mi">1</span>)
                  (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
                   (projection E $o projection F) f0 =
                   mon_unit)
                  (ap (projection E)
                     (abses_pullback_inclusion_transpose_beta
                      (inclusion E) F p X.<span class="mi">1</span>) @
                   (<span class="kr">let</span> <span class="nv">X0</span> :=
                      <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
                      pointed_fun (iscomplex_abses E)
                      <span class="kr">in</span>
                    X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>)
             o* (grp_quotient_map $o inclusion F)) @
          (dpoint_eq pconst)^))) a).<span class="mi">1</span> = 
(y; q).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk65"><span class="highlight"><span class="nb">refine</span> (ap grp_quotient_map q2 @ _ @ q0).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion F a =
sg_op f
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">grp_quotient_map
  (sg_op f
     (-
      grp_pullback_pr1 
        (projection F) 
        (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))) =
grp_quotient_map f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk66"><span class="highlight"><span class="nb">refine</span> (grp_homo_op _ _ _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion F a =
sg_op f
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sg_op (grp_quotient_map f)
  (grp_quotient_map
     (-
      grp_pullback_pr1 
        (projection F) 
        (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))) =
grp_quotient_map f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk67"><span class="highlight"><span class="nb">apply</span> grp_moveR_Mg.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion F a =
sg_op f
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">grp_quotient_map
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))) =
sg_op (- grp_quotient_map f) (grp_quotient_map f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk68"><span class="highlight"><span class="nb">refine</span> (_ @ (left_inverse _)^).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion F a =
sg_op f
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">grp_quotient_map
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))) =
congquot_mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk69"><span class="highlight"><span class="nb">apply</span> qglue.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion F a =
sg_op f
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">in_cosetL
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |}
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))
  mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk6a"><span class="highlight"><span class="kr">exists</span> <span class="nv">b</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion F a =
sg_op f
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
sg_op
  (-
   -
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))
  mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk6b"><span class="highlight"><span class="nb">refine</span> (_ @ (grp_unit_r _)^).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback_inclusion_transpose_endpoint&#39;
  (inclusion E) F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |} (projection E $o projection F)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   internal_paths_rew F
     ((grp_pullback_pr1 
         (projection F) 
         (inclusion E) $o 
       grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) X.<span class="mi">1</span>)
     (<span class="kr">fun</span> <span class="nv">f0</span> : F =&gt;
      (projection E $o projection F) f0 = mon_unit)
     (ap (projection E)
        (abses_pullback_inclusion_transpose_beta
           (inclusion E) F p X.<span class="mi">1</span>) @
      (<span class="kr">let</span> <span class="nv">X0</span> :=
         <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; C B =&gt;
         pointed_fun (iscomplex_abses E) <span class="kr">in</span>
       X0 E X.<span class="mi">1</span>)) f X.<span class="mi">2</span>) y = 
point C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">grp_quotient_map f = y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion E b = projection F f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inclusion F a =
sg_op f
  (-
   grp_pullback_pr1 (projection F) 
     (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b =
-
-
grp_pullback_pr1 (projection F) 
  (inclusion E) ((p^$).<span class="mi">1</span> (ab_biprod_inr b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (negate_involutive _)^.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** That [abses_pullback_trivial_preimage E F p] pulls back to [F] is immediate from [abses_component1_trivial_pullback] and the following map. As such, we&#39;ve shown that sequences which become trivial after pulling back along [inclusion E] are in the image of pullback along [projection E]. *)</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk6c"><span class="highlight"><span class="kn">Definition</span> <span class="nf">abses_pullback_inclusion0_map&#39;</span> `{Univalence} {A B C : AbGroup} (E : AbSES C B)
           (F : AbSES (middle E) A) (p : abses_pullback0 (inclusion E) F $== point _)
  : AbSESMorphism F (abses_pullback_trivial_preimage E F p).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">AbSESMorphism F
  (abses_pullback_trivial_preimage E F p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk6d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">AbSESMorphism F
  (abses_pullback_trivial_preimage E F p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk6e"><span class="highlight">srapply Build_AbSESMorphism.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A $-&gt; A</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk6f"><hr></label><div class="goal-conclusion"><span class="highlight">F $-&gt; abses_pullback_trivial_preimage E F p</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk70" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk70"><hr></label><div class="goal-conclusion"><span class="highlight">E $-&gt; C</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk71" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk71"><hr></label><div class="goal-conclusion"><span class="highlight">inclusion (abses_pullback_trivial_preimage E F p) $o
<span class="nl">?component1</span> == <span class="nl">?component2</span> $o inclusion F</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk72" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk72"><hr></label><div class="goal-conclusion"><span class="highlight">projection (abses_pullback_trivial_preimage E F p) $o
<span class="nl">?component2</span> == <span class="nl">?component3</span> $o projection F</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk73"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A $-&gt; A</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> grp_homo_id.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk74"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">F $-&gt; abses_pullback_trivial_preimage E F p</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> grp_quotient_map.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk75"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">E $-&gt; C</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (projection E).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk76"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inclusion (abses_pullback_trivial_preimage E F p) $o
grp_homo_id == grp_quotient_map $o inclusion F</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk77"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection (abses_pullback_trivial_preimage E F p) $o
grp_quotient_map == projection E $o projection F</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** For exactness we need not only a preimage of [F] but a preimage of [(F,p)] along [cxfib]. We now define and prove this in terms of path data. *)</span>

<span class="sd">(** The analog of [cxfib] induced by pullback in terms of path data. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk78"><span class="highlight"><span class="kn">Definition</span> <span class="nf">cxfib&#39;</span> `{Funext} {A B C : AbGroup} (E : AbSES C B)
  : AbSES C A -&gt; graph_hfiber (abses_pullback0 (A:=A) (inclusion E)) (point _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">AbSES C A -&gt;
graph_hfiber (abses_pullback0 (inclusion E))
  (point (AbSES B A))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk79"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">AbSES C A -&gt;
graph_hfiber (abses_pullback0 (inclusion E))
  (point (AbSES B A))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk7a"><span class="highlight"><span class="nb">intro</span> Y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">graph_hfiber (abses_pullback0 (inclusion E))
  (point (AbSES B A))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk7b"><span class="highlight"><span class="kr">exists</span> (<span class="nv">abses_pullback0</span> (projection E) Y).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">abses_pullback0 (inclusion E)
  (abses_pullback0 (projection E) Y) $-&gt;
point (AbSES B A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk7c"><span class="highlight"><span class="nb">refine</span> (abses_pullback_compose&#39; _ _ Y $@ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">abses_pullback0 (projection E $o inclusion E) Y $==
point (AbSES B A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk7d"><span class="highlight"><span class="nb">refine</span> (abses_pullback_homotopic&#39; _ grp_homo_const _ Y $@ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection E $o inclusion E == grp_homo_const</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk7e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk7e"><hr></label><div class="goal-conclusion"><span class="highlight">abses_pullback0 grp_homo_const Y $== point (AbSES B A)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk7f"><span class="highlight"><span class="mi">1</span>: rapply iscomplex_abses.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">abses_pullback0 grp_homo_const Y $== point (AbSES B A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">symmetry</span>; <span class="nb">apply</span> abses_pullback_const&#39;.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">hfiber_cxfib&#39;</span> `{Funext} {A B C : AbGroup} (E : AbSES C B)
           (F : AbSES (middle E) A) (p : abses_pullback0 (inclusion E) F $== point _)
  := {Y : AbSES C A &amp; hfiber_abses_path (cxfib&#39; E Y) (F; p)}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* This is just [idpath], but Coq takes too long to see that. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk80"><span class="highlight"><span class="kn">Definition</span> <span class="nf">pr2_cxfib&#39;</span> `{Univalence} {A B C : AbGroup} {E : AbSES C B} (U : AbSES C A)
  : equiv_ptransformation_phomotopy (iscomplex_abses_pullback&#39; _ _ (iscomplex_abses E)) U
    = equiv_path_abses_iso (cxfib&#39; E U).<span class="mi">2</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_ptransformation_phomotopy
  (iscomplex_abses_pullback&#39; (inclusion E)
     (projection E) (iscomplex_abses E)) U =
equiv_path_abses_iso (cxfib&#39; E U).<span class="mi">2</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk81"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_ptransformation_phomotopy
  (iscomplex_abses_pullback&#39; (inclusion E)
     (projection E) (iscomplex_abses E)) U =
equiv_path_abses_iso (cxfib&#39; E U).<span class="mi">2</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk82"><span class="highlight"><span class="nb">change</span> (equiv_ptransformation_phomotopy (iscomplex_abses_pullback&#39; _ _ (iscomplex_abses E)) U)
    <span class="kr">with</span> (equiv_path_abses_iso ((iscomplex_abses_pullback&#39; _ _ (iscomplex_abses E)).<span class="mi">1</span> U)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_path_abses_iso
  ((iscomplex_abses_pullback&#39; (inclusion E)
      (projection E) (iscomplex_abses E)).<span class="mi">1</span> U) =
equiv_path_abses_iso (cxfib&#39; E U).<span class="mi">2</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk83"><span class="highlight"><span class="nb">apply</span> (ap equiv_path_abses_iso).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(iscomplex_abses_pullback&#39; (inclusion E)
   (projection E) (iscomplex_abses E)).<span class="mi">1</span> U =
(cxfib&#39; E U).<span class="mi">2</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk84"><span class="highlight">rapply path_hom.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(iscomplex_abses_pullback&#39; (inclusion E)
   (projection E) (iscomplex_abses E)).<span class="mi">1</span> U $==
(cxfib&#39; E U).<span class="mi">2</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk85"><span class="highlight"><span class="nb">refine</span> (_ $@R abses_pullback_compose&#39; (inclusion E) (projection E) U);
    <span class="nb">unfold</span> trans_comp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(abses_pullback_pconst&#39; ^*$).<span class="mi">1</span> U $o
(abses_pullback_phomotopic&#39;
   (projection E $o inclusion E) grp_homo_const
   (iscomplex_abses E)).<span class="mi">1</span> U $==
abses_pullback_homotopic&#39;
  (projection E $o inclusion E) grp_homo_const
  (iscomplex_abses E) U $@
symmetric_GpdHom (point (AbSES B A))
  (abses_pullback0 grp_homo_const U)
  (abses_pullback_const&#39; U)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk86"><span class="highlight"><span class="nb">refine</span> (_ $@R abses_pullback_homotopic&#39; (projection E $o inclusion E) grp_homo_const (iscomplex_abses E) U).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(abses_pullback_pconst&#39;.<span class="mi">1</span> U)^$ $==
symmetric_GpdHom (point (AbSES B A))
  (abses_pullback0 grp_homo_const U)
  (abses_pullback_const&#39; U)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Making [abses_pullback&#39;] opaque speeds up the following proof. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Opaque</span> abses_pullback&#39;.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk87"><span class="highlight"><span class="kn">Definition</span> <span class="nf">eq_cxfib_cxfib&#39;</span> `{Univalence} {A B C : AbGroup} {E : AbSES C B} (U : AbSES C A)
  : cxfib (iscomplex_pullback_abses E) U = equiv_hfiber_abses _ _ (cxfib&#39; E U).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">cxfib (iscomplex_pullback_abses E) U =
equiv_hfiber_abses (abses_pullback0 (inclusion E))
  (point (AbSES B A)) (cxfib&#39; E U)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk88"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">cxfib (iscomplex_pullback_abses E) U =
equiv_hfiber_abses (abses_pullback0 (inclusion E))
  (point (AbSES B A)) (cxfib&#39; E U)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk89"><span class="highlight">srapply path_sigma.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(cxfib (iscomplex_pullback_abses E) U).<span class="mi">1</span> =
(equiv_hfiber_abses (abses_pullback0 (inclusion E))
   (point (AbSES B A)) (cxfib&#39; E U)).<span class="mi">1</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk8a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk8a"><hr></label><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : AbSES E A =&gt;
   abses_pullback (inclusion E) x = point (AbSES B A))
  <span class="nl">?p</span> (cxfib (iscomplex_pullback_abses E) U).<span class="mi">2</span> =
(equiv_hfiber_abses (abses_pullback0 (inclusion E))
   (point (AbSES B A)) (cxfib&#39; E U)).<span class="mi">2</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk8b"><span class="highlight"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : AbSES E A =&gt;
   abses_pullback (inclusion E) x = point (AbSES B A))
  <span class="mi">1</span> (cxfib (iscomplex_pullback_abses E) U).<span class="mi">2</span> =
(equiv_hfiber_abses (abses_pullback0 (inclusion E))
   (point (AbSES B A)) (cxfib&#39; E U)).<span class="mi">2</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk8c"><span class="highlight">nrefine (concat_p1 _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(to_pointed_compose (abses_pullback&#39; (projection E))
   (abses_pullback&#39; (inclusion E)) @*
 (<span class="kr">let</span> <span class="nv">X</span> := equiv_fun equiv_ptransformation_phomotopy
    <span class="kr">in</span>
  X
    (iscomplex_abses_pullback&#39; (inclusion E)
       (projection E) (iscomplex_abses E)))) U =
(equiv_hfiber_abses (abses_pullback0 (inclusion E))
   (point (AbSES B A)) (cxfib&#39; E U)).<span class="mi">2</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk8d"><span class="highlight">nrefine (concat_1p _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">let</span> <span class="nv">X</span> := equiv_fun equiv_ptransformation_phomotopy <span class="kr">in</span>
 X
   (iscomplex_abses_pullback&#39; (inclusion E)
      (projection E) (iscomplex_abses E))) U =
(equiv_hfiber_abses (abses_pullback0 (inclusion E))
   (point (AbSES B A)) (cxfib&#39; E U)).<span class="mi">2</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk8e"><span class="highlight"><span class="nb">cbn</span> zeta.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_ptransformation_phomotopy
  (iscomplex_abses_pullback&#39; (inclusion E)
     (projection E) (iscomplex_abses E)) U =
(equiv_hfiber_abses (abses_pullback0 (inclusion E))
   (point (AbSES B A)) (cxfib&#39; E U)).<span class="mi">2</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk8f"><span class="highlight"><span class="nb">unfold</span> equiv_hfiber_abses, equiv_functor_sigma_id, equiv_functor_sigma&#39;, equiv_functor_sigma, equiv_fun, functor_sigma, <span class="s2">&quot;.2&quot;</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_ptransformation_phomotopy
  (iscomplex_abses_pullback&#39; (inclusion E)
     (projection E) (iscomplex_abses E)) U =
equiv_path_abses_iso (cxfib&#39; E U).<span class="mi">2</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  <span class="c">(* The goal looks identical to [pr2_cxfib&#39;], but the implicit argument to [@paths] is expressed differently, which is why the next line isn&#39;t faster. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (@pr2_cxfib&#39; _ A B C E U).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Transparent</span> abses_pullback&#39;.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk90"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_hfiber_cxfib&#39;</span> `{Univalence} {A B C : AbGroup} {E : AbSES C B}
           (F : AbSES (middle E) A) (p : abses_pullback0 (inclusion E) F $== point _)
  : hfiber_cxfib&#39; E F p &lt;~&gt; hfiber (cxfib (iscomplex_pullback_abses E))
                  (equiv_hfiber_abses _ (point _) (F;p)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber_cxfib&#39; E F p &lt;~&gt;
hfiber (cxfib (iscomplex_pullback_abses E))
  (equiv_hfiber_abses (abses_pullback0 (inclusion E))
     (point (AbSES B A)) (F; p))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk91"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber_cxfib&#39; E F p &lt;~&gt;
hfiber (cxfib (iscomplex_pullback_abses E))
  (equiv_hfiber_abses (abses_pullback0 (inclusion E))
     (point (AbSES B A)) (F; p))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk92"><span class="highlight">srapply equiv_functor_sigma_id; <span class="nb">intro</span> U; <span class="nb">lazy</span> beta.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber_abses_path (cxfib&#39; E U) (F; p) &lt;~&gt;
cxfib (iscomplex_pullback_abses E) U =
equiv_hfiber_abses (abses_pullback0 (inclusion E))
  (point (AbSES B A)) (F; p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk93"><span class="highlight"><span class="nb">refine</span> (_ oE equiv_hfiber_abses_pullback _ _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">cxfib&#39; E U = (F; p) &lt;~&gt;
cxfib (iscomplex_pullback_abses E) U =
equiv_hfiber_abses (abses_pullback0 (inclusion E))
  (point (AbSES B A)) (F; p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk94"><span class="highlight"><span class="nb">refine</span> (_ oE equiv_ap&#39; (equiv_hfiber_abses _ (point _)) _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_hfiber_abses (abses_pullback0 (inclusion E))
  (point (AbSES B A)) (cxfib&#39; E U) =
equiv_hfiber_abses (abses_pullback0 (inclusion E))
  (point (AbSES B A)) (F; p) &lt;~&gt;
cxfib (iscomplex_pullback_abses E) U =
equiv_hfiber_abses (abses_pullback0 (inclusion E))
  (point (AbSES B A)) (F; p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk95"><span class="highlight"><span class="nb">apply</span> equiv_concat_l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">cxfib (iscomplex_pullback_abses E) U =
equiv_hfiber_abses (abses_pullback0 (inclusion E))
  (point (AbSES B A)) (cxfib&#39; E U)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> eq_cxfib_cxfib&#39;.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The type of paths in [hfiber_cxfib&#39;] in terms of path data. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk96"><span class="highlight"><span class="kn">Definition</span> <span class="nf">path_hfiber_cxfib&#39;</span> `{Funext} {A B C : AbGroup} {E : AbSES C B}
           {F : AbSES (middle E) A} {p : abses_pullback0 (inclusion E) F $== point _}
           (X Y : hfiber_cxfib&#39; (B:=B) E F p)
  : <span class="kt">Type</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X, Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">Type</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk97"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X, Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">Type</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk98"><span class="highlight"><span class="nb">refine</span> (sig (<span class="kr">fun</span> <span class="nv">q0</span> : X.<span class="mi">1</span> $== Y.<span class="mi">1</span> =&gt; _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X, Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X.<span class="mi">1</span> $== Y.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">Type</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> ((fmap (abses_pullback0 (projection E)) q0)^$ $@ X.<span class="mi">2</span>.<span class="mi">1</span> $== Y.<span class="mi">2</span>.<span class="mi">1</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk99"><span class="highlight"><span class="kn">Definition</span> <span class="nf">transport_hfiber_abses_path_cxfib&#39;_l</span> `{Univalence} {A B C : AbGroup} {E : AbSES C B}
           (F : AbSES (middle E) A) (p : abses_pullback0 (inclusion E) F $== point _)
           (U V : hfiber_cxfib&#39; E F p) (q : U.<span class="mi">1</span> = V.<span class="mi">1</span>)
  : (transport (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt; hfiber_abses_path (cxfib&#39; E Y) (F; p)) q U.<span class="mi">2</span>).<span class="mi">1</span>
    = fmap (abses_pullback0 (projection E)) (equiv_path_abses_iso^-<span class="mi">1</span> q^) $@ U.<span class="mi">2</span>.<span class="mi">1</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">U.<span class="mi">1</span> = V.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(transport
   (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt;
    hfiber_abses_path (cxfib&#39; E Y) (F; p)) q U.<span class="mi">2</span>).<span class="mi">1</span> =
fmap (abses_pullback0 (projection E))
  (equiv_path_abses_iso^-<span class="mi">1</span> q^) $@ (U.<span class="mi">2</span>).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk9a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">U.<span class="mi">1</span> = V.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(transport
   (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt;
    hfiber_abses_path (cxfib&#39; E Y) (F; p)) q U.<span class="mi">2</span>).<span class="mi">1</span> =
fmap (abses_pullback0 (projection E))
  (equiv_path_abses_iso^-<span class="mi">1</span> q^) $@ (U.<span class="mi">2</span>).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk9b"><span class="highlight"><span class="nb">induction</span> q.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(transport
   (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt;
    hfiber_abses_path (cxfib&#39; E Y) (F; p)) <span class="mi">1</span> U.<span class="mi">2</span>).<span class="mi">1</span> =
fmap (abses_pullback0 (projection E))
  (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>^) $@ (U.<span class="mi">2</span>).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk9c"><span class="highlight"><span class="nb">refine</span> (ap pr1 (transport_1 _ _) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(U.<span class="mi">2</span>).<span class="mi">1</span> =
fmap (abses_pullback0 (projection E))
  (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>^) $@ (U.<span class="mi">2</span>).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk9d"><span class="highlight"><span class="nb">refine</span> (_ @ ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; fmap (abses_pullback0 (projection E)) x $@ _) equiv_path_absesV_1^).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(U.<span class="mi">2</span>).<span class="mi">1</span> =
fmap (abses_pullback0 (projection E)) (Id U.<span class="mi">1</span>) $@
(U.<span class="mi">2</span>).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk9e"><span class="highlight"><span class="nb">refine</span> (_ @ ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x $@ _) (fmap_id_strong _ _)^).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(U.<span class="mi">2</span>).<span class="mi">1</span> =
Id (abses_pullback0 (projection E) U.<span class="mi">1</span>) $@ (U.<span class="mi">2</span>).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (cat_idr_strong _)^.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk9f"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_path_hfiber_cxfib&#39;</span> `{Univalence} {A B C : AbGroup} {E : AbSES C B}
           (F : AbSES (middle E) A) (p : abses_pullback0 (inclusion E) F $== point _)
           (U V : hfiber_cxfib&#39; E F p)
  : path_hfiber_cxfib&#39; U V &lt;~&gt; U = V.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">path_hfiber_cxfib&#39; U V &lt;~&gt; U = V</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka0"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">path_hfiber_cxfib&#39; U V &lt;~&gt; U = V</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka1"><span class="highlight"><span class="nb">refine</span> (equiv_path_sigma _ _ _ oE _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">path_hfiber_cxfib&#39; U V &lt;~&gt;
{p0 : U.<span class="mi">1</span> = V.<span class="mi">1</span> &amp;
transport
  (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt;
   hfiber_abses_path (cxfib&#39; E Y) (F; p)) p0 U.<span class="mi">2</span> = V.<span class="mi">2</span>}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka2"><span class="highlight">srapply (equiv_functor_sigma&#39; equiv_path_abses_iso);
    <span class="nb">intro</span> q; <span class="nb">lazy</span> beta.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt;
transport
  (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt;
   hfiber_abses_path (cxfib&#39; E Y) (F; p))
  (equiv_path_abses_iso q) U.<span class="mi">2</span> = V.<span class="mi">2</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka3"><span class="highlight"><span class="nb">refine</span> (equiv_path_sigma_hprop _ _ oE _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt;
(transport
   (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt;
    hfiber_abses_path (cxfib&#39; E Y) (F; p))
   (equiv_path_abses_iso q) U.<span class="mi">2</span>).<span class="mi">1</span> = (V.<span class="mi">2</span>).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka4"><span class="highlight"><span class="nb">refine</span> (equiv_concat_l _ _ oE _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(transport
   (<span class="kr">fun</span> <span class="nv">Y</span> : AbSES C A =&gt;
    hfiber_abses_path (cxfib&#39; E Y) (F; p))
   (equiv_path_abses_iso q) U.<span class="mi">2</span>).<span class="mi">1</span> = <span class="nl">?Goal</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chka5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chka5"><hr></label><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt; <span class="nl">?Goal</span> = (V.<span class="mi">2</span>).<span class="mi">1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka6"><span class="highlight"><span class="mi">1</span>: <span class="nb">apply</span> transport_hfiber_abses_path_cxfib&#39;_l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt;
fmap (abses_pullback0 (projection E))
  (equiv_path_abses_iso^-<span class="mi">1</span> (equiv_path_abses_iso q)^) $@
(U.<span class="mi">2</span>).<span class="mi">1</span> = (V.<span class="mi">2</span>).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka7"><span class="highlight"><span class="nb">refine</span> (equiv_path_sigma_hprop _ _ oE equiv_concat_l _ _ oE _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (projection E))
   (equiv_path_abses_iso^-<span class="mi">1</span> (equiv_path_abses_iso q)^) $@
 (U.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span> = <span class="nl">?Goal</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chka8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chka8"><hr></label><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt; <span class="nl">?Goal</span> = ((V.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chka9"><span class="highlight"><span class="mi">1</span>: {</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (projection E))
   (equiv_path_abses_iso^-<span class="mi">1</span> (equiv_path_abses_iso q)^) $@
 (U.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span> = <span class="nl">?Goal</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkaa"><span class="highlight"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (fmap (abses_pullback0 _) x $@ _).<span class="mi">1</span>) _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_path_abses_iso^-<span class="mi">1</span> (equiv_path_abses_iso q)^ =
<span class="nl">?Goal0</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkab"><span class="highlight">nrefine (ap _ (abses_path_data_V q) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_path_abses_iso^-<span class="mi">1</span>
  (equiv_path_abses_iso (abses_path_data_inverse q)) =
<span class="nl">?Goal0</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> eissect.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkac"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt;
(fmap (abses_pullback0 (projection E))
   (abses_path_data_inverse q) $@ (U.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span> =
((V.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkad"><span class="highlight"><span class="nb">refine</span> (equiv_concat_l _ _ oE _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (projection E))
   (abses_path_data_inverse q) $@ (U.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span> = <span class="nl">?Goal</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chkae"><hr></label><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt; <span class="nl">?Goal</span> = ((V.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkaf"><span class="highlight"><span class="mi">1</span>: {</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (projection E))
   (abses_path_data_inverse q) $@ (U.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span> = <span class="nl">?Goal</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb0"><span class="highlight"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (x $@ _).<span class="mi">1</span>) _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap (abses_pullback0 (projection E))
  (abses_path_data_inverse q) = <span class="nl">?Goal0</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">rapply gpd_strong_1functor_V.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb1"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">U, V</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (projection E)) q)^$ $@ (U.<span class="mi">2</span>).<span class="mi">1</span> $==
(V.<span class="mi">2</span>).<span class="mi">1</span> &lt;~&gt;
((fmap (abses_pullback0 (projection E)) q)^$ $@
 (U.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span> = ((V.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> equiv_path_groupisomorphism.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The fibre of [cxfib&#39;] over [(F;p)] is inhabited. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb2"><span class="highlight"><span class="kn">Definition</span> <span class="nf">hfiber_cxfib&#39;_inhabited</span> `{Univalence} {A B C : AbGroup} (E : AbSES C B)
      (F : AbSES (middle E) A) (p : abses_pullback (inclusion E) F $== point _)
  : hfiber_cxfib&#39; E F p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber_cxfib&#39; E F p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber_cxfib&#39; E F p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb4"><span class="highlight"><span class="kr">exists</span> (<span class="nv">abses_pullback_trivial_preimage</span> <span class="nv">E</span> <span class="nv">F</span> <span class="nv">p</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber_abses_path
  (cxfib&#39; E (abses_pullback_trivial_preimage E F p))
  (F; p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb5"><span class="highlight">srefine (_^$; _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(F; p).<span class="mi">1</span> $-&gt;
(cxfib&#39; E (abses_pullback_trivial_preimage E F p)).<span class="mi">1</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkb6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chkb6"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span>
   <span class="nv">p0</span> : (cxfib&#39; E
           (abses_pullback_trivial_preimage E F p)).<span class="mi">1</span> $-&gt;
        (F; p).<span class="mi">1</span> =&gt;
 (fmap (abses_pullback0 (inclusion E)) p0)^$ $@
 (cxfib&#39; E (abses_pullback_trivial_preimage E F p)).<span class="mi">2</span> $-&gt;
 (F; p).<span class="mi">2</span>) <span class="nl">?Goal</span>^$</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb7"><span class="highlight"><span class="mi">1</span>: <span class="bp">by</span> rapply (abses_component1_trivial_pullback&#39; (abses_pullback_inclusion0_map&#39; E F p)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span>
   <span class="nv">p0</span> : (cxfib&#39; E
           (abses_pullback_trivial_preimage E F p)).<span class="mi">1</span> $-&gt;
        (F; p).<span class="mi">1</span> =&gt;
 (fmap (abses_pullback0 (inclusion E)) p0)^$ $@
 (cxfib&#39; E (abses_pullback_trivial_preimage E F p)).<span class="mi">2</span> $-&gt;
 (F; p).<span class="mi">2</span>)
  (abses_component1_trivial_pullback&#39;
     (abses_pullback_inclusion0_map&#39; E F p)
     (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>%path))^$</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb8"><span class="highlight"><span class="nb">lazy</span> beta; <span class="nb">unfold</span> pr2.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (inclusion E))
   (abses_component1_trivial_pullback&#39;
      (abses_pullback_inclusion0_map&#39; E F p)
      (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>%path))^$)^$ $@
(cxfib&#39; E (abses_pullback_trivial_preimage E F p)).<span class="mi">2</span> $-&gt;
p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkb9"><span class="highlight"><span class="nb">refine</span> (cat_assoc _ _ _ $@ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">abses_pullback_homotopic&#39;
  (projection E $o inclusion E) grp_homo_const
  (iscomplex_abses E)
  (abses_pullback_trivial_preimage E F p) $@
symmetric_GpdHom (point (AbSES B A))
  (abses_pullback0 grp_homo_const
     (abses_pullback_trivial_preimage E F p))
  (abses_pullback_const&#39;
     (abses_pullback_trivial_preimage E F p)) $o
(abses_pullback_compose&#39; (inclusion E) (projection E)
   (abses_pullback_trivial_preimage E F p) $o
 (fmap (abses_pullback0 (inclusion E))
    (abses_component1_trivial_pullback&#39;
       (abses_pullback_inclusion0_map&#39; E F p)
       (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>%path))^$)^$) $== p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkba"><span class="highlight"><span class="nb">refine</span> (cat_assoc _ _ _ $@ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">symmetric_GpdHom (point (AbSES B A))
  (abses_pullback0 grp_homo_const
     (abses_pullback_trivial_preimage E F p))
  (abses_pullback_const&#39;
     (abses_pullback_trivial_preimage E F p)) $o
(abses_pullback_homotopic&#39;
   (projection E $o inclusion E) grp_homo_const
   (iscomplex_abses E)
   (abses_pullback_trivial_preimage E F p) $o
 (abses_pullback_compose&#39; (inclusion E) (projection E)
    (abses_pullback_trivial_preimage E F p) $o
  (fmap (abses_pullback0 (inclusion E))
     (abses_component1_trivial_pullback&#39;
        (abses_pullback_inclusion0_map&#39; E F p)
        (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>%path))^$)^$)) $== p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkbb"><span class="highlight"><span class="nb">apply</span> gpd_moveR_Vh.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">abses_pullback_homotopic&#39;
  (projection E $o inclusion E) grp_homo_const
  (iscomplex_abses E)
  (abses_pullback_trivial_preimage E F p) $o
(abses_pullback_compose&#39; (inclusion E) (projection E)
   (abses_pullback_trivial_preimage E F p) $o
 (fmap (abses_pullback0 (inclusion E))
    (abses_component1_trivial_pullback&#39;
       (abses_pullback_inclusion0_map&#39; E F p)
       (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>%path))^$)^$) $==
abses_pullback_const&#39;
  (abses_pullback_trivial_preimage E F p) $o p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkbc"><span class="highlight"><span class="nb">apply</span> gpd_moveL_hM.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">abses_pullback_homotopic&#39;
  (projection E $o inclusion E) grp_homo_const
  (iscomplex_abses E)
  (abses_pullback_trivial_preimage E F p) $o
(abses_pullback_compose&#39; (inclusion E) (projection E)
   (abses_pullback_trivial_preimage E F p) $o
 (fmap (abses_pullback0 (inclusion E))
    (abses_component1_trivial_pullback&#39;
       (abses_pullback_inclusion0_map&#39; E F p)
       (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>%path))^$)^$) $o p^$ $==
abses_pullback_const&#39;
  (abses_pullback_trivial_preimage E F p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkbd"><span class="highlight"><span class="nb">apply</span> equiv_path_biprod_corec.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(((abses_pullback_homotopic&#39;
     (projection E $o inclusion E) grp_homo_const
     (iscomplex_abses E)
     (abses_pullback_trivial_preimage E F p) $o
   (abses_pullback_compose&#39; (inclusion E)
      (projection E)
      (abses_pullback_trivial_preimage E F p) $o
    (fmap (abses_pullback0 (inclusion E))
       (abses_component1_trivial_pullback&#39;
          (abses_pullback_inclusion0_map&#39; E F p)
          (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>%path))^$)^$) $o p^$).<span class="mi">1</span> $o
  ab_biprod_inl ==
  (abses_pullback_const&#39;
     (abses_pullback_trivial_preimage E F p)).<span class="mi">1</span> $o
  ab_biprod_inl) *
 ((abses_pullback_homotopic&#39;
     (projection E $o inclusion E) grp_homo_const
     (iscomplex_abses E)
     (abses_pullback_trivial_preimage E F p) $o
   (abses_pullback_compose&#39; (inclusion E)
      (projection E)
      (abses_pullback_trivial_preimage E F p) $o
    (fmap (abses_pullback0 (inclusion E))
       (abses_component1_trivial_pullback&#39;
          (abses_pullback_inclusion0_map&#39; E F p)
          (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>%path))^$)^$) $o p^$).<span class="mi">1</span> $o
  ab_biprod_inr ==
  (abses_pullback_const&#39;
     (abses_pullback_trivial_preimage E F p)).<span class="mi">1</span> $o
  ab_biprod_inr))%type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkbe"><span class="highlight"><span class="nb">split</span>; <span class="nb">apply</span> equiv_path_pullback_rec_hset; <span class="nb">split</span>; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, x1)))
      (sg_op (- x0) y))
   (pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (x, mon_unit)))) ==
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, x1)))
      (sg_op (- x0) y)) (inclusion F x))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkbf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chkbf"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; pullback_pr2 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (x, mon_unit))) ==
(<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; mon_unit)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkc0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chkc0"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, x1)))
      (sg_op (- x0) y))
   (pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, x)))) ==
(<span class="kr">fun</span> <span class="nv">_</span> : B =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, x1)))
      (sg_op (- x0) y)) (inclusion F mon_unit))</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkc1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chkc1"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; pullback_pr2 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, x))) ==
idmap</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc2"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, x1)))
      (sg_op (- x0) y))
   (pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (x, mon_unit)))) ==
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, x1)))
      (sg_op (- x0) y)) (inclusion F x))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc3"><span class="highlight"><span class="nb">intro</span> a.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : F =&gt;
   hfiber
     (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt;
      pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, x0)))
     (sg_op (- x) y))
  (pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (a, mon_unit))) =
class_of
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : F =&gt;
   hfiber
     (<span class="kr">fun</span> <span class="nv">x0</span> : B =&gt;
      pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, x0)))
     (sg_op (- x) y)) (inclusion F a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc4"><span class="highlight"><span class="nb">refine</span> (ap (class_of _) _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (a, mon_unit)) = inclusion F a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (ap pullback_pr1 (fst p^$.<span class="mi">2</span> a)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc5"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; pullback_pr2 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (x, mon_unit))) ==
(<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; mon_unit)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc6"><span class="highlight"><span class="nb">intro</span> a.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pullback_pr2 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (a, mon_unit)) = mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> ((snd p^$.<span class="mi">2</span> _)^).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc7"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, x1)))
      (sg_op (- x0) y))
   (pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, x)))) ==
(<span class="kr">fun</span> <span class="nv">_</span> : B =&gt;
 class_of
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : F =&gt;
    hfiber
      (<span class="kr">fun</span> <span class="nv">x1</span> : B =&gt;
       pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, x1)))
      (sg_op (- x0) y)) (inclusion F mon_unit))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc8"><span class="highlight"><span class="nb">intro</span> b; <span class="nb">apply</span> qglue.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber
  (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, x)))
  (sg_op (- pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, b)))
     (inclusion F mon_unit))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkc9"><span class="highlight"><span class="kr">exists</span> (-b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, - b)) =
sg_op (- pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, b)))
  (inclusion F mon_unit)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkca"><span class="highlight"><span class="nb">apply</span> grp_moveL_Vg.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sg_op (pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, b)))
  (pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, - b))) =
inclusion F mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkcb"><span class="highlight"><span class="nb">refine</span> ((grp_homo_op (grp_pullback_pr1 _ _ $o p^$.<span class="mi">1</span> $o ab_biprod_inr) _ _)^ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 (p^$).<span class="mi">1</span> $o ab_biprod_inr) (sg_op b (group_inverse b)) =
inclusion F mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (ap _ (right_inverse _) @ grp_homo_unit _ @ (grp_homo_unit _)^).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkcc"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; pullback_pr2 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, x))) ==
idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkcd"><span class="highlight"><span class="nb">intro</span> b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback (inclusion E) F $==
point (pfam_const (AbSES B A) F)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pullback_pr2 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (mon_unit, b)) = b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> ((snd p^$.<span class="mi">2</span> _)^).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** To conclude exactness in terms of path data, we show that the fibre is a proposition, hence contractible. *)</span>

<span class="sd">(** Given a point [(Y;Q)] in the fiber of [cxfib&#39;] over [(F;p)] there is an induced map as follows. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkce"><span class="highlight"><span class="kn">Definition</span> <span class="nf">hfiber_cxfib&#39;_induced_map</span> `{Funext} {A B C : AbGroup} (E : AbSES C B)
      (F : AbSES (middle E) A) (p : abses_pullback0 (inclusion E) F $== point _)
      (Y : hfiber_cxfib&#39; E F p)
  : ab_biprod A B $-&gt; abses_pullback0 (projection E) Y.<span class="mi">1</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab_biprod A B $-&gt; abses_pullback0 (projection E) Y.<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkcf"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab_biprod A B $-&gt; abses_pullback0 (projection E) Y.<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd0"><span class="highlight"><span class="nb">destruct</span> Y <span class="kr">as</span> [Y q].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab_biprod A B $-&gt;
abses_pullback0 (projection E) (Y; q).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd1"><span class="highlight"><span class="nb">refine</span> (grp_homo_compose _ (grp_iso_inverse p.<span class="mi">1</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">GroupHomomorphism (abses_pullback0 (inclusion E) F)
  (abses_pullback0 (projection E) (Y; q).<span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd2"><span class="highlight"><span class="nb">refine</span> (_ $o grp_pullback_pr1 _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">F $-&gt; abses_pullback0 (projection E) (Y; q).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (q.<span class="mi">1</span>^$.<span class="mi">1</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** There is &quot;another&quot; obvious induced map. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd3"><span class="highlight"><span class="kn">Definition</span> <span class="nf">abses_pullback_splits_induced_map&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : AbGroup}
           (<span class="nv">E</span> : AbSES C B) (<span class="nv">Y</span> : AbSES C A)
  : ab_biprod A B $-&gt; abses_pullback0 (projection E) Y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab_biprod A B $-&gt; abses_pullback0 (projection E) Y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd4"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab_biprod A B $-&gt; abses_pullback0 (projection E) Y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd5"><span class="highlight">srapply (ab_biprod_rec (inclusion _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">B $-&gt; abses_pullback0 (projection E) Y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd6"><span class="highlight">srapply grp_pullback_corec.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">B $-&gt; Y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkd7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chkd7"><hr></label><div class="goal-conclusion"><span class="highlight">B $-&gt; E</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkd8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chkd8"><hr></label><div class="goal-conclusion"><span class="highlight">projection Y o <span class="nl">?b</span> == projection E o <span class="nl">?c</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkd9"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">B $-&gt; Y</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> grp_homo_const.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkda"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">B $-&gt; E</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (inclusion E).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkdb"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection Y o grp_homo_const ==
projection E o inclusion E</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkdc"><span class="highlight"><span class="nb">intro</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection Y (grp_homo_const x) =
projection E (inclusion E x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkdd"><span class="highlight"><span class="nb">refine</span> (grp_homo_unit _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">mon_unit = projection E (inclusion E x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">symmetry</span>; <span class="nb">apply</span> iscomplex_abses.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkde"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">fmap_hfiber_abses_lemma</span> `{Univalence} {A B B&#39; : AbGroup} (f : B&#39; $-&gt; B)
           (X Y : graph_hfiber (abses_pullback0 (A:=A) f) (point _)) (Q : hfiber_abses_path X Y)
  : fmap (abses_pullback0 f) Q.<span class="mi">1</span>^$ $o Y.<span class="mi">2</span>^$ $== X.<span class="mi">2</span>^$.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B&#39; $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X, Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">graph_hfiber (abses_pullback0 f)
  (point (AbSES B&#39; A))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path X Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap (abses_pullback0 f) (Q.<span class="mi">1</span>)^$ $o (Y.<span class="mi">2</span>)^$ $==
(X.<span class="mi">2</span>)^$</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkdf"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B&#39; $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X, Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">graph_hfiber (abses_pullback0 f)
  (point (AbSES B&#39; A))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path X Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap (abses_pullback0 f) (Q.<span class="mi">1</span>)^$ $o (Y.<span class="mi">2</span>)^$ $==
(X.<span class="mi">2</span>)^$</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chke0"><span class="highlight"><span class="nb">generalize</span> Q.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B&#39; $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X, Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">graph_hfiber (abses_pullback0 f)
  (point (AbSES B&#39; A))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path X Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">Q</span> : hfiber_abses_path X Y,
fmap (abses_pullback0 f) (Q.<span class="mi">1</span>)^$ $o (Y.<span class="mi">2</span>)^$ $==
(X.<span class="mi">2</span>)^$</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chke1"><span class="highlight">equiv_intro (equiv_hfiber_abses_pullback _ X Y)^-<span class="mi">1</span>%equiv p;
    <span class="nb">induction</span> p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B&#39; $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">graph_hfiber (abses_pullback0 f)
  (point (AbSES B&#39; A))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path X X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap (abses_pullback0 f)
  ((((equiv_hfiber_abses_pullback (point (AbSES B&#39; A))
        X X)^-<span class="mi">1</span>)%equiv <span class="mi">1</span>%path).<span class="mi">1</span>)^$ $o (X.<span class="mi">2</span>)^$ $==
(X.<span class="mi">2</span>)^$</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chke2"><span class="highlight"><span class="nb">refine</span> ((_ $@R _) $@ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B&#39; $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">graph_hfiber (abses_pullback0 f)
  (point (AbSES B&#39; A))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path X X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap (abses_pullback0 f)
  ((((equiv_hfiber_abses_pullback (point (AbSES B&#39; A))
        X X)^-<span class="mi">1</span>)%equiv <span class="mi">1</span>%path).<span class="mi">1</span>)^$ $== <span class="nl">?Goal</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chke3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B&#39; $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">graph_hfiber (abses_pullback0 f)
  (point (AbSES B&#39; A))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path X X</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chke3"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> $o (X.<span class="mi">2</span>)^$ $== (X.<span class="mi">2</span>)^$</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chke4"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B&#39; $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">graph_hfiber (abses_pullback0 f)
  (point (AbSES B&#39; A))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path X X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap (abses_pullback0 f)
  ((((equiv_hfiber_abses_pullback (point (AbSES B&#39; A))
        X X)^-<span class="mi">1</span>)%equiv <span class="mi">1</span>%path).<span class="mi">1</span>)^$ $== <span class="nl">?Goal</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chke5"><span class="highlight"><span class="kn">Unshelve</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B&#39; $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">graph_hfiber (abses_pullback0 f)
  (point (AbSES B&#39; A))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path X X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap (abses_pullback0 f)
  ((((equiv_hfiber_abses_pullback (point (AbSES B&#39; A))
        X X)^-<span class="mi">1</span>)%equiv <span class="mi">1</span>%path).<span class="mi">1</span>)^$ $== <span class="nl">?Goal</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chke6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B&#39; $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">graph_hfiber (abses_pullback0 f)
  (point (AbSES B&#39; A))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path X X</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chke6"><hr></label><div class="goal-conclusion"><span class="highlight">abses_pullback0 f X.<span class="mi">1</span> $-&gt; abses_pullback0 f X.<span class="mi">1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chke7"><span class="highlight"><span class="mi">2</span>: <span class="bp">exact</span> (Id _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B&#39; $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">graph_hfiber (abses_pullback0 f)
  (point (AbSES B&#39; A))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path X X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fmap (abses_pullback0 f)
  ((((equiv_hfiber_abses_pullback (point (AbSES B&#39; A))
        X X)^-<span class="mi">1</span>)%equiv <span class="mi">1</span>%path).<span class="mi">1</span>)^$ $==
Id (abses_pullback0 f X.<span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chke8"><span class="highlight"><span class="nb">refine</span> (fmap2 _ _ $@ fmap_id _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B&#39; $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">graph_hfiber (abses_pullback0 f)
  (point (AbSES B&#39; A))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path X X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((((equiv_hfiber_abses_pullback (point (AbSES B&#39; A)) X
      X)^-<span class="mi">1</span>)%equiv <span class="mi">1</span>%path).<span class="mi">1</span>)^$ $== Id X.<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intro</span> x; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chke9"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, B'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B&#39; $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">graph_hfiber (abses_pullback0 f)
  (point (AbSES B&#39; A))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path X X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Id (abses_pullback0 f X.<span class="mi">1</span>) $o (X.<span class="mi">2</span>)^$ $== (X.<span class="mi">2</span>)^$</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (cat_idl _).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkea"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">induced_map_eq</span> `{Univalence} {A B C : AbGroup} (E : AbSES C B)
      (F : AbSES (middle E) A) (p : abses_pullback0 (inclusion E) F $== point _)
      (Y : hfiber_cxfib&#39; E F p)
  : hfiber_cxfib&#39;_induced_map E F p Y == abses_pullback_splits_induced_map&#39; E Y.<span class="mi">1</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber_cxfib&#39;_induced_map E F p Y ==
abses_pullback_splits_induced_map&#39; E Y.<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkeb"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber_cxfib&#39;_induced_map E F p Y ==
abses_pullback_splits_induced_map&#39; E Y.<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkec"><span class="highlight"><span class="nb">intros</span> [a b]; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(((Y.<span class="mi">2</span>).<span class="mi">1</span>).<span class="mi">1</span>)^-<span class="mi">1</span> (pullback_pr1 ((p.<span class="mi">1</span>)^-<span class="mi">1</span> (a, b))) =
grp_pullback_sgop (projection Y.<span class="mi">1</span>) (projection E)
  (inclusion Y.<span class="mi">1</span> a; mon_unit;
  cx_isexact a @ (grp_homo_unit (projection E))^)
  (mon_unit; inclusion E b;
  grp_homo_unit (projection Y.<span class="mi">1</span>) @
  (iscomplex_abses E b)^)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chked"><span class="highlight"><span class="nb">refine</span> (ap pullback_pr1 (fmap_hfiber_abses_lemma _ _ (F;p) Y.<span class="mi">2</span> _) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pullback_pr1 ((((cxfib&#39; E Y.<span class="mi">1</span>).<span class="mi">2</span>)^$).<span class="mi">1</span> (a, b)) =
grp_pullback_sgop (projection Y.<span class="mi">1</span>) (projection E)
  (inclusion Y.<span class="mi">1</span> a; mon_unit;
  cx_isexact a @ (grp_homo_unit (projection E))^)
  (mon_unit; inclusion E b;
  grp_homo_unit (projection Y.<span class="mi">1</span>) @
  (iscomplex_abses E b)^)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkee"><span class="highlight">srapply equiv_path_pullback_hset; <span class="nb">split</span>; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inclusion Y.<span class="mi">1</span> a = sg_op (inclusion Y.<span class="mi">1</span> a) mon_unit</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkef" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chkef"><hr></label><div class="goal-conclusion"><span class="highlight">inclusion E b = sg_op mon_unit (inclusion E b)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf0"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inclusion Y.<span class="mi">1</span> a = sg_op (inclusion Y.<span class="mi">1</span> a) mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (grp_unit_r _)^.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf1"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inclusion E b = sg_op mon_unit (inclusion E b)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (grp_unit_l _)^.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Given another point [(Y,Q)] in the fibre of [cxfib&#39;] over [(F;p)], we get path data in [AbSES C A]. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf2"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">hfiber_cxfib&#39;_induced_path&#39;0</span> `{Univalence} {A B C : AbGroup} (E : AbSES C B)
      (F : AbSES (middle E) A) (p : abses_pullback0 (inclusion E) F $== point _)
      (Y : hfiber_cxfib&#39; E F p)
  : abses_pullback_trivial_preimage E F p $== Y.<span class="mi">1</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">abses_pullback_trivial_preimage E F p $== Y.<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">abses_pullback_trivial_preimage E F p $== Y.<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf4"><span class="highlight"><span class="nb">destruct</span> Y <span class="kr">as</span> [Y Q].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">abses_pullback_trivial_preimage E F p $== (Y; Q).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf5"><span class="highlight"><span class="nb">apply</span> abses_path_data_to_iso;
    srefine (_; (_,_)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">GroupHomomorphism
  (abses_pullback_trivial_preimage E F p) (Y; Q).<span class="mi">1</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkf6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chkf6"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?proj1</span> $o
inclusion (abses_pullback_trivial_preimage E F p) ==
inclusion (Y; Q).<span class="mi">1</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkf7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chkf7"><hr></label><div class="goal-conclusion"><span class="highlight">projection (abses_pullback_trivial_preimage E F p) ==
projection (Y; Q).<span class="mi">1</span> $o <span class="nl">?proj1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf8"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">GroupHomomorphism
  (abses_pullback_trivial_preimage E F p) (Y; Q).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkf9"><span class="highlight">srapply grp_quotient_rec.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">F $-&gt; (Y; Q).<span class="mi">1</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chkfa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chkfa"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : F,
{|
  normalsubgroup_subgroup :=
    abses_pullback_inclusion_transpose_subgroup
      (inclusion E) F p;
  normalsubgroup_isnormal :=
    isnormal_ab_subgroup F
      (abses_pullback_inclusion_transpose_subgroup
         (inclusion E) F p)
|} n -&gt; <span class="nl">?f</span> n = mon_unit</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkfb"><span class="highlight"><span class="mi">1</span>: <span class="bp">exact</span> (grp_pullback_pr1 _ _$o (Q.<span class="mi">1</span>^$).<span class="mi">1</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : F,
{|
  normalsubgroup_subgroup :=
    abses_pullback_inclusion_transpose_subgroup
      (inclusion E) F p;
  normalsubgroup_isnormal :=
    isnormal_ab_subgroup F
      (abses_pullback_inclusion_transpose_subgroup
         (inclusion E) F p)
|} n -&gt;
(grp_pullback_pr1 (projection Y) (projection E) $o
 ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>) n = mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkfc"><span class="highlight"><span class="nb">intros</span> f [b q0].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b = f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(grp_pullback_pr1 (projection Y) (projection E) $o
 ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>) f = mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkfd"><span class="highlight"><span class="nb">refine</span> (ap _ q0^ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b = f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(grp_pullback_pr1 (projection Y) (projection E) $o
 ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
  ((grp_pullback_pr1 (projection F) (inclusion E) $o
    grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b) =
mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkfe"><span class="highlight">nrefine (ap _ (induced_map_eq E F p (Y;Q) _) @ _); <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(grp_pullback_pr1 (projection F) (inclusion E) $o
 grp_iso_inverse p.<span class="mi">1</span> $o ab_biprod_inr) b = f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sg_op (inclusion Y mon_unit) mon_unit = mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (grp_unit_r _ @ grp_homo_unit _).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chkff"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |}
  (grp_pullback_pr1 (projection Y) (projection E) $o
   ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   (<span class="kr">fun</span> (<span class="nv">b</span> : B)
      (<span class="nv">q0</span> : (grp_pullback_pr1 (projection F)
               (inclusion E) $o grp_iso_inverse p.<span class="mi">1</span> $o
             ab_biprod_inr) b = f) =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E) $o
       ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>) q0^ @
    (ap
       (grp_pullback_pr1 (projection Y) (projection E))
       (induced_map_eq E F p (Y; Q) (ab_biprod_inr b)) @
     (grp_unit_r (inclusion Y mon_unit) @
      grp_homo_unit (inclusion Y)
      :
      grp_pullback_pr1 (projection Y) (projection E)
        (abses_pullback_splits_induced_map&#39; E (Y; Q).<span class="mi">1</span>
           (ab_biprod_inr b)) = mon_unit))) X.<span class="mi">1</span> X.<span class="mi">2</span>) $o
inclusion (abses_pullback_trivial_preimage E F p) ==
inclusion (Y; Q).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk100"><span class="highlight"><span class="nb">intro</span> a.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(grp_quotient_rec F
   {|
     normalsubgroup_subgroup :=
       abses_pullback_inclusion_transpose_subgroup
         (inclusion E) F p;
     normalsubgroup_isnormal :=
       isnormal_ab_subgroup F
         (abses_pullback_inclusion_transpose_subgroup
            (inclusion E) F p)
   |}
   (grp_pullback_pr1 (projection Y) (projection E) $o
    ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
   (<span class="kr">fun</span> (<span class="nv">f</span> : F)
      (<span class="nv">X</span> : {|
             normalsubgroup_subgroup :=
               abses_pullback_inclusion_transpose_subgroup
                 (inclusion E) F p;
             normalsubgroup_isnormal :=
               isnormal_ab_subgroup F
                 (abses_pullback_inclusion_transpose_subgroup
                    (inclusion E) F p)
           |} f) =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E) $o
       ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>) (X.<span class="mi">2</span>)^ @
    (ap
       (grp_pullback_pr1 (projection Y) (projection E))
       (induced_map_eq E F p (Y; Q)
          (ab_biprod_inr X.<span class="mi">1</span>)) @
     (grp_unit_r (inclusion Y mon_unit) @
      grp_homo_unit (inclusion Y)))) $o
 inclusion (abses_pullback_trivial_preimage E F p)) a =
inclusion (Y; Q).<span class="mi">1</span> a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk101"><span class="highlight"><span class="nb">refine</span> (_ @ ap (grp_pullback_pr1 _ _) (fst (Q.<span class="mi">1</span>^$).<span class="mi">2</span> a)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(grp_quotient_rec F
   {|
     normalsubgroup_subgroup :=
       abses_pullback_inclusion_transpose_subgroup
         (inclusion E) F p;
     normalsubgroup_isnormal :=
       isnormal_ab_subgroup F
         (abses_pullback_inclusion_transpose_subgroup
            (inclusion E) F p)
   |}
   (grp_pullback_pr1 (projection Y) (projection E) $o
    ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
   (<span class="kr">fun</span> (<span class="nv">f</span> : F)
      (<span class="nv">X</span> : {|
             normalsubgroup_subgroup :=
               abses_pullback_inclusion_transpose_subgroup
                 (inclusion E) F p;
             normalsubgroup_isnormal :=
               isnormal_ab_subgroup F
                 (abses_pullback_inclusion_transpose_subgroup
                    (inclusion E) F p)
           |} f) =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E) $o
       ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>) (X.<span class="mi">2</span>)^ @
    (ap
       (grp_pullback_pr1 (projection Y) (projection E))
       (induced_map_eq E F p (Y; Q)
          (ab_biprod_inr X.<span class="mi">1</span>)) @
     (grp_unit_r (inclusion Y mon_unit) @
      grp_homo_unit (inclusion Y)))) $o
 inclusion (abses_pullback_trivial_preimage E F p)) a =
grp_pullback_pr1 (projection Y) (projection E)
  ((((Q.<span class="mi">1</span>)^$).<span class="mi">1</span> $o inclusion (F; p).<span class="mi">1</span>) a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (grp_quotient_rec_beta&#39; _ F _ _ (inclusion F a)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk102"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection (abses_pullback_trivial_preimage E F p) ==
projection (Y; Q).<span class="mi">1</span> $o
grp_quotient_rec F
  {|
    normalsubgroup_subgroup :=
      abses_pullback_inclusion_transpose_subgroup
        (inclusion E) F p;
    normalsubgroup_isnormal :=
      isnormal_ab_subgroup F
        (abses_pullback_inclusion_transpose_subgroup
           (inclusion E) F p)
  |}
  (grp_pullback_pr1 (projection Y) (projection E) $o
   ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
  (<span class="kr">fun</span> (<span class="nv">f</span> : F)
     (<span class="nv">X</span> : {|
            normalsubgroup_subgroup :=
              abses_pullback_inclusion_transpose_subgroup
                (inclusion E) F p;
            normalsubgroup_isnormal :=
              isnormal_ab_subgroup F
                (abses_pullback_inclusion_transpose_subgroup
                   (inclusion E) F p)
          |} f) =&gt;
   (<span class="kr">fun</span> (<span class="nv">b</span> : B)
      (<span class="nv">q0</span> : (grp_pullback_pr1 (projection F)
               (inclusion E) $o grp_iso_inverse p.<span class="mi">1</span> $o
             ab_biprod_inr) b = f) =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E) $o
       ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>) q0^ @
    (ap
       (grp_pullback_pr1 (projection Y) (projection E))
       (induced_map_eq E F p (Y; Q) (ab_biprod_inr b)) @
     (grp_unit_r (inclusion Y mon_unit) @
      grp_homo_unit (inclusion Y)
      :
      grp_pullback_pr1 (projection Y) (projection E)
        (abses_pullback_splits_induced_map&#39; E (Y; Q).<span class="mi">1</span>
           (ab_biprod_inr b)) = mon_unit))) X.<span class="mi">1</span> X.<span class="mi">2</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk103"><span class="highlight">nrapply (conn_map_elim _ grp_quotient_map).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap <span class="nl">?Goal</span> grp_quotient_map</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk104" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk104"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span>
<span class="nv">b</span> : QuotientGroup F
      {|
        normalsubgroup_subgroup :=
          abses_pullback_inclusion_transpose_subgroup
            (inclusion E) F p;
        normalsubgroup_isnormal :=
          isnormal_ab_subgroup F
            (abses_pullback_inclusion_transpose_subgroup
               (inclusion E) F p)
      |},
In <span class="nl">?Goal</span>
  (projection (abses_pullback_trivial_preimage E F p)
     b =
   (projection (Y; Q).<span class="mi">1</span> $o
    grp_quotient_rec F
      {|
        normalsubgroup_subgroup :=
          abses_pullback_inclusion_transpose_subgroup
            (inclusion E) F p;
        normalsubgroup_isnormal :=
          isnormal_ab_subgroup F
            (abses_pullback_inclusion_transpose_subgroup
               (inclusion E) F p)
      |}
      (grp_pullback_pr1 (projection Y) (projection E) $o
       ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
      (<span class="kr">fun</span> (<span class="nv">f</span> : F)
         (<span class="nv">X</span> : {|
                normalsubgroup_subgroup :=
                  abses_pullback_inclusion_transpose_subgroup
                    (inclusion E) F p;
                normalsubgroup_isnormal :=
                  isnormal_ab_subgroup F
                    (abses_pullback_inclusion_transpose_subgroup
                       (inclusion E) F p)
              |} f) =&gt;
       ap
         (grp_pullback_pr1 (projection Y)
            (projection E) $o ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>) (X.<span class="mi">2</span>)^ @
       (ap
          (grp_pullback_pr1 (projection Y)
             (projection E))
          (induced_map_eq E F p (Y; Q)
             (ab_biprod_inr X.<span class="mi">1</span>)) @
        (grp_unit_r (inclusion Y mon_unit) @
         grp_homo_unit (inclusion Y))))) b)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk105" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk105"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : F,
projection (abses_pullback_trivial_preimage E F p)
  (grp_quotient_map a) =
(projection (Y; Q).<span class="mi">1</span> $o
 grp_quotient_rec F
   {|
     normalsubgroup_subgroup :=
       abses_pullback_inclusion_transpose_subgroup
         (inclusion E) F p;
     normalsubgroup_isnormal :=
       isnormal_ab_subgroup F
         (abses_pullback_inclusion_transpose_subgroup
            (inclusion E) F p)
   |}
   (grp_pullback_pr1 (projection Y) (projection E) $o
    ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
   (<span class="kr">fun</span> (<span class="nv">f</span> : F)
      (<span class="nv">X</span> : {|
             normalsubgroup_subgroup :=
               abses_pullback_inclusion_transpose_subgroup
                 (inclusion E) F p;
             normalsubgroup_isnormal :=
               isnormal_ab_subgroup F
                 (abses_pullback_inclusion_transpose_subgroup
                    (inclusion E) F p)
           |} f) =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E) $o
       ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>) (X.<span class="mi">2</span>)^ @
    (ap
       (grp_pullback_pr1 (projection Y) (projection E))
       (induced_map_eq E F p (Y; Q)
          (ab_biprod_inr X.<span class="mi">1</span>)) @
     (grp_unit_r (inclusion Y mon_unit) @
      grp_homo_unit (inclusion Y)))))
  (grp_quotient_map a)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk106"><span class="highlight"><span class="mi">1</span>: <span class="nb">apply</span> issurj_class_of.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span>
<span class="nv">b</span> : QuotientGroup F
      {|
        normalsubgroup_subgroup :=
          abses_pullback_inclusion_transpose_subgroup
            (inclusion E) F p;
        normalsubgroup_isnormal :=
          isnormal_ab_subgroup F
            (abses_pullback_inclusion_transpose_subgroup
               (inclusion E) F p)
      |},
In (Tr (-<span class="mi">1</span>))
  (projection (abses_pullback_trivial_preimage E F p)
     b =
   (projection (Y; Q).<span class="mi">1</span> $o
    grp_quotient_rec F
      {|
        normalsubgroup_subgroup :=
          abses_pullback_inclusion_transpose_subgroup
            (inclusion E) F p;
        normalsubgroup_isnormal :=
          isnormal_ab_subgroup F
            (abses_pullback_inclusion_transpose_subgroup
               (inclusion E) F p)
      |}
      (grp_pullback_pr1 (projection Y) (projection E) $o
       ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
      (<span class="kr">fun</span> (<span class="nv">f</span> : F)
         (<span class="nv">X</span> : {|
                normalsubgroup_subgroup :=
                  abses_pullback_inclusion_transpose_subgroup
                    (inclusion E) F p;
                normalsubgroup_isnormal :=
                  isnormal_ab_subgroup F
                    (abses_pullback_inclusion_transpose_subgroup
                       (inclusion E) F p)
              |} f) =&gt;
       ap
         (grp_pullback_pr1 (projection Y)
            (projection E) $o ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>) (X.<span class="mi">2</span>)^ @
       (ap
          (grp_pullback_pr1 (projection Y)
             (projection E))
          (induced_map_eq E F p (Y; Q)
             (ab_biprod_inr X.<span class="mi">1</span>)) @
        (grp_unit_r (inclusion Y mon_unit) @
         grp_homo_unit (inclusion Y))))) b)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk107" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk107"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : F,
projection (abses_pullback_trivial_preimage E F p)
  (grp_quotient_map a) =
(projection (Y; Q).<span class="mi">1</span> $o
 grp_quotient_rec F
   {|
     normalsubgroup_subgroup :=
       abses_pullback_inclusion_transpose_subgroup
         (inclusion E) F p;
     normalsubgroup_isnormal :=
       isnormal_ab_subgroup F
         (abses_pullback_inclusion_transpose_subgroup
            (inclusion E) F p)
   |}
   (grp_pullback_pr1 (projection Y) (projection E) $o
    ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
   (<span class="kr">fun</span> (<span class="nv">f</span> : F)
      (<span class="nv">X</span> : {|
             normalsubgroup_subgroup :=
               abses_pullback_inclusion_transpose_subgroup
                 (inclusion E) F p;
             normalsubgroup_isnormal :=
               isnormal_ab_subgroup F
                 (abses_pullback_inclusion_transpose_subgroup
                    (inclusion E) F p)
           |} f) =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E) $o
       ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>) (X.<span class="mi">2</span>)^ @
    (ap
       (grp_pullback_pr1 (projection Y) (projection E))
       (induced_map_eq E F p (Y; Q)
          (ab_biprod_inr X.<span class="mi">1</span>)) @
     (grp_unit_r (inclusion Y mon_unit) @
      grp_homo_unit (inclusion Y)))))
  (grp_quotient_map a)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk108"><span class="highlight"><span class="mi">1</span>: <span class="nb">intros</span> ?; <span class="nb">apply</span> istrunc_paths; <span class="nb">apply</span> group_isgroup.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : F,
projection (abses_pullback_trivial_preimage E F p)
  (grp_quotient_map a) =
(projection (Y; Q).<span class="mi">1</span> $o
 grp_quotient_rec F
   {|
     normalsubgroup_subgroup :=
       abses_pullback_inclusion_transpose_subgroup
         (inclusion E) F p;
     normalsubgroup_isnormal :=
       isnormal_ab_subgroup F
         (abses_pullback_inclusion_transpose_subgroup
            (inclusion E) F p)
   |}
   (grp_pullback_pr1 (projection Y) (projection E) $o
    ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
   (<span class="kr">fun</span> (<span class="nv">f</span> : F)
      (<span class="nv">X</span> : {|
             normalsubgroup_subgroup :=
               abses_pullback_inclusion_transpose_subgroup
                 (inclusion E) F p;
             normalsubgroup_isnormal :=
               isnormal_ab_subgroup F
                 (abses_pullback_inclusion_transpose_subgroup
                    (inclusion E) F p)
           |} f) =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E) $o
       ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>) (X.<span class="mi">2</span>)^ @
    (ap
       (grp_pullback_pr1 (projection Y) (projection E))
       (induced_map_eq E F p (Y; Q)
          (ab_biprod_inr X.<span class="mi">1</span>)) @
     (grp_unit_r (inclusion Y mon_unit) @
      grp_homo_unit (inclusion Y)))))
  (grp_quotient_map a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk109"><span class="highlight"><span class="nb">intro</span> f.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection (abses_pullback_trivial_preimage E F p)
  (grp_quotient_map f) =
(projection (Y; Q).<span class="mi">1</span> $o
 grp_quotient_rec F
   {|
     normalsubgroup_subgroup :=
       abses_pullback_inclusion_transpose_subgroup
         (inclusion E) F p;
     normalsubgroup_isnormal :=
       isnormal_ab_subgroup F
         (abses_pullback_inclusion_transpose_subgroup
            (inclusion E) F p)
   |}
   (grp_pullback_pr1 (projection Y) (projection E) $o
    ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
   (<span class="kr">fun</span> (<span class="nv">f</span> : F)
      (<span class="nv">X</span> : {|
             normalsubgroup_subgroup :=
               abses_pullback_inclusion_transpose_subgroup
                 (inclusion E) F p;
             normalsubgroup_isnormal :=
               isnormal_ab_subgroup F
                 (abses_pullback_inclusion_transpose_subgroup
                    (inclusion E) F p)
           |} f) =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E) $o
       ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>) (X.<span class="mi">2</span>)^ @
    (ap
       (grp_pullback_pr1 (projection Y) (projection E))
       (induced_map_eq E F p (Y; Q)
          (ab_biprod_inr X.<span class="mi">1</span>)) @
     (grp_unit_r (inclusion Y mon_unit) @
      grp_homo_unit (inclusion Y)))))
  (grp_quotient_map f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk10a"><span class="highlight"><span class="nb">refine</span> (ap (projection E) (snd (Q.<span class="mi">1</span>^$).<span class="mi">2</span> f) @ _); <span class="nb">unfold</span> pr1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projection E
  ((projection (cxfib&#39; E Y).<span class="mi">1</span> $o ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>) f) =
(projection Y $o
 grp_quotient_rec F
   {|
     normalsubgroup_subgroup :=
       abses_pullback_inclusion_transpose_subgroup
         (inclusion E) F p;
     normalsubgroup_isnormal :=
       isnormal_ab_subgroup F
         (abses_pullback_inclusion_transpose_subgroup
            (inclusion E) F p)
   |}
   (grp_pullback_pr1 (projection Y) (projection E) $o
    ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>)
   (<span class="kr">fun</span> (<span class="nv">f</span> : F)
      (<span class="nv">X</span> : {|
             normalsubgroup_subgroup :=
               abses_pullback_inclusion_transpose_subgroup
                 (inclusion E) F p;
             normalsubgroup_isnormal :=
               isnormal_ab_subgroup F
                 (abses_pullback_inclusion_transpose_subgroup
                    (inclusion E) F p)
           |} f) =&gt;
    ap
      (grp_pullback_pr1 (projection Y) (projection E) $o
       ((Q.<span class="mi">1</span>)^$).<span class="mi">1</span>) (X.<span class="mi">2</span>)^ @
    (ap
       (grp_pullback_pr1 (projection Y) (projection E))
       (induced_map_eq E F p (Y; Q)
          (ab_biprod_inr X.<span class="mi">1</span>)) @
     (grp_unit_r (inclusion Y mon_unit) @
      grp_homo_unit (inclusion Y)))))
  (grp_quotient_map f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (pullback_commsq _ _ ((Q.<span class="mi">1</span>^$).<span class="mi">1</span> f))^.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk10b"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">hfiber_cxfib&#39;_induced_path&#39;</span> `{Univalence} {A B C : AbGroup} (E : AbSES C B)
      (F : AbSES (middle E) A) (p : abses_pullback0 (inclusion E) F $== point _)
      (Y : hfiber_cxfib&#39; E F p)
  : path_hfiber_cxfib&#39; (hfiber_cxfib&#39;_inhabited E F p) Y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">path_hfiber_cxfib&#39; (hfiber_cxfib&#39;_inhabited E F p) Y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk10c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">path_hfiber_cxfib&#39; (hfiber_cxfib&#39;_inhabited E F p) Y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk10d"><span class="highlight"><span class="kr">exists</span> (<span class="nv">hfiber_cxfib&#39;_induced_path&#39;0</span> <span class="nv">E</span> <span class="nv">F</span> <span class="nv">p</span> <span class="nv">Y</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (projection E))
   (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y))^$ $@
((hfiber_cxfib&#39;_inhabited E F p).<span class="mi">2</span>).<span class="mi">1</span> $== (Y.<span class="mi">2</span>).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk10e"><span class="highlight">rapply gpd_moveR_Vh.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (projection E))
   (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y))^$ $==
abses_component1_trivial_pullback&#39;
  (abses_pullback_inclusion0_map&#39; E F p)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>%path) $o (Y.<span class="mi">2</span>).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk10f"><span class="highlight">rapply gpd_moveL_hM.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fmap (abses_pullback0 (projection E))
   (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y))^$ $o
((Y.<span class="mi">2</span>).<span class="mi">1</span>)^$ $==
abses_component1_trivial_pullback&#39;
  (abses_pullback_inclusion0_map&#39; E F p)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>%path)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk110"><span class="highlight">rapply gpd_moveR_Vh.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((Y.<span class="mi">2</span>).<span class="mi">1</span>)^$ $==
fmap (abses_pullback0 (projection E))
  (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y) $o
abses_component1_trivial_pullback&#39;
  (abses_pullback_inclusion0_map&#39; E F p)
  (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>%path)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk111"><span class="highlight"><span class="nb">intro</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(F; p).<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(((Y.<span class="mi">2</span>).<span class="mi">1</span>)^$).<span class="mi">1</span> x =
(fmap (abses_pullback0 (projection E))
   (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y) $o
 abses_component1_trivial_pullback&#39;
   (abses_pullback_inclusion0_map&#39; E F p)
   (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>%path)).<span class="mi">1</span> x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk112"><span class="highlight">srapply equiv_path_pullback_hset; <span class="nb">split</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(F; p).<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((((Y.<span class="mi">2</span>).<span class="mi">1</span>)^$).<span class="mi">1</span> x).<span class="mi">1</span> =
((fmap (abses_pullback0 (projection E))
    (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y) $o
  abses_component1_trivial_pullback&#39;
    (abses_pullback_inclusion0_map&#39; E F p)
    (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>%path)).<span class="mi">1</span> x).<span class="mi">1</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk113" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(F; p).<span class="mi">1</span></span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk113"><hr></label><div class="goal-conclusion"><span class="highlight">(((((Y.<span class="mi">2</span>).<span class="mi">1</span>)^$).<span class="mi">1</span> x).<span class="mi">2</span>).<span class="mi">1</span> =
(((fmap (abses_pullback0 (projection E))
     (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y) $o
   abses_component1_trivial_pullback&#39;
     (abses_pullback_inclusion0_map&#39; E F p)
     (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>%path)).<span class="mi">1</span> x).<span class="mi">2</span>).<span class="mi">1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk114"><span class="highlight"><span class="mi">2</span>: <span class="bp">exact</span> (snd Y.<span class="mi">2</span>.<span class="mi">1</span>^$.<span class="mi">2</span> x)^.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_cxfib&#39; E F p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(F; p).<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((((Y.<span class="mi">2</span>).<span class="mi">1</span>)^$).<span class="mi">1</span> x).<span class="mi">1</span> =
((fmap (abses_pullback0 (projection E))
    (hfiber_cxfib&#39;_induced_path&#39;0 E F p Y) $o
  abses_component1_trivial_pullback&#39;
    (abses_pullback_inclusion0_map&#39; E F p)
    (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>%path)).<span class="mi">1</span> x).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** It follows that [hfiber_cxfib&#39;] is contractible. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk115"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">contr_hfiber_cxfib&#39;</span> `{Univalence} {A B C : AbGroup} (E : AbSES C B)
      (F : AbSES (middle E) A) (p : abses_pullback0 (inclusion E) F $== point _)
  : Contr (hfiber_cxfib&#39; E F p).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (hfiber_cxfib&#39; E F p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk116"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (hfiber_cxfib&#39; E F p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk117"><span class="highlight">srapply Build_Contr.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber_cxfib&#39; E F p</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk118" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk118"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : hfiber_cxfib&#39; E F p, <span class="nl">?center</span> = y</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk119"><span class="highlight"><span class="mi">1</span>: <span class="nb">apply</span> hfiber_cxfib&#39;_inhabited.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : hfiber_cxfib&#39; E F p,
hfiber_cxfib&#39;_inhabited E F p = y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk11a"><span class="highlight"><span class="nb">intros</span> [Y q].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber_cxfib&#39;_inhabited E F p = (Y; q)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk11b"><span class="highlight"><span class="nb">apply</span> equiv_path_hfiber_cxfib&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $==
point (AbSES B A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber_abses_path (cxfib&#39; E Y) (F; p)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">path_hfiber_cxfib&#39; (hfiber_cxfib&#39;_inhabited E F p)
  (Y; q)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> hfiber_cxfib&#39;_induced_path&#39;.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** From this we deduce exactness. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk11c"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isexact_abses_pullback</span> `{Univalence} {A B C : AbGroup} {E : AbSES C B}
  : IsExact purely (abses_pullback (A:=A) (projection E)) (abses_pullback (inclusion E)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsExact purely (abses_pullback (projection E))
  (abses_pullback (inclusion E))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk11d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsExact purely (abses_pullback (projection E))
  (abses_pullback (inclusion E))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk11e"><span class="highlight">srapply Build_IsExact.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsComplex (abses_pullback (projection E))
  (abses_pullback (inclusion E))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk11f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk11f"><hr></label><div class="goal-conclusion"><span class="highlight">IsConnMap purely (cxfib <span class="nl">?cx_isexact</span>)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk120"><span class="highlight"><span class="mi">1</span>: <span class="nb">apply</span> iscomplex_pullback_abses.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap purely (cxfib (iscomplex_pullback_abses E))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk121"><span class="highlight">srapply (equiv_ind (equiv_hfiber_abses (abses_pullback0 (inclusion E)) (point (AbSES B A)))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span>
<span class="nv">x</span> : graph_hfiber (abses_pullback0 (inclusion E))
      (point (AbSES B A)),
(<span class="kr">fun</span>
   <span class="nv">y</span> : hfiber (abses_pullback0 (inclusion E))
         (point (AbSES B A)) =&gt;
 IsConnected purely
   (hfiber (cxfib (iscomplex_pullback_abses E)) y))
  (equiv_hfiber_abses (abses_pullback0 (inclusion E))
     (point (AbSES B A)) x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk122"><span class="highlight"><span class="nb">intros</span> [F p].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $-&gt;
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnected purely
  (hfiber (cxfib (iscomplex_pullback_abses E))
     (equiv_hfiber_abses
        (abses_pullback0 (inclusion E))
        (point (AbSES B A)) (F; p)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk123"><span class="highlight">rapply contr_equiv&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $-&gt;
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> &lt;~&gt;
purely
  (hfiber (cxfib (iscomplex_pullback_abses E))
     (equiv_hfiber_abses
        (abses_pullback0 (inclusion E))
        (point (AbSES B A)) (F; p)))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullbackfibersequence-v-chk124" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $-&gt;
point (AbSES B A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="pullbackfibersequence-v-chk124"><hr></label><div class="goal-conclusion"><span class="highlight">Contr <span class="nl">?Goal</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullbackfibersequence-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="pullbackfibersequence-v-chk125"><span class="highlight"><span class="mi">1</span>: <span class="nb">apply</span> equiv_hfiber_cxfib&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES C B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbSES E A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abses_pullback0 (inclusion E) F $-&gt;
point (AbSES B A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (hfiber_cxfib&#39; E F p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> contr_hfiber_cxfib&#39;.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span></span></pre>
</div>
</div></body>
</html>
