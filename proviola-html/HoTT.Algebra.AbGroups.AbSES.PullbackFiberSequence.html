<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "<infomsg>[Loading ML file ltac_plugin.cmxs ... done]</infomsg>	<infomsg>[Loading ML file number_string_notation_plugin.cmxs ... done]	</infomsg>	";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "";
            responses[i]=data;
          

            i = 23;
            data = "";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "";
            responses[i]=data;
          

            i = 28;
            data = "";
            responses[i]=data;
          

            i = 29;
            data = "";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "";
            responses[i]=data;
          

            i = 32;
            data = "";
            responses[i]=data;
          

            i = 33;
            data = "";
            responses[i]=data;
          

            i = 34;
            data = "";
            responses[i]=data;
          

            i = 35;
            data = "";
            responses[i]=data;
          

            i = 36;
            data = "";
            responses[i]=data;
          

            i = 37;
            data = "";
            responses[i]=data;
          

            i = 38;
            data = "";
            responses[i]=data;
          

            i = 39;
            data = "";
            responses[i]=data;
          

            i = 40;
            data = "";
            responses[i]=data;
          

            i = 41;
            data = "";
            responses[i]=data;
          

            i = 42;
            data = "";
            responses[i]=data;
          

            i = 43;
            data = "";
            responses[i]=data;
          

            i = 44;
            data = "";
            responses[i]=data;
          

            i = 45;
            data = "";
            responses[i]=data;
          

            i = 46;
            data = "";
            responses[i]=data;
          

            i = 47;
            data = "";
            responses[i]=data;
          

            i = 48;
            data = "";
            responses[i]=data;
          

            i = 49;
            data = "";
            responses[i]=data;
          

            i = 50;
            data = "";
            responses[i]=data;
          

            i = 51;
            data = "";
            responses[i]=data;
          

            i = 52;
            data = "";
            responses[i]=data;
          

            i = 53;
            data = "";
            responses[i]=data;
          

            i = 54;
            data = "";
            responses[i]=data;
          

            i = 55;
            data = "";
            responses[i]=data;
          

            i = 56;
            data = "";
            responses[i]=data;
          

            i = 57;
            data = "";
            responses[i]=data;
          

            i = 58;
            data = "";
            responses[i]=data;
          

            i = 59;
            data = "";
            responses[i]=data;
          

            i = 60;
            data = "";
            responses[i]=data;
          

            i = 61;
            data = "";
            responses[i]=data;
          

            i = 62;
            data = "";
            responses[i]=data;
          

            i = 63;
            data = "";
            responses[i]=data;
          

            i = 64;
            data = "";
            responses[i]=data;
          

            i = 65;
            data = "";
            responses[i]=data;
          

            i = 66;
            data = "";
            responses[i]=data;
          

            i = 67;
            data = "";
            responses[i]=data;
          

            i = 68;
            data = "";
            responses[i]=data;
          

            i = 69;
            data = "";
            responses[i]=data;
          

            i = 70;
            data = "";
            responses[i]=data;
          

            i = 71;
            data = "";
            responses[i]=data;
          

            i = 72;
            data = "";
            responses[i]=data;
          

            i = 73;
            data = "";
            responses[i]=data;
          

            i = 74;
            data = "";
            responses[i]=data;
          

            i = 75;
            data = "";
            responses[i]=data;
          

            i = 76;
            data = "";
            responses[i]=data;
          

            i = 77;
            data = "";
            responses[i]=data;
          

            i = 78;
            data = "";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "";
            responses[i]=data;
          

            i = 83;
            data = "";
            responses[i]=data;
          

            i = 84;
            data = "";
            responses[i]=data;
          

            i = 85;
            data = "";
            responses[i]=data;
          

            i = 86;
            data = "";
            responses[i]=data;
          

            i = 87;
            data = "1 goal (ID 145)	  	  H : Univalence	  A, B, E : AbGroup	  i : B $-> E	  IsEmbedding0 : IsEmbedding i	  F : AbSES E A	  p : abses_pullback0 i F $== point (AbSES B A)	  ============================	  NormalSubgroup F	";
            responses[i]=data;
          

            i = 88;
            data = "";
            responses[i]=data;
          

            i = 89;
            data = "3 goals (ID 150)	  	  H : Univalence	  A, B, E : AbGroup	  i : B $-> E	  IsEmbedding0 : IsEmbedding i	  F : AbSES E A	  p : abses_pullback0 i F $== point (AbSES B A)	  ============================	  Is01Cat Group		goal 2 (ID 156) is:	 Is01Cat Group	goal 3 (ID 173) is:	 IsEmbedding	   (grp_pullback_pr1 (projection F) i $o grp_iso_inverse p.1 $o ab_biprod_inr)	";
            responses[i]=data;
          

            i = 90;
            data = "1 goal (ID 173)	  	  H : Univalence	  A, B, E : AbGroup	  i : B $-> E	  IsEmbedding0 : IsEmbedding i	  F : AbSES E A	  p : abses_pullback0 i F $== point (AbSES B A)	  ============================	  IsEmbedding	    (grp_pullback_pr1 (projection F) i $o grp_iso_inverse p.1 $o	     ab_biprod_inr)	2 goals (ID 326)	  	  H : Univalence	  A, B, E : AbGroup	  i : B $-> E	  IsEmbedding0 : IsEmbedding i	  F : AbSES E A	  p : abses_pullback0 i F $== point (AbSES B A)	  ============================	  IsEmbedding (grp_pullback_pr1 (projection F) i)		goal 2 (ID 327) is:	 IsEmbedding (fun x : B => grp_iso_inverse p.1 (ab_biprod_inr x))	";
            responses[i]=data;
          

            i = 91;
            data = "";
            responses[i]=data;
          

            i = 92;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 93;
            data = "<infomsg>abses_pullback_inclusion_transpose_endpoint' is defined</infomsg>	";
            responses[i]=data;
          

            i = 94;
            data = "";
            responses[i]=data;
          

            i = 95;
            data = "";
            responses[i]=data;
          

            i = 96;
            data = "";
            responses[i]=data;
          

            i = 97;
            data = "";
            responses[i]=data;
          

            i = 98;
            data = "";
            responses[i]=data;
          

            i = 99;
            data = "";
            responses[i]=data;
          

            i = 100;
            data = "";
            responses[i]=data;
          

            i = 101;
            data = "";
            responses[i]=data;
          

            i = 102;
            data = "";
            responses[i]=data;
          

            i = 103;
            data = "";
            responses[i]=data;
          

            i = 104;
            data = "";
            responses[i]=data;
          

            i = 105;
            data = "";
            responses[i]=data;
          

            i = 106;
            data = "";
            responses[i]=data;
          

            i = 107;
            data = "";
            responses[i]=data;
          

            i = 108;
            data = "";
            responses[i]=data;
          

            i = 109;
            data = "";
            responses[i]=data;
          

            i = 110;
            data = "1 goal (ID 226)	  	  H : Univalence	  A, B, E : AbGroup	  i : B $-> E	  IsEmbedding0 : IsEmbedding i	  F : AbSES E A	  p : abses_pullback0 i F $== point (AbSES B A)	  ============================	  projection F $o	  (grp_pullback_pr1 (projection F) i $o (p^$).1 $o ab_biprod_inr) == i	";
            responses[i]=data;
          

            i = 111;
            data = "";
            responses[i]=data;
          

            i = 112;
            data = "1 goal (ID 442)	  	  H : Univalence	  A, B, E : AbGroup	  i : B $-> E	  IsEmbedding0 : IsEmbedding i	  F : AbSES E A	  p : abses_pullback0 i F $== point (AbSES B A)	  ============================	  forall a : ab_biprod A B,	  (projection F $o	   (grp_pullback_pr1 (projection F) i $o (p^$).1 $o ab_biprod_inr))	    (ab_biprod_pr2 a) = i (ab_biprod_pr2 a)	";
            responses[i]=data;
          

            i = 113;
            data = "1 goal (ID 443)	  	  H : Univalence	  A, B, E : AbGroup	  i : B $-> E	  IsEmbedding0 : IsEmbedding i	  F : AbSES E A	  p : abses_pullback0 i F $== point (AbSES B A)	  ab : ab_biprod A B	  ============================	  (projection F $o	   (grp_pullback_pr1 (projection F) i $o (p^$).1 $o ab_biprod_inr))	    (ab_biprod_pr2 ab) = i (ab_biprod_pr2 ab)	";
            responses[i]=data;
          

            i = 114;
            data = "1 goal (ID 463)	  	  H : Univalence	  A, B, E : AbGroup	  i : B $-> E	  IsEmbedding0 : IsEmbedding i	  F : AbSES E A	  p : abses_pullback0 i F $== point (AbSES B A)	  ab : ab_biprod A B	  ============================	  pullback_pr2 ((p^$).1 (ab_biprod_inr (ab_biprod_pr2 ab))) =	  ab_biprod_pr2 ab	";
            responses[i]=data;
          

            i = 115;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 116;
            data = "";
            responses[i]=data;
          

            i = 117;
            data = "";
            responses[i]=data;
          

            i = 118;
            data = "";
            responses[i]=data;
          

            i = 119;
            data = "";
            responses[i]=data;
          

            i = 120;
            data = "";
            responses[i]=data;
          

            i = 121;
            data = "";
            responses[i]=data;
          

            i = 122;
            data = "";
            responses[i]=data;
          

            i = 123;
            data = "";
            responses[i]=data;
          

            i = 124;
            data = "";
            responses[i]=data;
          

            i = 125;
            data = "";
            responses[i]=data;
          

            i = 126;
            data = "";
            responses[i]=data;
          

            i = 127;
            data = "";
            responses[i]=data;
          

            i = 128;
            data = "";
            responses[i]=data;
          

            i = 129;
            data = "1 goal (ID 248)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  AbSES C A	";
            responses[i]=data;
          

            i = 130;
            data = "";
            responses[i]=data;
          

            i = 131;
            data = "6 goals (ID 294)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  AbGroup		goal 2 (ID 296) is:	 A $-> ?middle	goal 3 (ID 298) is:	 ?middle $-> C	goal 4 (ID 300) is:	 IsEmbedding ?inclusion	goal 5 (ID 302) is:	 IsConnMap (Tr (-1)) ?projection	goal 6 (ID 304) is:	 IsExact (Tr (-1)) ?inclusion ?projection	";
            responses[i]=data;
          

            i = 132;
            data = "1 goal (ID 294)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  AbGroup	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	5 goals		goal 1 (ID 296) is:	 A $-> abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	goal 2 (ID 298) is:	 abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p $-> C	goal 3 (ID 300) is:	 IsEmbedding ?inclusion	goal 4 (ID 302) is:	 IsConnMap (Tr (-1)) ?projection	goal 5 (ID 304) is:	 IsExact (Tr (-1)) ?inclusion ?projection	";
            responses[i]=data;
          

            i = 133;
            data = "1 goal (ID 296)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  A $-> abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	4 goals		goal 1 (ID 298) is:	 abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p $-> C	goal 2 (ID 300) is:	 IsEmbedding (grp_quotient_map $o inclusion F)	goal 3 (ID 302) is:	 IsConnMap (Tr (-1)) ?projection	goal 4 (ID 304) is:	 IsExact (Tr (-1)) (grp_quotient_map $o inclusion F) ?projection	";
            responses[i]=data;
          

            i = 134;
            data = "1 goal (ID 298)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p $-> C	2 goals (ID 359)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  F $-> C		goal 2 (ID 361) is:	 forall n : F,	 {|	   normalsubgroup_subgroup :=	     abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	   normalsubgroup_isnormal :=	     isnormal_ab_subgroup F	       (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	 |} n -> ?f n = mon_unit	";
            responses[i]=data;
          

            i = 135;
            data = "1 goal (ID 359)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  F $-> C	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	4 goals		goal 1 (ID 361) is:	 forall n : F,	 {|	   normalsubgroup_subgroup :=	     abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	   normalsubgroup_isnormal :=	     isnormal_ab_subgroup F	       (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	 |} n -> (projection E $o projection F) n = mon_unit	goal 2 (ID 300) is:	 IsEmbedding (grp_quotient_map $o inclusion F)	goal 3 (ID 302) is:	 IsConnMap (Tr (-1))	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F) ?h)	goal 4 (ID 304) is:	 IsExact (Tr (-1)) (grp_quotient_map $o inclusion F)	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F) ?h)	";
            responses[i]=data;
          

            i = 136;
            data = "1 goal (ID 361)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  forall n : F,	  {|	    normalsubgroup_subgroup :=	      abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	    normalsubgroup_isnormal :=	      isnormal_ab_subgroup F	        (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	  |} n -> (projection E $o projection F) n = mon_unit	1 goal (ID 383)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  f : F	  b : B	  q : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	       ab_biprod_inr) b = f	  ============================	  (projection E $o projection F) f = mon_unit	";
            responses[i]=data;
          

            i = 137;
            data = "1 goal (ID 384)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  f : F	  b : B	  q : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	       ab_biprod_inr) b = f	  ============================	  (projection E $o projection F)	    ((grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	      ab_biprod_inr) b) = mon_unit	";
            responses[i]=data;
          

            i = 138;
            data = "1 goal (ID 404)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  f : F	  b : B	  q : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	       ab_biprod_inr) b = f	  ============================	  projection E (inclusion E b) = mon_unit	";
            responses[i]=data;
          

            i = 139;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 goals		goal 1 (ID 300) is:	 IsEmbedding (grp_quotient_map $o inclusion F)	goal 2 (ID 302) is:	 IsConnMap (Tr (-1))	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F)	      (fun (f : F)	         (X : {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} f) =>	       (fun (b : B)	          (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) b)	          (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E b)) f q) X.1 X.2))	goal 3 (ID 304) is:	 IsExact (Tr (-1)) (grp_quotient_map $o inclusion F)	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F)	      (fun (f : F)	         (X : {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} f) =>	       (fun (b : B)	          (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) b)	          (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E b)) f q) X.1 X.2))	";
            responses[i]=data;
          

            i = 140;
            data = "1 goal (ID 300)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  IsEmbedding (grp_quotient_map $o inclusion F)	1 goal (ID 414)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  forall a : A,	  (grp_quotient_map $o inclusion F) a = group_unit -> a = group_unit	";
            responses[i]=data;
          

            i = 141;
            data = "1 goal (ID 416)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  ============================	  a = group_unit	";
            responses[i]=data;
          

            i = 142;
            data = "2 goals (ID 431)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  ============================	  in_cosetL (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	    (inclusion F a) mon_unit		goal 2 (ID 432) is:	 a = group_unit	";
            responses[i]=data;
          

            i = 143;
            data = "1 goal (ID 431)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  ============================	  in_cosetL (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	    (inclusion F a) mon_unit	5 goals (ID 523)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  ============================	  is_mere_relation F	    (in_cosetL	       (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p))		goal 2 (ID 524) is:	 Transitive	   (in_cosetL (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p))	goal 3 (ID 525) is:	 Symmetric	   (in_cosetL (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p))	goal 4 (ID 526) is:	 Reflexive	   (in_cosetL (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p))	goal 5 (ID 527) is:	 class_of	   (in_cosetL (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p))	   (inclusion F a) =	 class_of	   (in_cosetL (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p))	   mon_unit	";
            responses[i]=data;
          

            i = 144;
            data = "1 goal (ID 527)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  ============================	  class_of	    (in_cosetL	       (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p))	    (inclusion F a) =	  class_of	    (in_cosetL	       (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p))	    mon_unit	";
            responses[i]=data;
          

            i = 145;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 goals		goal 1 (ID 432) is:	 a = group_unit	goal 2 (ID 302) is:	 IsConnMap (Tr (-1))	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F)	      (fun (f : F)	         (X : {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} f) =>	       (fun (b : B)	          (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) b)	          (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E b)) f q) X.1 X.2))	goal 3 (ID 304) is:	 IsExact (Tr (-1)) (grp_quotient_map $o inclusion F)	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F)	      (fun (f : F)	         (X : {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} f) =>	       (fun (b : B)	          (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) b)	          (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E b)) f q) X.1 X.2))	1 goal (ID 432)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  in_coset : in_cosetL	               (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	               (inclusion F a) mon_unit	  ============================	  a = group_unit	1 goal (ID 574)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  b : B	  q1 : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	        ab_biprod_inr) b = - inclusion F a	  ============================	  a = group_unit	";
            responses[i]=data;
          

            i = 146;
            data = "2 goals (ID 588)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  b : B	  q1 : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	        ab_biprod_inr) b = - inclusion F a	  ============================	  ab_biprod_inr b = ab_biprod_inl (- a)		goal 2 (ID 589) is:	 a = group_unit	";
            responses[i]=data;
          

            i = 147;
            data = "1 goal (ID 588)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  b : B	  q1 : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	        ab_biprod_inr) b = - inclusion F a	  ============================	  ab_biprod_inr b = ab_biprod_inl (- a)	2 goals (ID 613)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  b : B	  q1 : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	        ab_biprod_inr) b = - inclusion F a	  ============================	  IsEmbedding (grp_pullback_pr1 (projection F) (inclusion E) $o (p^$).1)		goal 2 (ID 614) is:	 (grp_pullback_pr1 (projection F) (inclusion E) $o (p^$).1) (ab_biprod_inr b) =	 (grp_pullback_pr1 (projection F) (inclusion E) $o (p^$).1)	   (ab_biprod_inl (- a))	";
            responses[i]=data;
          

            i = 148;
            data = "1 goal (ID 613)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  b : B	  q1 : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	        ab_biprod_inr) b = - inclusion F a	  ============================	  IsEmbedding (grp_pullback_pr1 (projection F) (inclusion E) $o (p^$).1)	2 goals (ID 635)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  b : B	  q1 : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	        ab_biprod_inr) b = - inclusion F a	  ============================	  IsEmbedding (grp_pullback_pr1 (projection F) (inclusion E))		goal 2 (ID 636) is:	 IsEmbedding (p^$).1	";
            responses[i]=data;
          

            i = 149;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	4 goals		goal 1 (ID 614) is:	 (grp_pullback_pr1 (projection F) (inclusion E) $o (p^$).1) (ab_biprod_inr b) =	 (grp_pullback_pr1 (projection F) (inclusion E) $o (p^$).1)	   (ab_biprod_inl (- a))	goal 2 (ID 589) is:	 a = group_unit	goal 3 (ID 302) is:	 IsConnMap (Tr (-1))	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F)	      (fun (f : F)	         (X : {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} f) =>	       (fun (b : B)	          (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) b)	          (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E b)) f q) X.1 X.2))	goal 4 (ID 304) is:	 IsExact (Tr (-1)) (grp_quotient_map $o inclusion F)	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F)	      (fun (f : F)	         (X : {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} f) =>	       (fun (b : B)	          (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) b)	          (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E b)) f q) X.1 X.2))	";
            responses[i]=data;
          

            i = 150;
            data = "1 goal (ID 614)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  b : B	  q1 : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	        ab_biprod_inr) b = - inclusion F a	  ============================	  (grp_pullback_pr1 (projection F) (inclusion E) $o (p^$).1)	    (ab_biprod_inr b) =	  (grp_pullback_pr1 (projection F) (inclusion E) $o (p^$).1)	    (ab_biprod_inl (- a))	1 goal (ID 735)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  b : B	  q1 : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	        ab_biprod_inr) b = - inclusion F a	  ============================	  (grp_pullback_pr1 (projection F) (inclusion E) $o (p^$).1)	    (ab_biprod_inl (- a)) = - inclusion F a	";
            responses[i]=data;
          

            i = 151;
            data = "1 goal (ID 765)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  b : B	  q1 : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	        ab_biprod_inr) b = - inclusion F a	  ============================	  grp_pullback_pr1 (projection F) (inclusion E)	    (inclusion (abses_pullback0 (inclusion E) F) (- a)) = 	  - inclusion F a	";
            responses[i]=data;
          

            i = 152;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 goals		goal 1 (ID 589) is:	 a = group_unit	goal 2 (ID 302) is:	 IsConnMap (Tr (-1))	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F)	      (fun (f : F)	         (X : {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} f) =>	       (fun (b : B)	          (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) b)	          (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E b)) f q) X.1 X.2))	goal 3 (ID 304) is:	 IsExact (Tr (-1)) (grp_quotient_map $o inclusion F)	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F)	      (fun (f : F)	         (X : {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} f) =>	       (fun (b : B)	          (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) b)	          (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E b)) f q) X.1 X.2))	";
            responses[i]=data;
          

            i = 153;
            data = "1 goal (ID 589)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  b : B	  q1 : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	        ab_biprod_inr) b = - inclusion F a	  q2 : ab_biprod_inr b = ab_biprod_inl (- a)	  ============================	  a = group_unit	1 goal (ID 796)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  q0 : (grp_quotient_map $o inclusion F) a = group_unit	  b : B	  q1 : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	        ab_biprod_inr) b = - inclusion F a	  q2 : ab_biprod_inr b = ab_biprod_inl (- a)	  q3 : - mon_unit = - - a	  ============================	  a = group_unit	";
            responses[i]=data;
          

            i = 154;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 302) is:	 IsConnMap (Tr (-1))	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F)	      (fun (f : F)	         (X : {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} f) =>	       (fun (b : B)	          (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) b)	          (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E b)) f q) X.1 X.2))	goal 2 (ID 304) is:	 IsExact (Tr (-1)) (grp_quotient_map $o inclusion F)	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F)	      (fun (f : F)	         (X : {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} f) =>	       (fun (b : B)	          (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) b)	          (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E b)) f q) X.1 X.2))	";
            responses[i]=data;
          

            i = 155;
            data = "1 goal (ID 302)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  IsConnMap (Tr (-1))	    (grp_quotient_rec F	       {|	         normalsubgroup_subgroup :=	           abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	         normalsubgroup_isnormal :=	           isnormal_ab_subgroup F	             (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	       |} (projection E $o projection F)	       (fun (f : F)	          (X : {|	                 normalsubgroup_subgroup :=	                   abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p;	                 normalsubgroup_isnormal :=	                   isnormal_ab_subgroup F	                     (abses_pullback_inclusion_transpose_subgroup	                        (inclusion E) F p)	               |} f) =>	        (fun (b : B)	           (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                 grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) b)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	            (let X0 :=	               fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0) in	             X0 E b)) f q) X.1 X.2))	2 goals (ID 828)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  IsConnMap (Tr (-1)) grp_quotient_map		goal 2 (ID 829) is:	 IsConnMap (Tr (-1))	   (fun x : F =>	    grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F)	      (fun (f : F)	         (X : {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} f) =>	       internal_paths_rew F	         ((grp_pullback_pr1 (projection F) (inclusion E) $o	           grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	         (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	         (ap (projection E)	            (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	          (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	             in	           X0 E X.1)) f X.2) (grp_quotient_map x))	";
            responses[i]=data;
          

            i = 156;
            data = "1 goal (ID 829)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  IsConnMap (Tr (-1))	    (fun x : F =>	     grp_quotient_rec F	       {|	         normalsubgroup_subgroup :=	           abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	         normalsubgroup_isnormal :=	           isnormal_ab_subgroup F	             (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	       |} (projection E $o projection F)	       (fun (f : F)	          (X : {|	                 normalsubgroup_subgroup :=	                   abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p;	                 normalsubgroup_isnormal :=	                   isnormal_ab_subgroup F	                     (abses_pullback_inclusion_transpose_subgroup	                        (inclusion E) F p)	               |} f) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	          (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E X.1)) f X.2) (grp_quotient_map x))	";
            responses[i]=data;
          

            i = 157;
            data = "1 goal (ID 831)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  IsConnMap (Tr (-1)) (fun x : F => projection E (projection F x))	";
            responses[i]=data;
          

            i = 158;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 304) is:	 IsExact (Tr (-1)) (grp_quotient_map $o inclusion F)	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F)	      (fun (f : F)	         (X : {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} f) =>	       (fun (b : B)	          (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) b)	          (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E b)) f q) X.1 X.2))	";
            responses[i]=data;
          

            i = 159;
            data = "1 goal (ID 304)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  IsExact (Tr (-1)) (grp_quotient_map $o inclusion F)	    (grp_quotient_rec F	       {|	         normalsubgroup_subgroup :=	           abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	         normalsubgroup_isnormal :=	           isnormal_ab_subgroup F	             (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	       |} (projection E $o projection F)	       (fun (f : F)	          (X : {|	                 normalsubgroup_subgroup :=	                   abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p;	                 normalsubgroup_isnormal :=	                   isnormal_ab_subgroup F	                     (abses_pullback_inclusion_transpose_subgroup	                        (inclusion E) F p)	               |} f) =>	        (fun (b : B)	           (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                 grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) b)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	            (let X0 :=	               fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0) in	             X0 E b)) f q) X.1 X.2))	2 goals (ID 947)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  IsComplex (grp_quotient_map $o inclusion F)	    (grp_quotient_rec F	       {|	         normalsubgroup_subgroup :=	           abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	         normalsubgroup_isnormal :=	           isnormal_ab_subgroup F	             (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	       |} (projection E $o projection F)	       (fun (f : F)	          (X : {|	                 normalsubgroup_subgroup :=	                   abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p;	                 normalsubgroup_isnormal :=	                   isnormal_ab_subgroup F	                     (abses_pullback_inclusion_transpose_subgroup	                        (inclusion E) F p)	               |} f) =>	        (fun (b : B)	           (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                 grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) b)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	            (let X0 :=	               fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0) in	             X0 E b)) f q) X.1 X.2))		goal 2 (ID 949) is:	 IsConnMap (Tr (-1)) (cxfib ?cx_isexact)	";
            responses[i]=data;
          

            i = 160;
            data = "1 goal (ID 947)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  IsComplex (grp_quotient_map $o inclusion F)	    (grp_quotient_rec F	       {|	         normalsubgroup_subgroup :=	           abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	         normalsubgroup_isnormal :=	           isnormal_ab_subgroup F	             (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	       |} (projection E $o projection F)	       (fun (f : F)	          (X : {|	                 normalsubgroup_subgroup :=	                   abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p;	                 normalsubgroup_isnormal :=	                   isnormal_ab_subgroup F	                     (abses_pullback_inclusion_transpose_subgroup	                        (inclusion E) F p)	               |} f) =>	        (fun (b : B)	           (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                 grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) b)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	            (let X0 :=	               fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0) in	             X0 E b)) f q) X.1 X.2))	2 goals (ID 971)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  grp_quotient_rec F	    {|	      normalsubgroup_subgroup :=	        abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	      normalsubgroup_isnormal :=	        isnormal_ab_subgroup F	          (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	    |} (projection E $o projection F)	    (fun (f : F)	       (X : {|	              normalsubgroup_subgroup :=	                abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	              normalsubgroup_isnormal :=	                isnormal_ab_subgroup F	                  (abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p)	            |} f) =>	     (fun (b : B)	        (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	              grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	      internal_paths_rew F	        ((grp_pullback_pr1 (projection F) (inclusion E) $o	          grp_iso_inverse p.1 $o ab_biprod_inr) b)	        (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	        (ap (projection E)	           (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	         (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	            in	          X0 E b)) f q) X.1 X.2) o* (grp_quotient_map $o inclusion F) ==	  pconst		goal 2 (ID 973) is:	 ?p (point A) =	 dpoint_eq	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F)	      (fun (f : F)	         (X : {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} f) =>	       (fun (b : B)	          (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) b)	          (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E b)) f q) X.1 X.2) o* (grp_quotient_map $o inclusion F)) @	 (dpoint_eq pconst)^	";
            responses[i]=data;
          

            i = 161;
            data = "1 goal (ID 971)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  grp_quotient_rec F	    {|	      normalsubgroup_subgroup :=	        abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	      normalsubgroup_isnormal :=	        isnormal_ab_subgroup F	          (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	    |} (projection E $o projection F)	    (fun (f : F)	       (X : {|	              normalsubgroup_subgroup :=	                abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	              normalsubgroup_isnormal :=	                isnormal_ab_subgroup F	                  (abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p)	            |} f) =>	     (fun (b : B)	        (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	              grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	      internal_paths_rew F	        ((grp_pullback_pr1 (projection F) (inclusion E) $o	          grp_iso_inverse p.1 $o ab_biprod_inr) b)	        (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	        (ap (projection E)	           (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	         (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	            in	          X0 E b)) f q) X.1 X.2) o* (grp_quotient_map $o inclusion F) ==	  pconst	1 goal (ID 976)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  ============================	  projection E (projection F (inclusion F a)) = point C	";
            responses[i]=data;
          

            i = 162;
            data = "2 focused goals (shelved: 1) (ID 992)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  ============================	  projection F (inclusion F a) = ?Goal		goal 2 (ID 993) is:	 projection E ?Goal = point C	";
            responses[i]=data;
          

            i = 163;
            data = "1 goal (ID 993)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  a : A	  ============================	  projection E (pconst a) = point C	";
            responses[i]=data;
          

            i = 164;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	";
            responses[i]=data;
          

            i = 165;
            data = "2 goals		goal 1 (ID 973) is:	 ((fun a : A =>	   ap (projection E)	     (let X := fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	      X F a) @ grp_homo_unit (projection E)	   :	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F)	      (fun (f : F)	         (X : {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} f) =>	       internal_paths_rew F	         ((grp_pullback_pr1 (projection F) (inclusion E) $o	           grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	         (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	         (ap (projection E)	            (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	          (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	             in	           X0 E X.1)) f X.2) o* (grp_quotient_map $o inclusion F)) a =	   pconst a)	  :	  grp_quotient_rec F	    {|	      normalsubgroup_subgroup :=	        abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	      normalsubgroup_isnormal :=	        isnormal_ab_subgroup F	          (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	    |} (projection E $o projection F)	    (fun (f : F)	       (X : {|	              normalsubgroup_subgroup :=	                abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	              normalsubgroup_isnormal :=	                isnormal_ab_subgroup F	                  (abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p)	            |} f) =>	     (fun (b : B)	        (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	              grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	      internal_paths_rew F	        ((grp_pullback_pr1 (projection F) (inclusion E) $o	          grp_iso_inverse p.1 $o ab_biprod_inr) b)	        (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	        (ap (projection E)	           (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	         (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	            in	          X0 E b)) f q) X.1 X.2) o* (grp_quotient_map $o inclusion F) ==	  pconst) (point A) =	 dpoint_eq	   (grp_quotient_rec F	      {|	        normalsubgroup_subgroup :=	          abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	        normalsubgroup_isnormal :=	          isnormal_ab_subgroup F	            (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	      |} (projection E $o projection F)	      (fun (f : F)	         (X : {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} f) =>	       (fun (b : B)	          (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) b)	          (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E b)) f q) X.1 X.2) o* (grp_quotient_map $o inclusion F)) @	 (dpoint_eq pconst)^	goal 2 (ID 949) is:	 IsConnMap (Tr (-1))	   (cxfib	      (Build_pHomotopy	         ((fun a : A =>	           ap (projection E)	             (let X :=	                fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	              X F a) @ grp_homo_unit (projection E)	           :	           (grp_quotient_rec F	              {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} (projection E $o projection F)	              (fun (f : F)	                 (X : {|	                        normalsubgroup_subgroup :=	                          abses_pullback_inclusion_transpose_subgroup	                            (inclusion E) F p;	                        normalsubgroup_isnormal :=	                          isnormal_ab_subgroup F	                            (abses_pullback_inclusion_transpose_subgroup	                               (inclusion E) F p)	                      |} f) =>	               internal_paths_rew F	                 ((grp_pullback_pr1 (projection F) (inclusion E) $o	                   grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                 (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	                 (ap (projection E)	                    (abses_pullback_inclusion_transpose_beta 	                       (inclusion E) F p X.1) @	                  (let X0 :=	                     fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	                     in	                   X0 E X.1)) f X.2) o* (grp_quotient_map $o inclusion F)) a =	           pconst a)	          :	          grp_quotient_rec F	            {|	              normalsubgroup_subgroup :=	                abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	              normalsubgroup_isnormal :=	                isnormal_ab_subgroup F	                  (abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p)	            |} (projection E $o projection F)	            (fun (f : F)	               (X : {|	                      normalsubgroup_subgroup :=	                        abses_pullback_inclusion_transpose_subgroup	                          (inclusion E) F p;	                      normalsubgroup_isnormal :=	                        isnormal_ab_subgroup F	                          (abses_pullback_inclusion_transpose_subgroup	                             (inclusion E) F p)	                    |} f) =>	             (fun (b : B)	                (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                      grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	              internal_paths_rew F	                ((grp_pullback_pr1 (projection F) (inclusion E) $o	                  grp_iso_inverse p.1 $o ab_biprod_inr) b)	                (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	                (ap (projection E)	                   (abses_pullback_inclusion_transpose_beta 	                      (inclusion E) F p b) @	                 (let X0 :=	                    fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	                    in	                  X0 E b)) f q) X.1 X.2) o* (grp_quotient_map $o inclusion F) ==	          pconst) ?q))	1 goal (ID 973)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  ((fun a : A =>	    ap (projection E)	      (let X := fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	       X F a) @ grp_homo_unit (projection E)	    :	    (grp_quotient_rec F	       {|	         normalsubgroup_subgroup :=	           abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	         normalsubgroup_isnormal :=	           isnormal_ab_subgroup F	             (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	       |} (projection E $o projection F)	       (fun (f : F)	          (X : {|	                 normalsubgroup_subgroup :=	                   abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p;	                 normalsubgroup_isnormal :=	                   isnormal_ab_subgroup F	                     (abses_pullback_inclusion_transpose_subgroup	                        (inclusion E) F p)	               |} f) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	          (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E X.1)) f X.2) o* (grp_quotient_map $o inclusion F)) a =	    pconst a)	   :	   grp_quotient_rec F	     {|	       normalsubgroup_subgroup :=	         abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	       normalsubgroup_isnormal :=	         isnormal_ab_subgroup F	           (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	     |} (projection E $o projection F)	     (fun (f : F)	        (X : {|	               normalsubgroup_subgroup :=	                 abses_pullback_inclusion_transpose_subgroup 	                   (inclusion E) F p;	               normalsubgroup_isnormal :=	                 isnormal_ab_subgroup F	                   (abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p)	             |} f) =>	      (fun (b : B)	         (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	               grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	       internal_paths_rew F	         ((grp_pullback_pr1 (projection F) (inclusion E) $o	           grp_iso_inverse p.1 $o ab_biprod_inr) b)	         (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	         (ap (projection E)	            (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	          (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	             in	           X0 E b)) f q) X.1 X.2) o* (grp_quotient_map $o inclusion F) ==	   pconst) (point A) =	  dpoint_eq	    (grp_quotient_rec F	       {|	         normalsubgroup_subgroup :=	           abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	         normalsubgroup_isnormal :=	           isnormal_ab_subgroup F	             (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	       |} (projection E $o projection F)	       (fun (f : F)	          (X : {|	                 normalsubgroup_subgroup :=	                   abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p;	                 normalsubgroup_isnormal :=	                   isnormal_ab_subgroup F	                     (abses_pullback_inclusion_transpose_subgroup	                        (inclusion E) F p)	               |} f) =>	        (fun (b : B)	           (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                 grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) b)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p b) @	            (let X0 :=	               fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0) in	             X0 E b)) f q) X.1 X.2) o* (grp_quotient_map $o inclusion F)) @	  (dpoint_eq pconst)^	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	";
            responses[i]=data;
          

            i = 166;
            data = "1 goal		goal 1 (ID 949) is:	 IsConnMap (Tr (-1))	   (cxfib	      (Build_pHomotopy	         ((fun a : A =>	           ap (projection E)	             (let X :=	                fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	              X F a) @ grp_homo_unit (projection E)	           :	           (grp_quotient_rec F	              {|	                normalsubgroup_subgroup :=	                  abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p;	                normalsubgroup_isnormal :=	                  isnormal_ab_subgroup F	                    (abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p)	              |} (projection E $o projection F)	              (fun (f : F)	                 (X : {|	                        normalsubgroup_subgroup :=	                          abses_pullback_inclusion_transpose_subgroup	                            (inclusion E) F p;	                        normalsubgroup_isnormal :=	                          isnormal_ab_subgroup F	                            (abses_pullback_inclusion_transpose_subgroup	                               (inclusion E) F p)	                      |} f) =>	               internal_paths_rew F	                 ((grp_pullback_pr1 (projection F) (inclusion E) $o	                   grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                 (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	                 (ap (projection E)	                    (abses_pullback_inclusion_transpose_beta 	                       (inclusion E) F p X.1) @	                  (let X0 :=	                     fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	                     in	                   X0 E X.1)) f X.2) o* (grp_quotient_map $o inclusion F)) a =	           pconst a)	          :	          grp_quotient_rec F	            {|	              normalsubgroup_subgroup :=	                abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	              normalsubgroup_isnormal :=	                isnormal_ab_subgroup F	                  (abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p)	            |} (projection E $o projection F)	            (fun (f : F)	               (X : {|	                      normalsubgroup_subgroup :=	                        abses_pullback_inclusion_transpose_subgroup	                          (inclusion E) F p;	                      normalsubgroup_isnormal :=	                        isnormal_ab_subgroup F	                          (abses_pullback_inclusion_transpose_subgroup	                             (inclusion E) F p)	                    |} f) =>	             (fun (b : B)	                (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                      grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	              internal_paths_rew F	                ((grp_pullback_pr1 (projection F) (inclusion E) $o	                  grp_iso_inverse p.1 $o ab_biprod_inr) b)	                (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	                (ap (projection E)	                   (abses_pullback_inclusion_transpose_beta 	                      (inclusion E) F p b) @	                 (let X0 :=	                    fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	                    in	                  X0 E b)) f q) X.1 X.2) o* (grp_quotient_map $o inclusion F) ==	          pconst)	         (path_ishprop	            (ap (projection E)	               (let X :=	                  fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	                X F (point A)) @ grp_homo_unit (projection E))	            (dpoint_eq	               (grp_quotient_rec F	                  {|	                    normalsubgroup_subgroup :=	                      abses_pullback_inclusion_transpose_subgroup	                        (inclusion E) F p;	                    normalsubgroup_isnormal :=	                      isnormal_ab_subgroup F	                        (abses_pullback_inclusion_transpose_subgroup	                           (inclusion E) F p)	                  |} (projection E $o projection F)	                  (fun (f : F)	                     (X : {|	                            normalsubgroup_subgroup :=	                              abses_pullback_inclusion_transpose_subgroup	                                (inclusion E) F p;	                            normalsubgroup_isnormal :=	                              isnormal_ab_subgroup F	                                (abses_pullback_inclusion_transpose_subgroup	                                   (inclusion E) F p)	                          |} f) =>	                   internal_paths_rew F	                     ((grp_pullback_pr1 (projection F) (inclusion E) $o	                       grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                     (fun f0 : F =>	                      (projection E $o projection F) f0 = mon_unit)	                     (ap (projection E)	                        (abses_pullback_inclusion_transpose_beta	                           (inclusion E) F p X.1) @	                      (let X0 :=	                         fun E0 : AbSES' C B =>	                         pointed_fun (iscomplex_abses E0) in	                       X0 E X.1)) f X.2) o* (grp_quotient_map $o inclusion F)) @	             (dpoint_eq pconst)^))))	1 goal (ID 949)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  IsConnMap (Tr (-1))	    (cxfib	       (Build_pHomotopy	          ((fun a : A =>	            ap (projection E)	              (let X :=	                 fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	               X F a) @ grp_homo_unit (projection E)	            :	            (grp_quotient_rec F	               {|	                 normalsubgroup_subgroup :=	                   abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p;	                 normalsubgroup_isnormal :=	                   isnormal_ab_subgroup F	                     (abses_pullback_inclusion_transpose_subgroup	                        (inclusion E) F p)	               |} (projection E $o projection F)	               (fun (f : F)	                  (X : {|	                         normalsubgroup_subgroup :=	                           abses_pullback_inclusion_transpose_subgroup	                             (inclusion E) F p;	                         normalsubgroup_isnormal :=	                           isnormal_ab_subgroup F	                             (abses_pullback_inclusion_transpose_subgroup	                                (inclusion E) F p)	                       |} f) =>	                internal_paths_rew F	                  ((grp_pullback_pr1 (projection F) (inclusion E) $o	                    grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                  (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	                  (ap (projection E)	                     (abses_pullback_inclusion_transpose_beta 	                        (inclusion E) F p X.1) @	                   (let X0 :=	                      fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	                      in	                    X0 E X.1)) f X.2) o* (grp_quotient_map $o inclusion F)) a =	            pconst a)	           :	           grp_quotient_rec F	             {|	               normalsubgroup_subgroup :=	                 abses_pullback_inclusion_transpose_subgroup 	                   (inclusion E) F p;	               normalsubgroup_isnormal :=	                 isnormal_ab_subgroup F	                   (abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p)	             |} (projection E $o projection F)	             (fun (f : F)	                (X : {|	                       normalsubgroup_subgroup :=	                         abses_pullback_inclusion_transpose_subgroup	                           (inclusion E) F p;	                       normalsubgroup_isnormal :=	                         isnormal_ab_subgroup F	                           (abses_pullback_inclusion_transpose_subgroup	                              (inclusion E) F p)	                     |} f) =>	              (fun (b : B)	                 (q : (grp_pullback_pr1 (projection F) (inclusion E) $o	                       grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	               internal_paths_rew F	                 ((grp_pullback_pr1 (projection F) (inclusion E) $o	                   grp_iso_inverse p.1 $o ab_biprod_inr) b)	                 (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	                 (ap (projection E)	                    (abses_pullback_inclusion_transpose_beta 	                       (inclusion E) F p b) @	                  (let X0 :=	                     fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	                     in	                   X0 E b)) f q) X.1 X.2)	           o* (grp_quotient_map $o inclusion F) == pconst)	          (path_ishprop	             (ap (projection E)	                (let X :=	                   fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	                 X F (point A)) @ grp_homo_unit (projection E))	             (dpoint_eq	                (grp_quotient_rec F	                   {|	                     normalsubgroup_subgroup :=	                       abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p;	                     normalsubgroup_isnormal :=	                       isnormal_ab_subgroup F	                         (abses_pullback_inclusion_transpose_subgroup	                            (inclusion E) F p)	                   |} (projection E $o projection F)	                   (fun (f : F)	                      (X : {|	                             normalsubgroup_subgroup :=	                               abses_pullback_inclusion_transpose_subgroup	                                 (inclusion E) F p;	                             normalsubgroup_isnormal :=	                               isnormal_ab_subgroup F	                                 (abses_pullback_inclusion_transpose_subgroup	                                    (inclusion E) F p)	                           |} f) =>	                    internal_paths_rew F	                      ((grp_pullback_pr1 (projection F) (inclusion E) $o	                        grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                      (fun f0 : F =>	                       (projection E $o projection F) f0 = mon_unit)	                      (ap (projection E)	                         (abses_pullback_inclusion_transpose_beta	                            (inclusion E) F p X.1) @	                       (let X0 :=	                          fun E0 : AbSES' C B =>	                          pointed_fun (iscomplex_abses E0) in	                        X0 E X.1)) f X.2)	                 o* (grp_quotient_map $o inclusion F)) @ 	              (dpoint_eq pconst)^))))	";
            responses[i]=data;
          

            i = 167;
            data = "1 goal (ID 1163)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  ============================	  IsConnected (Tr (-1))	    (hfiber	       (cxfib	          (Build_pHomotopy	             (fun a : A =>	              ap (projection E)	                (let X :=	                   fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	                 X F a) @ grp_homo_unit (projection E))	             (path_ishprop	                (ap (projection E)	                   (let X :=	                      fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	                      in	                    X F (point A)) @ grp_homo_unit (projection E))	                (dpoint_eq	                   (grp_quotient_rec F	                      {|	                        normalsubgroup_subgroup :=	                          abses_pullback_inclusion_transpose_subgroup	                            (inclusion E) F p;	                        normalsubgroup_isnormal :=	                          isnormal_ab_subgroup F	                            (abses_pullback_inclusion_transpose_subgroup	                               (inclusion E) F p)	                      |} (projection E $o projection F)	                      (fun (f : F)	                         (X : {|	                                normalsubgroup_subgroup :=	                                  abses_pullback_inclusion_transpose_subgroup	                                    (inclusion E) F p;	                                normalsubgroup_isnormal :=	                                  isnormal_ab_subgroup F	                                    (abses_pullback_inclusion_transpose_subgroup	                                       (inclusion E) F p)	                              |} f) =>	                       internal_paths_rew F	                         ((grp_pullback_pr1 (projection F) (inclusion E) $o	                           grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                         (fun f0 : F =>	                          (projection E $o projection F) f0 = mon_unit)	                         (ap (projection E)	                            (abses_pullback_inclusion_transpose_beta	                               (inclusion E) F p X.1) @	                          (let X0 :=	                             fun E0 : AbSES' C B =>	                             pointed_fun (iscomplex_abses E0) in	                           X0 E X.1)) f X.2)	                    o* (grp_quotient_map $o inclusion F)) @	                 (dpoint_eq pconst)^)))) (y; q))	1 goal (ID 1168)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  ============================	  Tr (-1)	    (hfiber	       (cxfib	          (Build_pHomotopy	             (fun a : A =>	              ap (projection E)	                (let X :=	                   fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	                 X F a) @ grp_homo_unit (projection E))	             (path_ishprop	                (ap (projection E)	                   (let X :=	                      fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	                      in	                    X F (point A)) @ grp_homo_unit (projection E))	                (dpoint_eq	                   (grp_quotient_rec F	                      {|	                        normalsubgroup_subgroup :=	                          abses_pullback_inclusion_transpose_subgroup	                            (inclusion E) F p;	                        normalsubgroup_isnormal :=	                          isnormal_ab_subgroup F	                            (abses_pullback_inclusion_transpose_subgroup	                               (inclusion E) F p)	                      |} (projection E $o projection F)	                      (fun (f : F)	                         (X : {|	                                normalsubgroup_subgroup :=	                                  abses_pullback_inclusion_transpose_subgroup	                                    (inclusion E) F p;	                                normalsubgroup_isnormal :=	                                  isnormal_ab_subgroup F	                                    (abses_pullback_inclusion_transpose_subgroup	                                       (inclusion E) F p)	                              |} f) =>	                       internal_paths_rew F	                         ((grp_pullback_pr1 (projection F) (inclusion E) $o	                           grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                         (fun f0 : F =>	                          (projection E $o projection F) f0 = mon_unit)	                         (ap (projection E)	                            (abses_pullback_inclusion_transpose_beta	                               (inclusion E) F p X.1) @	                          (let X0 :=	                             fun E0 : AbSES' C B =>	                             pointed_fun (iscomplex_abses E0) in	                           X0 E X.1)) f X.2)	                    o* (grp_quotient_map $o inclusion F)) @	                 (dpoint_eq pconst)^)))) (y; q))	";
            responses[i]=data;
          

            i = 168;
            data = "2 goals (ID 1173)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  ============================	  merely (hfiber grp_quotient_map y)		goal 2 (ID 1174) is:	 Tr (-1)	   (hfiber	      (cxfib	         (Build_pHomotopy	            (fun a : A =>	             ap (projection E)	               (let X :=	                  fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	                X F a) @ grp_homo_unit (projection E))	            (path_ishprop	               (ap (projection E)	                  (let X :=	                     fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	                     in	                   X F (point A)) @ grp_homo_unit (projection E))	               (dpoint_eq	                  (grp_quotient_rec F	                     {|	                       normalsubgroup_subgroup :=	                         abses_pullback_inclusion_transpose_subgroup	                           (inclusion E) F p;	                       normalsubgroup_isnormal :=	                         isnormal_ab_subgroup F	                           (abses_pullback_inclusion_transpose_subgroup	                              (inclusion E) F p)	                     |} (projection E $o projection F)	                     (fun (f0 : F)	                        (X : {|	                               normalsubgroup_subgroup :=	                                 abses_pullback_inclusion_transpose_subgroup	                                   (inclusion E) F p;	                               normalsubgroup_isnormal :=	                                 isnormal_ab_subgroup F	                                   (abses_pullback_inclusion_transpose_subgroup	                                      (inclusion E) F p)	                             |} f0) =>	                      internal_paths_rew F	                        ((grp_pullback_pr1 (projection F) (inclusion E) $o	                          grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                        (fun f1 : F =>	                         (projection E $o projection F) f1 = mon_unit)	                        (ap (projection E)	                           (abses_pullback_inclusion_transpose_beta	                              (inclusion E) F p X.1) @	                         (let X0 :=	                            fun E0 : AbSES' C B =>	                            pointed_fun (iscomplex_abses E0) in	                          X0 E X.1)) f0 X.2)	                   o* (grp_quotient_map $o inclusion F)) @	                (dpoint_eq pconst)^)))) (y; q))	";
            responses[i]=data;
          

            i = 169;
            data = "1 goal (ID 1174)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : merely (hfiber grp_quotient_map y)	  ============================	  Tr (-1)	    (hfiber	       (cxfib	          (Build_pHomotopy	             (fun a : A =>	              ap (projection E)	                (let X :=	                   fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	                 X F a) @ grp_homo_unit (projection E))	             (path_ishprop	                (ap (projection E)	                   (let X :=	                      fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	                      in	                    X F (point A)) @ grp_homo_unit (projection E))	                (dpoint_eq	                   (grp_quotient_rec F	                      {|	                        normalsubgroup_subgroup :=	                          abses_pullback_inclusion_transpose_subgroup	                            (inclusion E) F p;	                        normalsubgroup_isnormal :=	                          isnormal_ab_subgroup F	                            (abses_pullback_inclusion_transpose_subgroup	                               (inclusion E) F p)	                      |} (projection E $o projection F)	                      (fun (f0 : F)	                         (X : {|	                                normalsubgroup_subgroup :=	                                  abses_pullback_inclusion_transpose_subgroup	                                    (inclusion E) F p;	                                normalsubgroup_isnormal :=	                                  isnormal_ab_subgroup F	                                    (abses_pullback_inclusion_transpose_subgroup	                                       (inclusion E) F p)	                              |} f0) =>	                       internal_paths_rew F	                         ((grp_pullback_pr1 (projection F) (inclusion E) $o	                           grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                         (fun f1 : F =>	                          (projection E $o projection F) f1 = mon_unit)	                         (ap (projection E)	                            (abses_pullback_inclusion_transpose_beta	                               (inclusion E) F p X.1) @	                          (let X0 :=	                             fun E0 : AbSES' C B =>	                             pointed_fun (iscomplex_abses E0) in	                           X0 E X.1)) f0 X.2)	                    o* (grp_quotient_map $o inclusion F)) @	                 (dpoint_eq pconst)^)))) (y; q))	";
            responses[i]=data;
          

            i = 170;
            data = "";
            responses[i]=data;
          

            i = 171;
            data = "1 goal (ID 1188)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  ============================	  Tr (-1)	    (hfiber	       (cxfib	          (Build_pHomotopy	             (fun a : A =>	              ap (projection E)	                (let X :=	                   fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	                 X F a) @ grp_homo_unit (projection E))	             (path_ishprop	                (ap (projection E)	                   (let X :=	                      fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	                      in	                    X F (point A)) @ grp_homo_unit (projection E))	                (dpoint_eq	                   (grp_quotient_rec F	                      {|	                        normalsubgroup_subgroup :=	                          abses_pullback_inclusion_transpose_subgroup	                            (inclusion E) F p;	                        normalsubgroup_isnormal :=	                          isnormal_ab_subgroup F	                            (abses_pullback_inclusion_transpose_subgroup	                               (inclusion E) F p)	                      |} (projection E $o projection F)	                      (fun (f0 : F)	                         (X : {|	                                normalsubgroup_subgroup :=	                                  abses_pullback_inclusion_transpose_subgroup	                                    (inclusion E) F p;	                                normalsubgroup_isnormal :=	                                  isnormal_ab_subgroup F	                                    (abses_pullback_inclusion_transpose_subgroup	                                       (inclusion E) F p)	                              |} f0) =>	                       internal_paths_rew F	                         ((grp_pullback_pr1 (projection F) (inclusion E) $o	                           grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                         (fun f1 : F =>	                          (projection E $o projection F) f1 = mon_unit)	                         (ap (projection E)	                            (abses_pullback_inclusion_transpose_beta	                               (inclusion E) F p X.1) @	                          (let X0 :=	                             fun E0 : AbSES' C B =>	                             pointed_fun (iscomplex_abses E0) in	                           X0 E X.1)) f0 X.2)	                    o* (grp_quotient_map $o inclusion F)) @	                 (dpoint_eq pconst)^)))) (y; q))	2 goals (ID 1197)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  ============================	  merely (hfiber (inclusion E) (projection F f))		goal 2 (ID 1198) is:	 Tr (-1)	   (hfiber	      (cxfib	         (Build_pHomotopy	            (fun a : A =>	             ap (projection E)	               (let X :=	                  fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	                X F a) @ grp_homo_unit (projection E))	            (path_ishprop	               (ap (projection E)	                  (let X :=	                     fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	                     in	                   X F (point A)) @ grp_homo_unit (projection E))	               (dpoint_eq	                  (grp_quotient_rec F	                     {|	                       normalsubgroup_subgroup :=	                         abses_pullback_inclusion_transpose_subgroup	                           (inclusion E) F p;	                       normalsubgroup_isnormal :=	                         isnormal_ab_subgroup F	                           (abses_pullback_inclusion_transpose_subgroup	                              (inclusion E) F p)	                     |} (projection E $o projection F)	                     (fun (f0 : F)	                        (X : {|	                               normalsubgroup_subgroup :=	                                 abses_pullback_inclusion_transpose_subgroup	                                   (inclusion E) F p;	                               normalsubgroup_isnormal :=	                                 isnormal_ab_subgroup F	                                   (abses_pullback_inclusion_transpose_subgroup	                                      (inclusion E) F p)	                             |} f0) =>	                      internal_paths_rew F	                        ((grp_pullback_pr1 (projection F) (inclusion E) $o	                          grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                        (fun f1 : F =>	                         (projection E $o projection F) f1 = mon_unit)	                        (ap (projection E)	                           (abses_pullback_inclusion_transpose_beta	                              (inclusion E) F p X.1) @	                         (let X0 :=	                            fun E0 : AbSES' C B =>	                            pointed_fun (iscomplex_abses E0) in	                          X0 E X.1)) f0 X.2)	                   o* (grp_quotient_map $o inclusion F)) @	                (dpoint_eq pconst)^)))) (y; q))	";
            responses[i]=data;
          

            i = 172;
            data = "1 goal (ID 1197)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  ============================	  merely (hfiber (inclusion E) (projection F f))	1 goal (ID 1322)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  ============================	  projection E (projection F f) = point C	";
            responses[i]=data;
          

            i = 173;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 1198) is:	 Tr (-1)	   (hfiber	      (cxfib	         (Build_pHomotopy	            (fun a : A =>	             ap (projection E)	               (let X :=	                  fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	                X F a) @ grp_homo_unit (projection E))	            (path_ishprop	               (ap (projection E)	                  (let X :=	                     fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	                     in	                   X F (point A)) @ grp_homo_unit (projection E))	               (dpoint_eq	                  (grp_quotient_rec F	                     {|	                       normalsubgroup_subgroup :=	                         abses_pullback_inclusion_transpose_subgroup	                           (inclusion E) F p;	                       normalsubgroup_isnormal :=	                         isnormal_ab_subgroup F	                           (abses_pullback_inclusion_transpose_subgroup	                              (inclusion E) F p)	                     |} (projection E $o projection F)	                     (fun (f0 : F)	                        (X : {|	                               normalsubgroup_subgroup :=	                                 abses_pullback_inclusion_transpose_subgroup	                                   (inclusion E) F p;	                               normalsubgroup_isnormal :=	                                 isnormal_ab_subgroup F	                                   (abses_pullback_inclusion_transpose_subgroup	                                      (inclusion E) F p)	                             |} f0) =>	                      internal_paths_rew F	                        ((grp_pullback_pr1 (projection F) (inclusion E) $o	                          grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                        (fun f1 : F =>	                         (projection E $o projection F) f1 = mon_unit)	                        (ap (projection E)	                           (abses_pullback_inclusion_transpose_beta	                              (inclusion E) F p X.1) @	                         (let X0 :=	                            fun E0 : AbSES' C B =>	                            pointed_fun (iscomplex_abses E0) in	                          X0 E X.1)) f0 X.2)	                   o* (grp_quotient_map $o inclusion F)) @	                (dpoint_eq pconst)^)))) (y; q))	";
            responses[i]=data;
          

            i = 174;
            data = "1 goal (ID 1198)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : merely (hfiber (inclusion E) (projection F f))	  ============================	  Tr (-1)	    (hfiber	       (cxfib	          (Build_pHomotopy	             (fun a : A =>	              ap (projection E)	                (let X :=	                   fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	                 X F a) @ grp_homo_unit (projection E))	             (path_ishprop	                (ap (projection E)	                   (let X :=	                      fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	                      in	                    X F (point A)) @ grp_homo_unit (projection E))	                (dpoint_eq	                   (grp_quotient_rec F	                      {|	                        normalsubgroup_subgroup :=	                          abses_pullback_inclusion_transpose_subgroup	                            (inclusion E) F p;	                        normalsubgroup_isnormal :=	                          isnormal_ab_subgroup F	                            (abses_pullback_inclusion_transpose_subgroup	                               (inclusion E) F p)	                      |} (projection E $o projection F)	                      (fun (f0 : F)	                         (X : {|	                                normalsubgroup_subgroup :=	                                  abses_pullback_inclusion_transpose_subgroup	                                    (inclusion E) F p;	                                normalsubgroup_isnormal :=	                                  isnormal_ab_subgroup F	                                    (abses_pullback_inclusion_transpose_subgroup	                                       (inclusion E) F p)	                              |} f0) =>	                       internal_paths_rew F	                         ((grp_pullback_pr1 (projection F) (inclusion E) $o	                           grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                         (fun f1 : F =>	                          (projection E $o projection F) f1 = mon_unit)	                         (ap (projection E)	                            (abses_pullback_inclusion_transpose_beta	                               (inclusion E) F p X.1) @	                          (let X0 :=	                             fun E0 : AbSES' C B =>	                             pointed_fun (iscomplex_abses E0) in	                           X0 E X.1)) f0 X.2)	                    o* (grp_quotient_map $o inclusion F)) @	                 (dpoint_eq pconst)^)))) (y; q))	";
            responses[i]=data;
          

            i = 175;
            data = "1 goal (ID 1344)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  ============================	  Tr (-1)	    (hfiber	       (cxfib	          (Build_pHomotopy	             (fun a : A =>	              ap (projection E)	                (let X :=	                   fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	                 X F a) @ grp_homo_unit (projection E))	             (path_ishprop	                (ap (projection E)	                   (let X :=	                      fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	                      in	                    X F (point A)) @ grp_homo_unit (projection E))	                (dpoint_eq	                   (grp_quotient_rec F	                      {|	                        normalsubgroup_subgroup :=	                          abses_pullback_inclusion_transpose_subgroup	                            (inclusion E) F p;	                        normalsubgroup_isnormal :=	                          isnormal_ab_subgroup F	                            (abses_pullback_inclusion_transpose_subgroup	                               (inclusion E) F p)	                      |} (projection E $o projection F)	                      (fun (f0 : F)	                         (X : {|	                                normalsubgroup_subgroup :=	                                  abses_pullback_inclusion_transpose_subgroup	                                    (inclusion E) F p;	                                normalsubgroup_isnormal :=	                                  isnormal_ab_subgroup F	                                    (abses_pullback_inclusion_transpose_subgroup	                                       (inclusion E) F p)	                              |} f0) =>	                       internal_paths_rew F	                         ((grp_pullback_pr1 (projection F) (inclusion E) $o	                           grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                         (fun f1 : F =>	                          (projection E $o projection F) f1 = mon_unit)	                         (ap (projection E)	                            (abses_pullback_inclusion_transpose_beta	                               (inclusion E) F p X.1) @	                          (let X0 :=	                             fun E0 : AbSES' C B =>	                             pointed_fun (iscomplex_abses E0) in	                           X0 E X.1)) f0 X.2)	                    o* (grp_quotient_map $o inclusion F)) @	                 (dpoint_eq pconst)^)))) (y; q))	2 goals (ID 1376)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  ============================	  merely	    (hfiber (inclusion F)	       (sg_op f	          (-	           grp_pullback_pr1 (projection F) (inclusion E)	             ((p^$).1 (ab_biprod_inr b)))))		goal 2 (ID 1377) is:	 Tr (-1)	   (hfiber	      (cxfib	         (Build_pHomotopy	            (fun a0 : A =>	             ap (projection E)	               (let X :=	                  fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	                X F a0) @ grp_homo_unit (projection E))	            (path_ishprop	               (ap (projection E)	                  (let X :=	                     fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	                     in	                   X F (point A)) @ grp_homo_unit (projection E))	               (dpoint_eq	                  (grp_quotient_rec F	                     {|	                       normalsubgroup_subgroup :=	                         abses_pullback_inclusion_transpose_subgroup	                           (inclusion E) F p;	                       normalsubgroup_isnormal :=	                         isnormal_ab_subgroup F	                           (abses_pullback_inclusion_transpose_subgroup	                              (inclusion E) F p)	                     |} (projection E $o projection F)	                     (fun (f0 : F)	                        (X : {|	                               normalsubgroup_subgroup :=	                                 abses_pullback_inclusion_transpose_subgroup	                                   (inclusion E) F p;	                               normalsubgroup_isnormal :=	                                 isnormal_ab_subgroup F	                                   (abses_pullback_inclusion_transpose_subgroup	                                      (inclusion E) F p)	                             |} f0) =>	                      internal_paths_rew F	                        ((grp_pullback_pr1 (projection F) (inclusion E) $o	                          grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                        (fun f1 : F =>	                         (projection E $o projection F) f1 = mon_unit)	                        (ap (projection E)	                           (abses_pullback_inclusion_transpose_beta	                              (inclusion E) F p X.1) @	                         (let X0 :=	                            fun E0 : AbSES' C B =>	                            pointed_fun (iscomplex_abses E0) in	                          X0 E X.1)) f0 X.2)	                   o* (grp_quotient_map $o inclusion F)) @	                (dpoint_eq pconst)^)))) (y; q))	";
            responses[i]=data;
          

            i = 176;
            data = "1 goal (ID 1376)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  ============================	  merely	    (hfiber (inclusion F)	       (sg_op f	          (-	           grp_pullback_pr1 (projection F) (inclusion E)	             ((p^$).1 (ab_biprod_inr b)))))	1 goal (ID 1501)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  ============================	  projection F	    (sg_op f	       (-	        grp_pullback_pr1 (projection F) (inclusion E)	          ((p^$).1 (ab_biprod_inr b)))) = point E	";
            responses[i]=data;
          

            i = 177;
            data = "1 goal (ID 1516)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  ============================	  sg_op (projection F f)	    (projection F	       (-	        grp_pullback_pr1 (projection F) (inclusion E)	          ((p^$).1 (ab_biprod_inr b)))) = point E	";
            responses[i]=data;
          

            i = 178;
            data = "1 goal (ID 1538)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  ============================	  projection F f -	  projection F	    (grp_pullback_pr1 (projection F) (inclusion E)	       ((p^$).1 (ab_biprod_inr b))) = point E	";
            responses[i]=data;
          

            i = 179;
            data = "1 goal (ID 1568)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  ============================	  projection F f - projection F f = point E	";
            responses[i]=data;
          

            i = 180;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 1377) is:	 Tr (-1)	   (hfiber	      (cxfib	         (Build_pHomotopy	            (fun a0 : A =>	             ap (projection E)	               (let X :=	                  fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	                X F a0) @ grp_homo_unit (projection E))	            (path_ishprop	               (ap (projection E)	                  (let X :=	                     fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	                     in	                   X F (point A)) @ grp_homo_unit (projection E))	               (dpoint_eq	                  (grp_quotient_rec F	                     {|	                       normalsubgroup_subgroup :=	                         abses_pullback_inclusion_transpose_subgroup	                           (inclusion E) F p;	                       normalsubgroup_isnormal :=	                         isnormal_ab_subgroup F	                           (abses_pullback_inclusion_transpose_subgroup	                              (inclusion E) F p)	                     |} (projection E $o projection F)	                     (fun (f0 : F)	                        (X : {|	                               normalsubgroup_subgroup :=	                                 abses_pullback_inclusion_transpose_subgroup	                                   (inclusion E) F p;	                               normalsubgroup_isnormal :=	                                 isnormal_ab_subgroup F	                                   (abses_pullback_inclusion_transpose_subgroup	                                      (inclusion E) F p)	                             |} f0) =>	                      internal_paths_rew F	                        ((grp_pullback_pr1 (projection F) (inclusion E) $o	                          grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                        (fun f1 : F =>	                         (projection E $o projection F) f1 = mon_unit)	                        (ap (projection E)	                           (abses_pullback_inclusion_transpose_beta	                              (inclusion E) F p X.1) @	                         (let X0 :=	                            fun E0 : AbSES' C B =>	                            pointed_fun (iscomplex_abses E0) in	                          X0 E X.1)) f0 X.2)	                   o* (grp_quotient_map $o inclusion F)) @	                (dpoint_eq pconst)^)))) (y; q))	1 goal (ID 1377)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  a : merely	        (hfiber (inclusion F)	           (sg_op f	              (-	               grp_pullback_pr1 (projection F) (inclusion E)	                 ((p^$).1 (ab_biprod_inr b)))))	  ============================	  Tr (-1)	    (hfiber	       (cxfib	          (Build_pHomotopy	             (fun a0 : A =>	              ap (projection E)	                (let X :=	                   fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	                 X F a0) @ grp_homo_unit (projection E))	             (path_ishprop	                (ap (projection E)	                   (let X :=	                      fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	                      in	                    X F (point A)) @ grp_homo_unit (projection E))	                (dpoint_eq	                   (grp_quotient_rec F	                      {|	                        normalsubgroup_subgroup :=	                          abses_pullback_inclusion_transpose_subgroup	                            (inclusion E) F p;	                        normalsubgroup_isnormal :=	                          isnormal_ab_subgroup F	                            (abses_pullback_inclusion_transpose_subgroup	                               (inclusion E) F p)	                      |} (projection E $o projection F)	                      (fun (f0 : F)	                         (X : {|	                                normalsubgroup_subgroup :=	                                  abses_pullback_inclusion_transpose_subgroup	                                    (inclusion E) F p;	                                normalsubgroup_isnormal :=	                                  isnormal_ab_subgroup F	                                    (abses_pullback_inclusion_transpose_subgroup	                                       (inclusion E) F p)	                              |} f0) =>	                       internal_paths_rew F	                         ((grp_pullback_pr1 (projection F) (inclusion E) $o	                           grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                         (fun f1 : F =>	                          (projection E $o projection F) f1 = mon_unit)	                         (ap (projection E)	                            (abses_pullback_inclusion_transpose_beta	                               (inclusion E) F p X.1) @	                          (let X0 :=	                             fun E0 : AbSES' C B =>	                             pointed_fun (iscomplex_abses E0) in	                           X0 E X.1)) f0 X.2)	                    o* (grp_quotient_map $o inclusion F)) @	                 (dpoint_eq pconst)^)))) (y; q))	";
            responses[i]=data;
          

            i = 181;
            data = "";
            responses[i]=data;
          

            i = 182;
            data = "1 goal (ID 1590)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  a : A	  q2 : inclusion F a =	       sg_op f	         (-	          grp_pullback_pr1 (projection F) (inclusion E)	            ((p^$).1 (ab_biprod_inr b)))	  ============================	  Tr (-1)	    (hfiber	       (cxfib	          (Build_pHomotopy	             (fun a0 : A =>	              ap (projection E)	                (let X :=	                   fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	                 X F a0) @ grp_homo_unit (projection E))	             (path_ishprop	                (ap (projection E)	                   (let X :=	                      fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	                      in	                    X F (point A)) @ grp_homo_unit (projection E))	                (dpoint_eq	                   (grp_quotient_rec F	                      {|	                        normalsubgroup_subgroup :=	                          abses_pullback_inclusion_transpose_subgroup	                            (inclusion E) F p;	                        normalsubgroup_isnormal :=	                          isnormal_ab_subgroup F	                            (abses_pullback_inclusion_transpose_subgroup	                               (inclusion E) F p)	                      |} (projection E $o projection F)	                      (fun (f0 : F)	                         (X : {|	                                normalsubgroup_subgroup :=	                                  abses_pullback_inclusion_transpose_subgroup	                                    (inclusion E) F p;	                                normalsubgroup_isnormal :=	                                  isnormal_ab_subgroup F	                                    (abses_pullback_inclusion_transpose_subgroup	                                       (inclusion E) F p)	                              |} f0) =>	                       internal_paths_rew F	                         ((grp_pullback_pr1 (projection F) (inclusion E) $o	                           grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                         (fun f1 : F =>	                          (projection E $o projection F) f1 = mon_unit)	                         (ap (projection E)	                            (abses_pullback_inclusion_transpose_beta	                               (inclusion E) F p X.1) @	                          (let X0 :=	                             fun E0 : AbSES' C B =>	                             pointed_fun (iscomplex_abses E0) in	                           X0 E X.1)) f0 X.2)	                    o* (grp_quotient_map $o inclusion F)) @	                 (dpoint_eq pconst)^)))) (y; q))	1 goal (ID 1598)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  a : A	  q2 : inclusion F a =	       sg_op f	         (-	          grp_pullback_pr1 (projection F) (inclusion E)	            ((p^$).1 (ab_biprod_inr b)))	  ============================	  cxfib	    (Build_pHomotopy	       (fun a0 : A =>	        ap (projection E)	          (let X := fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	             in	           X F a0) @ grp_homo_unit (projection E))	       (path_ishprop	          (ap (projection E)	             (let X :=	                fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	              X F (point A)) @ grp_homo_unit (projection E))	          (dpoint_eq	             (grp_quotient_rec F	                {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} (projection E $o projection F)	                (fun (f0 : F)	                   (X : {|	                          normalsubgroup_subgroup :=	                            abses_pullback_inclusion_transpose_subgroup	                              (inclusion E) F p;	                          normalsubgroup_isnormal :=	                            isnormal_ab_subgroup F	                              (abses_pullback_inclusion_transpose_subgroup	                                 (inclusion E) F p)	                        |} f0) =>	                 internal_paths_rew F	                   ((grp_pullback_pr1 (projection F) (inclusion E) $o	                     grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                   (fun f1 : F =>	                    (projection E $o projection F) f1 = mon_unit)	                   (ap (projection E)	                      (abses_pullback_inclusion_transpose_beta 	                         (inclusion E) F p X.1) @	                    (let X0 :=	                       fun E0 : AbSES' C B =>	                       pointed_fun (iscomplex_abses E0) in	                     X0 E X.1)) f0 X.2) o* (grp_quotient_map $o inclusion F)) @	           (dpoint_eq pconst)^))) a = (y; q)	2 goals (ID 1599)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  a : A	  q2 : inclusion F a =	       sg_op f	         (-	          grp_pullback_pr1 (projection F) (inclusion E)	            ((p^$).1 (ab_biprod_inr b)))	  ============================	  forall x : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p,	  IsHProp	    (grp_quotient_rec F	       {|	         normalsubgroup_subgroup :=	           abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	         normalsubgroup_isnormal :=	           isnormal_ab_subgroup F	             (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	       |} (projection E $o projection F)	       (fun (f0 : F)	          (X : {|	                 normalsubgroup_subgroup :=	                   abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p;	                 normalsubgroup_isnormal :=	                   isnormal_ab_subgroup F	                     (abses_pullback_inclusion_transpose_subgroup	                        (inclusion E) F p)	               |} f0) =>	        internal_paths_rew F	          ((grp_pullback_pr1 (projection F) (inclusion E) $o	            grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	          (fun f1 : F => (projection E $o projection F) f1 = mon_unit)	          (ap (projection E)	             (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	           (let X0 := fun E0 : AbSES' C B => pointed_fun (iscomplex_abses E0)	              in	            X0 E X.1)) f0 X.2) x = point C)		goal 2 (ID 1600) is:	 (cxfib	    (Build_pHomotopy	       (fun a0 : A =>	        ap (projection E)	          (let X := fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	             in	           X F a0) @ grp_homo_unit (projection E))	       (path_ishprop	          (ap (projection E)	             (let X :=	                fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	              X F (point A)) @ grp_homo_unit (projection E))	          (dpoint_eq	             (grp_quotient_rec F	                {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} (projection E $o projection F)	                (fun (f0 : F)	                   (X : {|	                          normalsubgroup_subgroup :=	                            abses_pullback_inclusion_transpose_subgroup	                              (inclusion E) F p;	                          normalsubgroup_isnormal :=	                            isnormal_ab_subgroup F	                              (abses_pullback_inclusion_transpose_subgroup	                                 (inclusion E) F p)	                        |} f0) =>	                 internal_paths_rew F	                   ((grp_pullback_pr1 (projection F) (inclusion E) $o	                     grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                   (fun f1 : F =>	                    (projection E $o projection F) f1 = mon_unit)	                   (ap (projection E)	                      (abses_pullback_inclusion_transpose_beta 	                         (inclusion E) F p X.1) @	                    (let X0 :=	                       fun E0 : AbSES' C B =>	                       pointed_fun (iscomplex_abses E0) in	                     X0 E X.1)) f0 X.2) o* (grp_quotient_map $o inclusion F)) @	           (dpoint_eq pconst)^))) a).1 = (y; q).1	";
            responses[i]=data;
          

            i = 183;
            data = "1 goal (ID 1600)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  a : A	  q2 : inclusion F a =	       sg_op f	         (-	          grp_pullback_pr1 (projection F) (inclusion E)	            ((p^$).1 (ab_biprod_inr b)))	  ============================	  (cxfib	     (Build_pHomotopy	        (fun a0 : A =>	         ap (projection E)	           (let X := fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0)	              in	            X F a0) @ grp_homo_unit (projection E))	        (path_ishprop	           (ap (projection E)	              (let X :=	                 fun E0 : AbSES' E A => pointed_fun (iscomplex_abses E0) in	               X F (point A)) @ grp_homo_unit (projection E))	           (dpoint_eq	              (grp_quotient_rec F	                 {|	                   normalsubgroup_subgroup :=	                     abses_pullback_inclusion_transpose_subgroup	                       (inclusion E) F p;	                   normalsubgroup_isnormal :=	                     isnormal_ab_subgroup F	                       (abses_pullback_inclusion_transpose_subgroup	                          (inclusion E) F p)	                 |} (projection E $o projection F)	                 (fun (f0 : F)	                    (X : {|	                           normalsubgroup_subgroup :=	                             abses_pullback_inclusion_transpose_subgroup	                               (inclusion E) F p;	                           normalsubgroup_isnormal :=	                             isnormal_ab_subgroup F	                               (abses_pullback_inclusion_transpose_subgroup	                                  (inclusion E) F p)	                         |} f0) =>	                  internal_paths_rew F	                    ((grp_pullback_pr1 (projection F) (inclusion E) $o	                      grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	                    (fun f1 : F =>	                     (projection E $o projection F) f1 = mon_unit)	                    (ap (projection E)	                       (abses_pullback_inclusion_transpose_beta 	                          (inclusion E) F p X.1) @	                     (let X0 :=	                        fun E0 : AbSES' C B =>	                        pointed_fun (iscomplex_abses E0) in	                      X0 E X.1)) f0 X.2) o* (grp_quotient_map $o inclusion F)) @	            (dpoint_eq pconst)^))) a).1 = (y; q).1	";
            responses[i]=data;
          

            i = 184;
            data = "1 goal (ID 1626)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  a : A	  q2 : inclusion F a =	       sg_op f	         (-	          grp_pullback_pr1 (projection F) (inclusion E)	            ((p^$).1 (ab_biprod_inr b)))	  ============================	  grp_quotient_map	    (sg_op f	       (-	        grp_pullback_pr1 (projection F) (inclusion E)	          ((p^$).1 (ab_biprod_inr b)))) = grp_quotient_map f	";
            responses[i]=data;
          

            i = 185;
            data = "1 goal (ID 1641)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  a : A	  q2 : inclusion F a =	       sg_op f	         (-	          grp_pullback_pr1 (projection F) (inclusion E)	            ((p^$).1 (ab_biprod_inr b)))	  ============================	  sg_op (grp_quotient_map f)	    (grp_quotient_map	       (-	        grp_pullback_pr1 (projection F) (inclusion E)	          ((p^$).1 (ab_biprod_inr b)))) = grp_quotient_map f	";
            responses[i]=data;
          

            i = 186;
            data = "1 goal (ID 1649)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  a : A	  q2 : inclusion F a =	       sg_op f	         (-	          grp_pullback_pr1 (projection F) (inclusion E)	            ((p^$).1 (ab_biprod_inr b)))	  ============================	  grp_quotient_map	    (-	     grp_pullback_pr1 (projection F) (inclusion E)	       ((p^$).1 (ab_biprod_inr b))) =	  sg_op (- grp_quotient_map f) (grp_quotient_map f)	";
            responses[i]=data;
          

            i = 187;
            data = "1 goal (ID 1668)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  a : A	  q2 : inclusion F a =	       sg_op f	         (-	          grp_pullback_pr1 (projection F) (inclusion E)	            ((p^$).1 (ab_biprod_inr b)))	  ============================	  grp_quotient_map	    (-	     grp_pullback_pr1 (projection F) (inclusion E)	       ((p^$).1 (ab_biprod_inr b))) = congquot_mon_unit	";
            responses[i]=data;
          

            i = 188;
            data = "1 goal (ID 1673)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  a : A	  q2 : inclusion F a =	       sg_op f	         (-	          grp_pullback_pr1 (projection F) (inclusion E)	            ((p^$).1 (ab_biprod_inr b)))	  ============================	  in_cosetL	    {|	      normalsubgroup_subgroup :=	        abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	      normalsubgroup_isnormal :=	        isnormal_ab_subgroup F	          (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	    |}	    (-	     grp_pullback_pr1 (projection F) (inclusion E)	       ((p^$).1 (ab_biprod_inr b))) mon_unit	";
            responses[i]=data;
          

            i = 189;
            data = "1 goal (ID 1675)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  a : A	  q2 : inclusion F a =	       sg_op f	         (-	          grp_pullback_pr1 (projection F) (inclusion E)	            ((p^$).1 (ab_biprod_inr b)))	  ============================	  (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	   ab_biprod_inr) b =	  sg_op	    (-	     -	     grp_pullback_pr1 (projection F) (inclusion E)	       ((p^$).1 (ab_biprod_inr b))) mon_unit	";
            responses[i]=data;
          

            i = 190;
            data = "1 goal (ID 1688)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  y : abses_pullback_inclusion_transpose_endpoint' (inclusion E) F p	  q : grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (projection E $o projection F)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         internal_paths_rew F	           ((grp_pullback_pr1 (projection F) (inclusion E) $o	             grp_iso_inverse p.1 $o ab_biprod_inr) X.1)	           (fun f0 : F => (projection E $o projection F) f0 = mon_unit)	           (ap (projection E)	              (abses_pullback_inclusion_transpose_beta (inclusion E) F p X.1) @	            (let X0 := fun E : AbSES' C B => pointed_fun (iscomplex_abses E)	               in	             X0 E X.1)) f X.2) y = point C	  f : F	  q0 : grp_quotient_map f = y	  b : B	  q1 : inclusion E b = projection F f	  a : A	  q2 : inclusion F a =	       sg_op f	         (-	          grp_pullback_pr1 (projection F) (inclusion E)	            ((p^$).1 (ab_biprod_inr b)))	  ============================	  (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	   ab_biprod_inr) b =	  -	  - grp_pullback_pr1 (projection F) (inclusion E) ((p^$).1 (ab_biprod_inr b))	";
            responses[i]=data;
          

            i = 191;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 192;
            data = "";
            responses[i]=data;
          

            i = 193;
            data = "";
            responses[i]=data;
          

            i = 194;
            data = "";
            responses[i]=data;
          

            i = 195;
            data = "";
            responses[i]=data;
          

            i = 196;
            data = "";
            responses[i]=data;
          

            i = 197;
            data = "";
            responses[i]=data;
          

            i = 198;
            data = "";
            responses[i]=data;
          

            i = 199;
            data = "";
            responses[i]=data;
          

            i = 200;
            data = "";
            responses[i]=data;
          

            i = 201;
            data = "";
            responses[i]=data;
          

            i = 202;
            data = "";
            responses[i]=data;
          

            i = 203;
            data = "";
            responses[i]=data;
          

            i = 204;
            data = "";
            responses[i]=data;
          

            i = 205;
            data = "";
            responses[i]=data;
          

            i = 206;
            data = "";
            responses[i]=data;
          

            i = 207;
            data = "";
            responses[i]=data;
          

            i = 208;
            data = "";
            responses[i]=data;
          

            i = 209;
            data = "";
            responses[i]=data;
          

            i = 210;
            data = "";
            responses[i]=data;
          

            i = 211;
            data = "";
            responses[i]=data;
          

            i = 212;
            data = "";
            responses[i]=data;
          

            i = 213;
            data = "";
            responses[i]=data;
          

            i = 214;
            data = "";
            responses[i]=data;
          

            i = 215;
            data = "";
            responses[i]=data;
          

            i = 216;
            data = "";
            responses[i]=data;
          

            i = 217;
            data = "";
            responses[i]=data;
          

            i = 218;
            data = "";
            responses[i]=data;
          

            i = 219;
            data = "";
            responses[i]=data;
          

            i = 220;
            data = "";
            responses[i]=data;
          

            i = 221;
            data = "";
            responses[i]=data;
          

            i = 222;
            data = "";
            responses[i]=data;
          

            i = 223;
            data = "";
            responses[i]=data;
          

            i = 224;
            data = "";
            responses[i]=data;
          

            i = 225;
            data = "1 goal (ID 278)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  AbSESMorphism F (abses_pullback_trivial_preimage E F p)	5 goals (ID 336)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  A $-> A		goal 2 (ID 338) is:	 F $-> abses_pullback_trivial_preimage E F p	goal 3 (ID 340) is:	 E $-> C	goal 4 (ID 342) is:	 inclusion (abses_pullback_trivial_preimage E F p) $o ?component1 ==	 ?component2 $o inclusion F	goal 5 (ID 344) is:	 projection (abses_pullback_trivial_preimage E F p) $o ?component2 ==	 ?component3 $o projection F	1 goal (ID 336)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  A $-> A	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	4 goals		goal 1 (ID 338) is:	 F $-> abses_pullback_trivial_preimage E F p	goal 2 (ID 340) is:	 E $-> C	goal 3 (ID 342) is:	 inclusion (abses_pullback_trivial_preimage E F p) $o grp_homo_id ==	 ?component2 $o inclusion F	goal 4 (ID 344) is:	 projection (abses_pullback_trivial_preimage E F p) $o ?component2 ==	 ?component3 $o projection F	1 goal (ID 338)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  F $-> abses_pullback_trivial_preimage E F p	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 goals		goal 1 (ID 340) is:	 E $-> C	goal 2 (ID 342) is:	 inclusion (abses_pullback_trivial_preimage E F p) $o grp_homo_id ==	 grp_quotient_map $o inclusion F	goal 3 (ID 344) is:	 projection (abses_pullback_trivial_preimage E F p) $o grp_quotient_map ==	 ?component3 $o projection F	1 goal (ID 340)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  E $-> C	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 342) is:	 inclusion (abses_pullback_trivial_preimage E F p) $o grp_homo_id ==	 grp_quotient_map $o inclusion F	goal 2 (ID 344) is:	 projection (abses_pullback_trivial_preimage E F p) $o grp_quotient_map ==	 projection E $o projection F	1 goal (ID 342)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  inclusion (abses_pullback_trivial_preimage E F p) $o grp_homo_id ==	  grp_quotient_map $o inclusion F	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 344) is:	 projection (abses_pullback_trivial_preimage E F p) $o grp_quotient_map ==	 projection E $o projection F	1 goal (ID 344)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  projection (abses_pullback_trivial_preimage E F p) $o grp_quotient_map ==	  projection E $o projection F	No more goals.	";
            responses[i]=data;
          

            i = 226;
            data = "";
            responses[i]=data;
          

            i = 227;
            data = "";
            responses[i]=data;
          

            i = 228;
            data = "";
            responses[i]=data;
          

            i = 229;
            data = "";
            responses[i]=data;
          

            i = 230;
            data = "";
            responses[i]=data;
          

            i = 231;
            data = "";
            responses[i]=data;
          

            i = 232;
            data = "";
            responses[i]=data;
          

            i = 233;
            data = "";
            responses[i]=data;
          

            i = 234;
            data = "";
            responses[i]=data;
          

            i = 235;
            data = "";
            responses[i]=data;
          

            i = 236;
            data = "";
            responses[i]=data;
          

            i = 237;
            data = "";
            responses[i]=data;
          

            i = 238;
            data = "";
            responses[i]=data;
          

            i = 239;
            data = "";
            responses[i]=data;
          

            i = 240;
            data = "1 goal (ID 294)	  	  H : Funext	  A, B, C : AbGroup	  E : AbSES C B	  ============================	  AbSES C A ->	  graph_hfiber (abses_pullback0 (inclusion E)) (point (AbSES B A))	";
            responses[i]=data;
          

            i = 241;
            data = "";
            responses[i]=data;
          

            i = 242;
            data = "1 goal (ID 295)	  	  H : Funext	  A, B, C : AbGroup	  E : AbSES C B	  Y : AbSES C A	  ============================	  graph_hfiber (abses_pullback0 (inclusion E)) (point (AbSES B A))	";
            responses[i]=data;
          

            i = 243;
            data = "1 goal (ID 302)	  	  H : Funext	  A, B, C : AbGroup	  E : AbSES C B	  Y : AbSES C A	  ============================	  abses_pullback0 (inclusion E) (abses_pullback0 (projection E) Y) $->	  point (AbSES B A)	";
            responses[i]=data;
          

            i = 244;
            data = "1 goal (ID 319)	  	  H : Funext	  A, B, C : AbGroup	  E : AbSES C B	  Y : AbSES C A	  ============================	  abses_pullback0 (projection E $o inclusion E) Y $== point (AbSES B A)	";
            responses[i]=data;
          

            i = 245;
            data = "2 goals (ID 337)	  	  H : Funext	  A, B, C : AbGroup	  E : AbSES C B	  Y : AbSES C A	  ============================	  projection E $o inclusion E == grp_homo_const		goal 2 (ID 338) is:	 abses_pullback0 grp_homo_const Y $== point (AbSES B A)	";
            responses[i]=data;
          

            i = 246;
            data = "1 goal (ID 338)	  	  H : Funext	  A, B, C : AbGroup	  E : AbSES C B	  Y : AbSES C A	  ============================	  abses_pullback0 grp_homo_const Y $== point (AbSES B A)	";
            responses[i]=data;
          

            i = 247;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 248;
            data = "";
            responses[i]=data;
          

            i = 249;
            data = "<infomsg>hfiber_cxfib' is defined</infomsg>	";
            responses[i]=data;
          

            i = 250;
            data = "1 goal (ID 368)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  U : AbSES C A	  ============================	  equiv_ptransformation_phomotopy	    (iscomplex_abses_pullback' (inclusion E) (projection E)	       (iscomplex_abses E)) U = equiv_path_abses_iso (cxfib' E U).2	";
            responses[i]=data;
          

            i = 251;
            data = "";
            responses[i]=data;
          

            i = 252;
            data = "1 goal (ID 411)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  U : AbSES C A	  ============================	  equiv_path_abses_iso	    ((iscomplex_abses_pullback' (inclusion E) (projection E)	        (iscomplex_abses E)).1 U) = equiv_path_abses_iso (cxfib' E U).2	";
            responses[i]=data;
          

            i = 253;
            data = "1 goal (ID 421)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  U : AbSES C A	  ============================	  (iscomplex_abses_pullback' (inclusion E) (projection E) (iscomplex_abses E)).1	    U = (cxfib' E U).2	";
            responses[i]=data;
          

            i = 254;
            data = "1 goal (ID 460)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  U : AbSES C A	  ============================	  (iscomplex_abses_pullback' (inclusion E) (projection E) (iscomplex_abses E)).1	    U $== (cxfib' E U).2	";
            responses[i]=data;
          

            i = 255;
            data = "1 goal (ID 482)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  U : AbSES C A	  ============================	  (abses_pullback_pconst' ^*$).1 U $o	  (abses_pullback_phomotopic' (projection E $o inclusion E) grp_homo_const	     (iscomplex_abses E)).1 U $==	  abses_pullback_homotopic' (projection E $o inclusion E) grp_homo_const	    (iscomplex_abses E) U $@	  symmetric_GpdHom (point (AbSES B A)) (abses_pullback0 grp_homo_const U)	    (abses_pullback_const' U)	";
            responses[i]=data;
          

            i = 256;
            data = "1 goal (ID 514)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  U : AbSES C A	  ============================	  (abses_pullback_pconst'.1 U)^$ $==	  symmetric_GpdHom (point (AbSES B A)) (abses_pullback0 grp_homo_const U)	    (abses_pullback_const' U)	";
            responses[i]=data;
          

            i = 257;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 258;
            data = "";
            responses[i]=data;
          

            i = 259;
            data = "";
            responses[i]=data;
          

            i = 260;
            data = "";
            responses[i]=data;
          

            i = 261;
            data = "";
            responses[i]=data;
          

            i = 262;
            data = "";
            responses[i]=data;
          

            i = 263;
            data = "";
            responses[i]=data;
          

            i = 264;
            data = "";
            responses[i]=data;
          

            i = 265;
            data = "";
            responses[i]=data;
          

            i = 266;
            data = "1 goal (ID 405)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  U : AbSES C A	  ============================	  cxfib (iscomplex_pullback_abses E) U =	  equiv_hfiber_abses (abses_pullback0 (inclusion E)) 	    (point (AbSES B A)) (cxfib' E U)	";
            responses[i]=data;
          

            i = 267;
            data = "";
            responses[i]=data;
          

            i = 268;
            data = "2 goals (ID 439)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  U : AbSES C A	  ============================	  (cxfib (iscomplex_pullback_abses E) U).1 =	  (equiv_hfiber_abses (abses_pullback0 (inclusion E)) 	     (point (AbSES B A)) (cxfib' E U)).1		goal 2 (ID 441) is:	 transport	   (fun x : AbSES E A => abses_pullback (inclusion E) x = point (AbSES B A))	   ?p (cxfib (iscomplex_pullback_abses E) U).2 =	 (equiv_hfiber_abses (abses_pullback0 (inclusion E)) 	    (point (AbSES B A)) (cxfib' E U)).2	";
            responses[i]=data;
          

            i = 269;
            data = "1 goal (ID 441)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  U : AbSES C A	  ============================	  transport	    (fun x : AbSES E A => abses_pullback (inclusion E) x = point (AbSES B A))	    1 (cxfib (iscomplex_pullback_abses E) U).2 =	  (equiv_hfiber_abses (abses_pullback0 (inclusion E)) 	     (point (AbSES B A)) (cxfib' E U)).2	";
            responses[i]=data;
          

            i = 270;
            data = "1 goal (ID 454)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  U : AbSES C A	  ============================	  (to_pointed_compose (abses_pullback' (projection E))	     (abses_pullback' (inclusion E)) @*	   (let X := equiv_fun equiv_ptransformation_phomotopy in	    X	      (iscomplex_abses_pullback' (inclusion E) (projection E)	         (iscomplex_abses E)))) U =	  (equiv_hfiber_abses (abses_pullback0 (inclusion E)) 	     (point (AbSES B A)) (cxfib' E U)).2	";
            responses[i]=data;
          

            i = 271;
            data = "1 goal (ID 471)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  U : AbSES C A	  ============================	  (let X := equiv_fun equiv_ptransformation_phomotopy in	   X	     (iscomplex_abses_pullback' (inclusion E) (projection E)	        (iscomplex_abses E))) U =	  (equiv_hfiber_abses (abses_pullback0 (inclusion E)) 	     (point (AbSES B A)) (cxfib' E U)).2	";
            responses[i]=data;
          

            i = 272;
            data = "1 goal (ID 477)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  U : AbSES C A	  ============================	  equiv_ptransformation_phomotopy	    (iscomplex_abses_pullback' (inclusion E) (projection E)	       (iscomplex_abses E)) U =	  (equiv_hfiber_abses (abses_pullback0 (inclusion E)) 	     (point (AbSES B A)) (cxfib' E U)).2	";
            responses[i]=data;
          

            i = 273;
            data = "1 goal (ID 478)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  U : AbSES C A	  ============================	  equiv_ptransformation_phomotopy	    (iscomplex_abses_pullback' (inclusion E) (projection E)	       (iscomplex_abses E)) U = equiv_path_abses_iso (cxfib' E U).2	";
            responses[i]=data;
          

            i = 274;
            data = "";
            responses[i]=data;
          

            i = 275;
            data = "";
            responses[i]=data;
          

            i = 276;
            data = "";
            responses[i]=data;
          

            i = 277;
            data = "";
            responses[i]=data;
          

            i = 278;
            data = "";
            responses[i]=data;
          

            i = 279;
            data = "";
            responses[i]=data;
          

            i = 280;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 281;
            data = "1 goal (ID 459)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  hfiber_cxfib' E F p <~>	  hfiber (cxfib (iscomplex_pullback_abses E))	    (equiv_hfiber_abses (abses_pullback0 (inclusion E)) 	       (point (AbSES B A)) (F; p))	1 goal (ID 469)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U : AbSES C A	  ============================	  hfiber_abses_path (cxfib' E U) (F; p) <~>	  cxfib (iscomplex_pullback_abses E) U =	  equiv_hfiber_abses (abses_pullback0 (inclusion E)) 	    (point (AbSES B A)) (F; p)	1 goal (ID 486)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U : AbSES C A	  ============================	  cxfib' E U = (F; p) <~>	  cxfib (iscomplex_pullback_abses E) U =	  equiv_hfiber_abses (abses_pullback0 (inclusion E)) 	    (point (AbSES B A)) (F; p)	1 goal (ID 507)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U : AbSES C A	  ============================	  equiv_hfiber_abses (abses_pullback0 (inclusion E)) 	    (point (AbSES B A)) (cxfib' E U) =	  equiv_hfiber_abses (abses_pullback0 (inclusion E)) 	    (point (AbSES B A)) (F; p) <~>	  cxfib (iscomplex_pullback_abses E) U =	  equiv_hfiber_abses (abses_pullback0 (inclusion E)) 	    (point (AbSES B A)) (F; p)	";
            responses[i]=data;
          

            i = 282;
            data = "1 goal (ID 511)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U : AbSES C A	  ============================	  cxfib (iscomplex_pullback_abses E) U =	  equiv_hfiber_abses (abses_pullback0 (inclusion E)) 	    (point (AbSES B A)) (cxfib' E U)	";
            responses[i]=data;
          

            i = 283;
            data = "";
            responses[i]=data;
          

            i = 284;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 285;
            data = "";
            responses[i]=data;
          

            i = 286;
            data = "";
            responses[i]=data;
          

            i = 287;
            data = "";
            responses[i]=data;
          

            i = 288;
            data = "";
            responses[i]=data;
          

            i = 289;
            data = "";
            responses[i]=data;
          

            i = 290;
            data = "";
            responses[i]=data;
          

            i = 291;
            data = "1 goal (ID 489)	  	  H : Funext	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  X : hfiber_cxfib' E F p	  Y : hfiber_cxfib' E F p	  ============================	  Type	";
            responses[i]=data;
          

            i = 292;
            data = "";
            responses[i]=data;
          

            i = 293;
            data = "1 goal (ID 500)	  	  H : Funext	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  X : hfiber_cxfib' E F p	  Y : hfiber_cxfib' E F p	  q0 : X.1 $== Y.1	  ============================	  Type	";
            responses[i]=data;
          

            i = 294;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 295;
            data = "";
            responses[i]=data;
          

            i = 296;
            data = "1 goal (ID 596)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U : hfiber_cxfib' E F p	  V : hfiber_cxfib' E F p	  q : U.1 = V.1	  ============================	  (transport (fun Y : AbSES C A => hfiber_abses_path (cxfib' E Y) (F; p)) q	     U.2).1 =	  fmap (abses_pullback0 (projection E)) (equiv_path_abses_iso^-1 q^) $@	  (U.2).1	";
            responses[i]=data;
          

            i = 297;
            data = "";
            responses[i]=data;
          

            i = 298;
            data = "1 goal (ID 605)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U : hfiber_cxfib' E F p	  V : hfiber_cxfib' E F p	  ============================	  (transport (fun Y : AbSES C A => hfiber_abses_path (cxfib' E Y) (F; p)) 1	     U.2).1 =	  fmap (abses_pullback0 (projection E)) (equiv_path_abses_iso^-1 1^) $@	  (U.2).1	";
            responses[i]=data;
          

            i = 299;
            data = "1 goal (ID 624)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U : hfiber_cxfib' E F p	  V : hfiber_cxfib' E F p	  ============================	  (U.2).1 =	  fmap (abses_pullback0 (projection E)) (equiv_path_abses_iso^-1 1^) $@	  (U.2).1	";
            responses[i]=data;
          

            i = 300;
            data = "1 goal (ID 672)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U : hfiber_cxfib' E F p	  V : hfiber_cxfib' E F p	  ============================	  (U.2).1 = fmap (abses_pullback0 (projection E)) (Id U.1) $@ (U.2).1	";
            responses[i]=data;
          

            i = 301;
            data = "1 goal (ID 725)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U : hfiber_cxfib' E F p	  V : hfiber_cxfib' E F p	  ============================	  (U.2).1 = Id (abses_pullback0 (projection E) U.1) $@ (U.2).1	";
            responses[i]=data;
          

            i = 302;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 303;
            data = "";
            responses[i]=data;
          

            i = 304;
            data = "1 goal (ID 643)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U, V : hfiber_cxfib' E F p	  ============================	  path_hfiber_cxfib' U V <~> U = V	";
            responses[i]=data;
          

            i = 305;
            data = "";
            responses[i]=data;
          

            i = 306;
            data = "1 goal (ID 656)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U, V : hfiber_cxfib' E F p	  ============================	  path_hfiber_cxfib' U V <~>	  {p0 : U.1 = V.1 &	  transport (fun Y : AbSES C A => hfiber_abses_path (cxfib' E Y) (F; p)) p0	    U.2 = V.2}	";
            responses[i]=data;
          

            i = 307;
            data = "1 goal (ID 678)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U, V : hfiber_cxfib' E F p	  q : abses_path_data_iso U.1 V.1	  ============================	  (fmap (abses_pullback0 (projection E)) q)^$ $@ (U.2).1 $== (V.2).1 <~>	  transport (fun Y : AbSES C A => hfiber_abses_path (cxfib' E Y) (F; p))	    (equiv_path_abses_iso q) U.2 = V.2	";
            responses[i]=data;
          

            i = 308;
            data = "";
            responses[i]=data;
          

            i = 309;
            data = "1 goal (ID 879)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U, V : hfiber_cxfib' E F p	  q : abses_path_data_iso U.1 V.1	  ============================	  (fmap (abses_pullback0 (projection E)) q)^$ $@ (U.2).1 $== (V.2).1 <~>	  (transport (fun Y : AbSES C A => hfiber_abses_path (cxfib' E Y) (F; p))	     (equiv_path_abses_iso q) U.2).1 = (V.2).1	2 focused goals (shelved: 1) (ID 893)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U, V : hfiber_cxfib' E F p	  q : abses_path_data_iso U.1 V.1	  ============================	  (transport (fun Y : AbSES C A => hfiber_abses_path (cxfib' E Y) (F; p))	     (equiv_path_abses_iso q) U.2).1 = ?Goal		goal 2 (ID 894) is:	 (fmap (abses_pullback0 (projection E)) q)^$ $@ (U.2).1 $== (V.2).1 <~>	 ?Goal = (V.2).1	";
            responses[i]=data;
          

            i = 310;
            data = "1 goal (ID 894)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U, V : hfiber_cxfib' E F p	  q : abses_path_data_iso U.1 V.1	  ============================	  (fmap (abses_pullback0 (projection E)) q)^$ $@ (U.2).1 $== (V.2).1 <~>	  fmap (abses_pullback0 (projection E))	    (equiv_path_abses_iso^-1 (equiv_path_abses_iso q)^) $@ 	  (U.2).1 = (V.2).1	";
            responses[i]=data;
          

            i = 311;
            data = "";
            responses[i]=data;
          

            i = 312;
            data = "2 focused goals (shelved: 1) (ID 1302)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U, V : hfiber_cxfib' E F p	  q : abses_path_data_iso U.1 V.1	  ============================	  (fmap (abses_pullback0 (projection E))	     (equiv_path_abses_iso^-1 (equiv_path_abses_iso q)^) $@ 	   (U.2).1).1 = ?Goal		goal 2 (ID 1303) is:	 (fmap (abses_pullback0 (projection E)) q)^$ $@ (U.2).1 $== (V.2).1 <~>	 ?Goal = ((V.2).1).1	1 focused goal (shelved: 1) (ID 1302)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U, V : hfiber_cxfib' E F p	  q : abses_path_data_iso U.1 V.1	  ============================	  (fmap (abses_pullback0 (projection E))	     (equiv_path_abses_iso^-1 (equiv_path_abses_iso q)^) $@ 	   (U.2).1).1 = ?Goal	1 focused goal (shelved: 1) (ID 1343)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U, V : hfiber_cxfib' E F p	  q : abses_path_data_iso U.1 V.1	  ============================	  equiv_path_abses_iso^-1 (equiv_path_abses_iso q)^ = ?Goal0	";
            responses[i]=data;
          

            i = 313;
            data = "1 focused goal (shelved: 1) (ID 1361)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U, V : hfiber_cxfib' E F p	  q : abses_path_data_iso U.1 V.1	  ============================	  equiv_path_abses_iso^-1 (equiv_path_abses_iso (abses_path_data_inverse q)) =	  ?Goal0	";
            responses[i]=data;
          

            i = 314;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 1303) is:	 (fmap (abses_pullback0 (projection E)) q)^$ $@ (U.2).1 $== (V.2).1 <~>	 (fmap (abses_pullback0 (projection E)) (abses_path_data_inverse q) $@	  (U.2).1).1 = ((V.2).1).1	1 goal (ID 1303)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U, V : hfiber_cxfib' E F p	  q : abses_path_data_iso U.1 V.1	  ============================	  (fmap (abses_pullback0 (projection E)) q)^$ $@ (U.2).1 $== (V.2).1 <~>	  (fmap (abses_pullback0 (projection E)) (abses_path_data_inverse q) $@	   (U.2).1).1 = ((V.2).1).1	2 focused goals (shelved: 1) (ID 1378)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U, V : hfiber_cxfib' E F p	  q : abses_path_data_iso U.1 V.1	  ============================	  (fmap (abses_pullback0 (projection E)) (abses_path_data_inverse q) $@	   (U.2).1).1 = ?Goal		goal 2 (ID 1379) is:	 (fmap (abses_pullback0 (projection E)) q)^$ $@ (U.2).1 $== (V.2).1 <~>	 ?Goal = ((V.2).1).1	";
            responses[i]=data;
          

            i = 315;
            data = "1 focused goal (shelved: 1) (ID 1378)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U, V : hfiber_cxfib' E F p	  q : abses_path_data_iso U.1 V.1	  ============================	  (fmap (abses_pullback0 (projection E)) (abses_path_data_inverse q) $@	   (U.2).1).1 = ?Goal	1 focused goal (shelved: 1) (ID 1408)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U, V : hfiber_cxfib' E F p	  q : abses_path_data_iso U.1 V.1	  ============================	  fmap (abses_pullback0 (projection E)) (abses_path_data_inverse q) = ?Goal0	";
            responses[i]=data;
          

            i = 316;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 1379) is:	 (fmap (abses_pullback0 (projection E)) q)^$ $@ (U.2).1 $== (V.2).1 <~>	 ((fmap (abses_pullback0 (projection E)) q)^$ $@ (U.2).1).1 = ((V.2).1).1	1 goal (ID 1379)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  U, V : hfiber_cxfib' E F p	  q : abses_path_data_iso U.1 V.1	  ============================	  (fmap (abses_pullback0 (projection E)) q)^$ $@ (U.2).1 $== (V.2).1 <~>	  ((fmap (abses_pullback0 (projection E)) q)^$ $@ (U.2).1).1 = ((V.2).1).1	No more goals.	";
            responses[i]=data;
          

            i = 317;
            data = "";
            responses[i]=data;
          

            i = 318;
            data = "";
            responses[i]=data;
          

            i = 319;
            data = "";
            responses[i]=data;
          

            i = 320;
            data = "";
            responses[i]=data;
          

            i = 321;
            data = "";
            responses[i]=data;
          

            i = 322;
            data = "";
            responses[i]=data;
          

            i = 323;
            data = "";
            responses[i]=data;
          

            i = 324;
            data = "";
            responses[i]=data;
          

            i = 325;
            data = "";
            responses[i]=data;
          

            i = 326;
            data = "";
            responses[i]=data;
          

            i = 327;
            data = "1 goal (ID 675)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  ============================	  hfiber_cxfib' E F p	";
            responses[i]=data;
          

            i = 328;
            data = "1 goal (ID 681)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  ============================	  hfiber_abses_path (cxfib' E (abses_pullback_trivial_preimage E F p)) (F; p)	";
            responses[i]=data;
          

            i = 329;
            data = "2 goals (ID 691)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  ============================	  (F; p).1 $-> (cxfib' E (abses_pullback_trivial_preimage E F p)).1		goal 2 (ID 693) is:	 (fun p0 : (cxfib' E (abses_pullback_trivial_preimage E F p)).1 $-> (F; p).1	  =>	  (fmap (abses_pullback0 (inclusion E)) p0)^$ $@	  (cxfib' E (abses_pullback_trivial_preimage E F p)).2 $-> 	  (F; p).2) ?Goal^$	";
            responses[i]=data;
          

            i = 330;
            data = "1 goal (ID 693)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  ============================	  (fun p0 : (cxfib' E (abses_pullback_trivial_preimage E F p)).1 $-> (F; p).1	   =>	   (fmap (abses_pullback0 (inclusion E)) p0)^$ $@	   (cxfib' E (abses_pullback_trivial_preimage E F p)).2 $-> 	   (F; p).2)	    (abses_component1_trivial_pullback'	       (abses_pullback_inclusion0_map' E F p) (fun x0 : A => 1%path))^$	";
            responses[i]=data;
          

            i = 331;
            data = "1 goal (ID 741)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  ============================	  (fmap (abses_pullback0 (inclusion E))	     (abses_component1_trivial_pullback'	        (abses_pullback_inclusion0_map' E F p) (fun x0 : A => 1%path))^$)^$ $@	  (cxfib' E (abses_pullback_trivial_preimage E F p)).2 $-> p	";
            responses[i]=data;
          

            i = 332;
            data = "1 goal (ID 767)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  ============================	  abses_pullback_homotopic' (projection E $o inclusion E) grp_homo_const	    (iscomplex_abses E) (abses_pullback_trivial_preimage E F p) $@	  symmetric_GpdHom (point (AbSES B A))	    (abses_pullback0 grp_homo_const (abses_pullback_trivial_preimage E F p))	    (abses_pullback_const' (abses_pullback_trivial_preimage E F p)) $o	  (abses_pullback_compose' (inclusion E) (projection E)	     (abses_pullback_trivial_preimage E F p) $o	   (fmap (abses_pullback0 (inclusion E))	      (abses_component1_trivial_pullback'	         (abses_pullback_inclusion0_map' E F p) (fun x0 : A => 1%path))^$)^$) $==	  p	";
            responses[i]=data;
          

            i = 333;
            data = "1 goal (ID 791)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  ============================	  symmetric_GpdHom (point (AbSES B A))	    (abses_pullback0 grp_homo_const (abses_pullback_trivial_preimage E F p))	    (abses_pullback_const' (abses_pullback_trivial_preimage E F p)) $o	  (abses_pullback_homotopic' (projection E $o inclusion E) grp_homo_const	     (iscomplex_abses E) (abses_pullback_trivial_preimage E F p) $o	   (abses_pullback_compose' (inclusion E) (projection E)	      (abses_pullback_trivial_preimage E F p) $o	    (fmap (abses_pullback0 (inclusion E))	       (abses_component1_trivial_pullback'	          (abses_pullback_inclusion0_map' E F p) (fun x0 : A => 1%path))^$)^$)) $==	  p	";
            responses[i]=data;
          

            i = 334;
            data = "1 goal (ID 805)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  ============================	  abses_pullback_homotopic' (projection E $o inclusion E) grp_homo_const	    (iscomplex_abses E) (abses_pullback_trivial_preimage E F p) $o	  (abses_pullback_compose' (inclusion E) (projection E)	     (abses_pullback_trivial_preimage E F p) $o	   (fmap (abses_pullback0 (inclusion E))	      (abses_component1_trivial_pullback'	         (abses_pullback_inclusion0_map' E F p) (fun x0 : A => 1%path))^$)^$) $==	  abses_pullback_const' (abses_pullback_trivial_preimage E F p) $o p	";
            responses[i]=data;
          

            i = 335;
            data = "1 goal (ID 819)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  ============================	  abses_pullback_homotopic' (projection E $o inclusion E) grp_homo_const	    (iscomplex_abses E) (abses_pullback_trivial_preimage E F p) $o	  (abses_pullback_compose' (inclusion E) (projection E)	     (abses_pullback_trivial_preimage E F p) $o	   (fmap (abses_pullback0 (inclusion E))	      (abses_component1_trivial_pullback'	         (abses_pullback_inclusion0_map' E F p) (fun x0 : A => 1%path))^$)^$) $o	  p^$ $== abses_pullback_const' (abses_pullback_trivial_preimage E F p)	";
            responses[i]=data;
          

            i = 336;
            data = "1 goal (ID 830)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  ============================	  ((abses_pullback_homotopic' (projection E $o inclusion E) grp_homo_const	      (iscomplex_abses E) (abses_pullback_trivial_preimage E F p) $o	    (abses_pullback_compose' (inclusion E) (projection E)	       (abses_pullback_trivial_preimage E F p) $o	     (fmap (abses_pullback0 (inclusion E))	        (abses_component1_trivial_pullback'	           (abses_pullback_inclusion0_map' E F p) 	           (fun x0 : A => 1%path))^$)^$) $o p^$).1 $o ab_biprod_inl ==	   (abses_pullback_const' (abses_pullback_trivial_preimage E F p)).1 $o	   ab_biprod_inl) *	  ((abses_pullback_homotopic' (projection E $o inclusion E) grp_homo_const	      (iscomplex_abses E) (abses_pullback_trivial_preimage E F p) $o	    (abses_pullback_compose' (inclusion E) (projection E)	       (abses_pullback_trivial_preimage E F p) $o	     (fmap (abses_pullback0 (inclusion E))	        (abses_component1_trivial_pullback'	           (abses_pullback_inclusion0_map' E F p) 	           (fun x0 : A => 1%path))^$)^$) $o p^$).1 $o ab_biprod_inr ==	   (abses_pullback_const' (abses_pullback_trivial_preimage E F p)).1 $o	   ab_biprod_inr)	";
            responses[i]=data;
          

            i = 337;
            data = "";
            responses[i]=data;
          

            i = 338;
            data = "";
            responses[i]=data;
          

            i = 339;
            data = "4 goals (ID 1140)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  ============================	  (fun x : A =>	   class_of	     (fun x0 y : F =>	      hfiber (fun x1 : B => pullback_pr1 ((p.1)^-1 (mon_unit, x1)))	        (sg_op (- x0) y)) (pullback_pr1 ((p.1)^-1 (x, mon_unit)))) ==	  (fun x : A =>	   class_of	     (fun x0 y : F =>	      hfiber (fun x1 : B => pullback_pr1 ((p.1)^-1 (mon_unit, x1)))	        (sg_op (- x0) y)) (inclusion F x))		goal 2 (ID 1141) is:	 (fun x : A => pullback_pr2 ((p.1)^-1 (x, mon_unit))) ==	 (fun _ : A => mon_unit)	goal 3 (ID 1142) is:	 (fun x : B =>	  class_of	    (fun x0 y : F =>	     hfiber (fun x1 : B => pullback_pr1 ((p.1)^-1 (mon_unit, x1)))	       (sg_op (- x0) y)) (pullback_pr1 ((p.1)^-1 (mon_unit, x)))) ==	 (fun _ : B =>	  class_of	    (fun x0 y : F =>	     hfiber (fun x1 : B => pullback_pr1 ((p.1)^-1 (mon_unit, x1)))	       (sg_op (- x0) y)) (inclusion F mon_unit))	goal 4 (ID 1143) is:	 (fun x : B => pullback_pr2 ((p.1)^-1 (mon_unit, x))) == idmap	1 goal (ID 1140)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  ============================	  (fun x : A =>	   class_of	     (fun x0 y : F =>	      hfiber (fun x1 : B => pullback_pr1 ((p.1)^-1 (mon_unit, x1)))	        (sg_op (- x0) y)) (pullback_pr1 ((p.1)^-1 (x, mon_unit)))) ==	  (fun x : A =>	   class_of	     (fun x0 y : F =>	      hfiber (fun x1 : B => pullback_pr1 ((p.1)^-1 (mon_unit, x1)))	        (sg_op (- x0) y)) (inclusion F x))	1 goal (ID 1145)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  a : A	  ============================	  class_of	    (fun x y : F =>	     hfiber (fun x0 : B => pullback_pr1 ((p.1)^-1 (mon_unit, x0)))	       (sg_op (- x) y)) (pullback_pr1 ((p.1)^-1 (a, mon_unit))) =	  class_of	    (fun x y : F =>	     hfiber (fun x0 : B => pullback_pr1 ((p.1)^-1 (mon_unit, x0)))	       (sg_op (- x) y)) (inclusion F a)	1 goal (ID 1155)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  a : A	  ============================	  pullback_pr1 ((p.1)^-1 (a, mon_unit)) = inclusion F a	";
            responses[i]=data;
          

            i = 340;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 goals		goal 1 (ID 1141) is:	 (fun x : A => pullback_pr2 ((p.1)^-1 (x, mon_unit))) ==	 (fun _ : A => mon_unit)	goal 2 (ID 1142) is:	 (fun x : B =>	  class_of	    (fun x0 y : F =>	     hfiber (fun x1 : B => pullback_pr1 ((p.1)^-1 (mon_unit, x1)))	       (sg_op (- x0) y)) (pullback_pr1 ((p.1)^-1 (mon_unit, x)))) ==	 (fun _ : B =>	  class_of	    (fun x0 y : F =>	     hfiber (fun x1 : B => pullback_pr1 ((p.1)^-1 (mon_unit, x1)))	       (sg_op (- x0) y)) (inclusion F mon_unit))	goal 3 (ID 1143) is:	 (fun x : B => pullback_pr2 ((p.1)^-1 (mon_unit, x))) == idmap	";
            responses[i]=data;
          

            i = 341;
            data = "1 goal (ID 1141)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  ============================	  (fun x : A => pullback_pr2 ((p.1)^-1 (x, mon_unit))) ==	  (fun _ : A => mon_unit)	1 goal (ID 1176)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  a : A	  ============================	  pullback_pr2 ((p.1)^-1 (a, mon_unit)) = mon_unit	";
            responses[i]=data;
          

            i = 342;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 1142) is:	 (fun x : B =>	  class_of	    (fun x0 y : F =>	     hfiber (fun x1 : B => pullback_pr1 ((p.1)^-1 (mon_unit, x1)))	       (sg_op (- x0) y)) (pullback_pr1 ((p.1)^-1 (mon_unit, x)))) ==	 (fun _ : B =>	  class_of	    (fun x0 y : F =>	     hfiber (fun x1 : B => pullback_pr1 ((p.1)^-1 (mon_unit, x1)))	       (sg_op (- x0) y)) (inclusion F mon_unit))	goal 2 (ID 1143) is:	 (fun x : B => pullback_pr2 ((p.1)^-1 (mon_unit, x))) == idmap	";
            responses[i]=data;
          

            i = 343;
            data = "1 goal (ID 1142)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  ============================	  (fun x : B =>	   class_of	     (fun x0 y : F =>	      hfiber (fun x1 : B => pullback_pr1 ((p.1)^-1 (mon_unit, x1)))	        (sg_op (- x0) y)) (pullback_pr1 ((p.1)^-1 (mon_unit, x)))) ==	  (fun _ : B =>	   class_of	     (fun x0 y : F =>	      hfiber (fun x1 : B => pullback_pr1 ((p.1)^-1 (mon_unit, x1)))	        (sg_op (- x0) y)) (inclusion F mon_unit))	1 goal (ID 1198)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  b : B	  ============================	  hfiber (fun x : B => pullback_pr1 ((p.1)^-1 (mon_unit, x)))	    (sg_op (- pullback_pr1 ((p.1)^-1 (mon_unit, b))) (inclusion F mon_unit))	";
            responses[i]=data;
          

            i = 344;
            data = "1 goal (ID 1202)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  b : B	  ============================	  pullback_pr1 ((p.1)^-1 (mon_unit, - b)) =	  sg_op (- pullback_pr1 ((p.1)^-1 (mon_unit, b))) (inclusion F mon_unit)	";
            responses[i]=data;
          

            i = 345;
            data = "1 goal (ID 1210)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  b : B	  ============================	  sg_op (pullback_pr1 ((p.1)^-1 (mon_unit, b)))	    (pullback_pr1 ((p.1)^-1 (mon_unit, - b))) = inclusion F mon_unit	";
            responses[i]=data;
          

            i = 346;
            data = "1 goal (ID 1255)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  b : B	  ============================	  (grp_pullback_pr1 (projection F) (inclusion E) $o (p^$).1 $o ab_biprod_inr)	    (sg_op b (group_inverse b)) = inclusion F mon_unit	";
            responses[i]=data;
          

            i = 347;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 1143) is:	 (fun x : B => pullback_pr2 ((p.1)^-1 (mon_unit, x))) == idmap	";
            responses[i]=data;
          

            i = 348;
            data = "1 goal (ID 1143)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  ============================	  (fun x : B => pullback_pr2 ((p.1)^-1 (mon_unit, x))) == idmap	1 goal (ID 1294)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback (inclusion E) F $== point (pfam_const (AbSES B A) F)	  b : B	  ============================	  pullback_pr2 ((p.1)^-1 (mon_unit, b)) = b	";
            responses[i]=data;
          

            i = 349;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 350;
            data = "";
            responses[i]=data;
          

            i = 351;
            data = "";
            responses[i]=data;
          

            i = 352;
            data = "";
            responses[i]=data;
          

            i = 353;
            data = "";
            responses[i]=data;
          

            i = 354;
            data = "";
            responses[i]=data;
          

            i = 355;
            data = "";
            responses[i]=data;
          

            i = 356;
            data = "";
            responses[i]=data;
          

            i = 357;
            data = "";
            responses[i]=data;
          

            i = 358;
            data = "";
            responses[i]=data;
          

            i = 359;
            data = "";
            responses[i]=data;
          

            i = 360;
            data = "";
            responses[i]=data;
          

            i = 361;
            data = "";
            responses[i]=data;
          

            i = 362;
            data = "";
            responses[i]=data;
          

            i = 363;
            data = "";
            responses[i]=data;
          

            i = 364;
            data = "";
            responses[i]=data;
          

            i = 365;
            data = "";
            responses[i]=data;
          

            i = 366;
            data = "";
            responses[i]=data;
          

            i = 367;
            data = "";
            responses[i]=data;
          

            i = 368;
            data = "";
            responses[i]=data;
          

            i = 369;
            data = "";
            responses[i]=data;
          

            i = 370;
            data = "";
            responses[i]=data;
          

            i = 371;
            data = "";
            responses[i]=data;
          

            i = 372;
            data = "";
            responses[i]=data;
          

            i = 373;
            data = "";
            responses[i]=data;
          

            i = 374;
            data = "";
            responses[i]=data;
          

            i = 375;
            data = "";
            responses[i]=data;
          

            i = 376;
            data = "";
            responses[i]=data;
          

            i = 377;
            data = "";
            responses[i]=data;
          

            i = 378;
            data = "";
            responses[i]=data;
          

            i = 379;
            data = "";
            responses[i]=data;
          

            i = 380;
            data = "";
            responses[i]=data;
          

            i = 381;
            data = "";
            responses[i]=data;
          

            i = 382;
            data = "";
            responses[i]=data;
          

            i = 383;
            data = "";
            responses[i]=data;
          

            i = 384;
            data = "";
            responses[i]=data;
          

            i = 385;
            data = "";
            responses[i]=data;
          

            i = 386;
            data = "";
            responses[i]=data;
          

            i = 387;
            data = "";
            responses[i]=data;
          

            i = 388;
            data = "";
            responses[i]=data;
          

            i = 389;
            data = "";
            responses[i]=data;
          

            i = 390;
            data = "";
            responses[i]=data;
          

            i = 391;
            data = "";
            responses[i]=data;
          

            i = 392;
            data = "1 goal (ID 711)	  	  H : Funext	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  ============================	  ab_biprod A B $-> abses_pullback0 (projection E) Y.1	1 goal (ID 716)	  	  H : Funext	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  q : hfiber_abses_path (cxfib' E Y) (F; p)	  ============================	  ab_biprod A B $-> abses_pullback0 (projection E) (Y; q).1	1 goal (ID 725)	  	  H : Funext	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  q : hfiber_abses_path (cxfib' E Y) (F; p)	  ============================	  GroupHomomorphism (abses_pullback0 (inclusion E) F)	    (abses_pullback0 (projection E) (Y; q).1)	1 goal (ID 740)	  	  H : Funext	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  q : hfiber_abses_path (cxfib' E Y) (F; p)	  ============================	  F $-> abses_pullback0 (projection E) (Y; q).1	No more goals.	1 goal (ID 724)	  	  A, B, C : AbGroup	  E : AbSES C B	  Y : AbSES C A	  ============================	  ab_biprod A B $-> abses_pullback0 (projection E) Y	1 goal (ID 740)	  	  A, B, C : AbGroup	  E : AbSES C B	  Y : AbSES C A	  ============================	  B $-> abses_pullback0 (projection E) Y	3 goals (ID 799)	  	  A, B, C : AbGroup	  E : AbSES C B	  Y : AbSES C A	  ============================	  B $-> Y		goal 2 (ID 801) is:	 B $-> E	goal 3 (ID 803) is:	 projection Y o ?b == projection E o ?c	1 goal (ID 799)	  	  A, B, C : AbGroup	  E : AbSES C B	  Y : AbSES C A	  ============================	  B $-> Y	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 801) is:	 B $-> E	goal 2 (ID 803) is:	 projection Y o grp_homo_const == projection E o ?c	1 goal (ID 801)	  	  A, B, C : AbGroup	  E : AbSES C B	  Y : AbSES C A	  ============================	  B $-> E	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 803) is:	 projection Y o grp_homo_const == projection E o inclusion E	1 goal (ID 803)	  	  A, B, C : AbGroup	  E : AbSES C B	  Y : AbSES C A	  ============================	  projection Y o grp_homo_const == projection E o inclusion E	1 goal (ID 809)	  	  A, B, C : AbGroup	  E : AbSES C B	  Y : AbSES C A	  x : B	  ============================	  projection Y (grp_homo_const x) = projection E (inclusion E x)	1 goal (ID 820)	  	  A, B, C : AbGroup	  E : AbSES C B	  Y : AbSES C A	  x : B	  ============================	  mon_unit = projection E (inclusion E x)	No more goals.	1 goal (ID 800)	  	  H : Univalence	  A, B, B' : AbGroup	  f : B' $-> B	  X, Y : graph_hfiber (abses_pullback0 f) (point (AbSES B' A))	  Q : hfiber_abses_path X Y	  ============================	  fmap (abses_pullback0 f) (Q.1)^$ $o (Y.2)^$ $== (X.2)^$	1 goal (ID 801)	  	  H : Univalence	  A, B, B' : AbGroup	  f : B' $-> B	  X, Y : graph_hfiber (abses_pullback0 f) (point (AbSES B' A))	  Q : hfiber_abses_path X Y	  ============================	  forall Q0 : hfiber_abses_path X Y,	  fmap (abses_pullback0 f) (Q0.1)^$ $o (Y.2)^$ $== (X.2)^$	1 goal (ID 828)	  	  H : Univalence	  A, B, B' : AbGroup	  f : B' $-> B	  X : graph_hfiber (abses_pullback0 f) (point (AbSES B' A))	  Q : hfiber_abses_path X X	  ============================	  fmap (abses_pullback0 f)	    ((((equiv_hfiber_abses_pullback (point (AbSES B' A)) X X)^-1)%equiv	        1%path).1)^$ $o (X.2)^$ $== (X.2)^$	2 focused goals (shelved: 1) (ID 854)	  	  H : Univalence	  A, B, B' : AbGroup	  f : B' $-> B	  X : graph_hfiber (abses_pullback0 f) (point (AbSES B' A))	  Q : hfiber_abses_path X X	  ============================	  fmap (abses_pullback0 f)	    ((((equiv_hfiber_abses_pullback (point (AbSES B' A)) X X)^-1)%equiv	        1%path).1)^$ $== ?Goal		goal 2 (ID 855) is:	 ?Goal $o (X.2)^$ $== (X.2)^$	1 focused goal (shelved: 1) (ID 854)	  	  H : Univalence	  A, B, B' : AbGroup	  f : B' $-> B	  X : graph_hfiber (abses_pullback0 f) (point (AbSES B' A))	  Q : hfiber_abses_path X X	  ============================	  fmap (abses_pullback0 f)	    ((((equiv_hfiber_abses_pullback (point (AbSES B' A)) X X)^-1)%equiv	        1%path).1)^$ $== ?Goal	2 goals (ID 854)	  	  H : Univalence	  A, B, B' : AbGroup	  f : B' $-> B	  X : graph_hfiber (abses_pullback0 f) (point (AbSES B' A))	  Q : hfiber_abses_path X X	  ============================	  fmap (abses_pullback0 f)	    ((((equiv_hfiber_abses_pullback (point (AbSES B' A)) X X)^-1)%equiv	        1%path).1)^$ $== ?Goal		goal 2 (ID 853) is:	 abses_pullback0 f X.1 $-> abses_pullback0 f X.1	1 goal (ID 854)	  	  H : Univalence	  A, B, B' : AbGroup	  f : B' $-> B	  X : graph_hfiber (abses_pullback0 f) (point (AbSES B' A))	  Q : hfiber_abses_path X X	  ============================	  fmap (abses_pullback0 f)	    ((((equiv_hfiber_abses_pullback (point (AbSES B' A)) X X)^-1)%equiv	        1%path).1)^$ $== Id (abses_pullback0 f X.1)	1 goal (ID 904)	  	  H : Univalence	  A, B, B' : AbGroup	  f : B' $-> B	  X : graph_hfiber (abses_pullback0 f) (point (AbSES B' A))	  Q : hfiber_abses_path X X	  ============================	  ((((equiv_hfiber_abses_pullback (point (AbSES B' A)) X X)^-1)%equiv 1%path).1)^$ $==	  Id X.1	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 855) is:	 Id (abses_pullback0 f X.1) $o (X.2)^$ $== (X.2)^$	1 goal (ID 855)	  	  H : Univalence	  A, B, B' : AbGroup	  f : B' $-> B	  X : graph_hfiber (abses_pullback0 f) (point (AbSES B' A))	  Q : hfiber_abses_path X X	  ============================	  Id (abses_pullback0 f X.1) $o (X.2)^$ $== (X.2)^$	No more goals.	";
            responses[i]=data;
          

            i = 393;
            data = "";
            responses[i]=data;
          

            i = 394;
            data = "1 goal (ID 841)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  ============================	  hfiber_cxfib'_induced_map E F p Y ==	  abses_pullback_splits_induced_map' E Y.1	";
            responses[i]=data;
          

            i = 395;
            data = "";
            responses[i]=data;
          

            i = 396;
            data = "1 goal (ID 848)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  a : A	  b : B	  ============================	  (((Y.2).1).1)^-1 (pullback_pr1 ((p.1)^-1 (a, b))) =	  grp_pullback_sgop (projection Y.1) (projection E)	    (inclusion Y.1 a; mon_unit;	    cx_isexact a @ (grp_homo_unit (projection E))^)	    (mon_unit; inclusion E b;	    grp_homo_unit (projection Y.1) @ (iscomplex_abses E b)^)	";
            responses[i]=data;
          

            i = 397;
            data = "1 goal (ID 879)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  a : A	  b : B	  ============================	  pullback_pr1 ((((cxfib' E Y.1).2)^$).1 (a, b)) =	  grp_pullback_sgop (projection Y.1) (projection E)	    (inclusion Y.1 a; mon_unit;	    cx_isexact a @ (grp_homo_unit (projection E))^)	    (mon_unit; inclusion E b;	    grp_homo_unit (projection Y.1) @ (iscomplex_abses E b)^)	";
            responses[i]=data;
          

            i = 398;
            data = "2 goals (ID 1225)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  a : A	  b : B	  ============================	  inclusion Y.1 a = sg_op (inclusion Y.1 a) mon_unit		goal 2 (ID 1226) is:	 inclusion E b = sg_op mon_unit (inclusion E b)	";
            responses[i]=data;
          

            i = 399;
            data = "1 goal (ID 1225)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  a : A	  b : B	  ============================	  inclusion Y.1 a = sg_op (inclusion Y.1 a) mon_unit	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 1226) is:	 inclusion E b = sg_op mon_unit (inclusion E b)	";
            responses[i]=data;
          

            i = 400;
            data = "1 goal (ID 1226)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  a : A	  b : B	  ============================	  inclusion E b = sg_op mon_unit (inclusion E b)	No more goals.	";
            responses[i]=data;
          

            i = 401;
            data = "";
            responses[i]=data;
          

            i = 402;
            data = "";
            responses[i]=data;
          

            i = 403;
            data = "";
            responses[i]=data;
          

            i = 404;
            data = "";
            responses[i]=data;
          

            i = 405;
            data = "";
            responses[i]=data;
          

            i = 406;
            data = "";
            responses[i]=data;
          

            i = 407;
            data = "";
            responses[i]=data;
          

            i = 408;
            data = "";
            responses[i]=data;
          

            i = 409;
            data = "";
            responses[i]=data;
          

            i = 410;
            data = "";
            responses[i]=data;
          

            i = 411;
            data = "";
            responses[i]=data;
          

            i = 412;
            data = "";
            responses[i]=data;
          

            i = 413;
            data = "";
            responses[i]=data;
          

            i = 414;
            data = "";
            responses[i]=data;
          

            i = 415;
            data = "";
            responses[i]=data;
          

            i = 416;
            data = "";
            responses[i]=data;
          

            i = 417;
            data = "";
            responses[i]=data;
          

            i = 418;
            data = "1 goal (ID 881)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  ============================	  abses_pullback_trivial_preimage E F p $== Y.1	";
            responses[i]=data;
          

            i = 419;
            data = "";
            responses[i]=data;
          

            i = 420;
            data = "1 goal (ID 886)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  ============================	  abses_pullback_trivial_preimage E F p $== (Y; Q).1	";
            responses[i]=data;
          

            i = 421;
            data = "3 goals (ID 898)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  ============================	  GroupHomomorphism (abses_pullback_trivial_preimage E F p) (Y; Q).1		goal 2 (ID 902) is:	 ?proj1 $o inclusion (abses_pullback_trivial_preimage E F p) ==	 inclusion (Y; Q).1	goal 3 (ID 904) is:	 projection (abses_pullback_trivial_preimage E F p) ==	 projection (Y; Q).1 $o ?proj1	";
            responses[i]=data;
          

            i = 422;
            data = "1 goal (ID 898)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  ============================	  GroupHomomorphism (abses_pullback_trivial_preimage E F p) (Y; Q).1	2 goals (ID 932)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  ============================	  F $-> (Y; Q).1		goal 2 (ID 934) is:	 forall n : F,	 {|	   normalsubgroup_subgroup :=	     abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	   normalsubgroup_isnormal :=	     isnormal_ab_subgroup F	       (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	 |} n -> ?f n = mon_unit	";
            responses[i]=data;
          

            i = 423;
            data = "1 goal (ID 934)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  ============================	  forall n : F,	  {|	    normalsubgroup_subgroup :=	      abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	    normalsubgroup_isnormal :=	      isnormal_ab_subgroup F	        (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	  |} n ->	  (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1) n =	  mon_unit	";
            responses[i]=data;
          

            i = 424;
            data = "1 goal (ID 963)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  f : F	  b : B	  q0 : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	        ab_biprod_inr) b = f	  ============================	  (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1) f =	  mon_unit	";
            responses[i]=data;
          

            i = 425;
            data = "1 goal (ID 979)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  f : F	  b : B	  q0 : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	        ab_biprod_inr) b = f	  ============================	  (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	    ((grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	      ab_biprod_inr) b) = mon_unit	";
            responses[i]=data;
          

            i = 426;
            data = "1 goal (ID 1007)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  f : F	  b : B	  q0 : (grp_pullback_pr1 (projection F) (inclusion E) $o grp_iso_inverse p.1 $o	        ab_biprod_inr) b = f	  ============================	  sg_op (inclusion Y mon_unit) mon_unit = mon_unit	";
            responses[i]=data;
          

            i = 427;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	";
            responses[i]=data;
          

            i = 428;
            data = "2 goals		goal 1 (ID 902) is:	 grp_quotient_rec F	   {|	     normalsubgroup_subgroup :=	       abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	     normalsubgroup_isnormal :=	       isnormal_ab_subgroup F	         (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	   |} (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	   (fun (f : F)	      (X : {|	             normalsubgroup_subgroup :=	               abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	             normalsubgroup_isnormal :=	               isnormal_ab_subgroup F	                 (abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p)	           |} f) =>	    (fun (b : B)	       (q0 : (grp_pullback_pr1 (projection F) (inclusion E) $o	              grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	     ap (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1) q0^ @	     (ap (grp_pullback_pr1 (projection Y) (projection E))	        (induced_map_eq E F p (Y; Q) (ab_biprod_inr b)) @	      (grp_unit_r (inclusion Y mon_unit) @ grp_homo_unit (inclusion Y)	       :	       grp_pullback_pr1 (projection Y) (projection E)	         (abses_pullback_splits_induced_map' E (Y; Q).1 (ab_biprod_inr b)) =	       mon_unit))) X.1 X.2) $o	 inclusion (abses_pullback_trivial_preimage E F p) == 	 inclusion (Y; Q).1	goal 2 (ID 904) is:	 projection (abses_pullback_trivial_preimage E F p) ==	 projection (Y; Q).1 $o	 grp_quotient_rec F	   {|	     normalsubgroup_subgroup :=	       abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	     normalsubgroup_isnormal :=	       isnormal_ab_subgroup F	         (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	   |} (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	   (fun (f : F)	      (X : {|	             normalsubgroup_subgroup :=	               abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	             normalsubgroup_isnormal :=	               isnormal_ab_subgroup F	                 (abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p)	           |} f) =>	    (fun (b : B)	       (q0 : (grp_pullback_pr1 (projection F) (inclusion E) $o	              grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	     ap (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1) q0^ @	     (ap (grp_pullback_pr1 (projection Y) (projection E))	        (induced_map_eq E F p (Y; Q) (ab_biprod_inr b)) @	      (grp_unit_r (inclusion Y mon_unit) @ grp_homo_unit (inclusion Y)	       :	       grp_pullback_pr1 (projection Y) (projection E)	         (abses_pullback_splits_induced_map' E (Y; Q).1 (ab_biprod_inr b)) =	       mon_unit))) X.1 X.2)	1 goal (ID 902)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  ============================	  grp_quotient_rec F	    {|	      normalsubgroup_subgroup :=	        abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	      normalsubgroup_isnormal :=	        isnormal_ab_subgroup F	          (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	    |} (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	    (fun (f : F)	       (X : {|	              normalsubgroup_subgroup :=	                abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	              normalsubgroup_isnormal :=	                isnormal_ab_subgroup F	                  (abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p)	            |} f) =>	     (fun (b : B)	        (q0 : (grp_pullback_pr1 (projection F) (inclusion E) $o	               grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	      ap (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1) q0^ @	      (ap (grp_pullback_pr1 (projection Y) (projection E))	         (induced_map_eq E F p (Y; Q) (ab_biprod_inr b)) @	       (grp_unit_r (inclusion Y mon_unit) @ grp_homo_unit (inclusion Y)	        :	        grp_pullback_pr1 (projection Y) (projection E)	          (abses_pullback_splits_induced_map' E (Y; Q).1 (ab_biprod_inr b)) =	        mon_unit))) X.1 X.2) $o	  inclusion (abses_pullback_trivial_preimage E F p) == 	  inclusion (Y; Q).1	1 goal (ID 1020)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  a : A	  ============================	  (grp_quotient_rec F	     {|	       normalsubgroup_subgroup :=	         abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	       normalsubgroup_isnormal :=	         isnormal_ab_subgroup F	           (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	     |} (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	     (fun (f : F)	        (X : {|	               normalsubgroup_subgroup :=	                 abses_pullback_inclusion_transpose_subgroup 	                   (inclusion E) F p;	               normalsubgroup_isnormal :=	                 isnormal_ab_subgroup F	                   (abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p)	             |} f) =>	      ap (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	        (X.2)^ @	      (ap (grp_pullback_pr1 (projection Y) (projection E))	         (induced_map_eq E F p (Y; Q) (ab_biprod_inr X.1)) @	       (grp_unit_r (inclusion Y mon_unit) @ grp_homo_unit (inclusion Y)))) $o	   inclusion (abses_pullback_trivial_preimage E F p)) a =	  inclusion (Y; Q).1 a	";
            responses[i]=data;
          

            i = 429;
            data = "1 goal (ID 1050)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  a : A	  ============================	  (grp_quotient_rec F	     {|	       normalsubgroup_subgroup :=	         abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	       normalsubgroup_isnormal :=	         isnormal_ab_subgroup F	           (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	     |} (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	     (fun (f : F)	        (X : {|	               normalsubgroup_subgroup :=	                 abses_pullback_inclusion_transpose_subgroup 	                   (inclusion E) F p;	               normalsubgroup_isnormal :=	                 isnormal_ab_subgroup F	                   (abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p)	             |} f) =>	      ap (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	        (X.2)^ @	      (ap (grp_pullback_pr1 (projection Y) (projection E))	         (induced_map_eq E F p (Y; Q) (ab_biprod_inr X.1)) @	       (grp_unit_r (inclusion Y mon_unit) @ grp_homo_unit (inclusion Y)))) $o	   inclusion (abses_pullback_trivial_preimage E F p)) a =	  grp_pullback_pr1 (projection Y) (projection E)	    ((((Q.1)^$).1 $o inclusion (F; p).1) a)	";
            responses[i]=data;
          

            i = 430;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 904) is:	 projection (abses_pullback_trivial_preimage E F p) ==	 projection (Y; Q).1 $o	 grp_quotient_rec F	   {|	     normalsubgroup_subgroup :=	       abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	     normalsubgroup_isnormal :=	       isnormal_ab_subgroup F	         (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	   |} (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	   (fun (f : F)	      (X : {|	             normalsubgroup_subgroup :=	               abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	             normalsubgroup_isnormal :=	               isnormal_ab_subgroup F	                 (abses_pullback_inclusion_transpose_subgroup 	                    (inclusion E) F p)	           |} f) =>	    (fun (b : B)	       (q0 : (grp_pullback_pr1 (projection F) (inclusion E) $o	              grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	     ap (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1) q0^ @	     (ap (grp_pullback_pr1 (projection Y) (projection E))	        (induced_map_eq E F p (Y; Q) (ab_biprod_inr b)) @	      (grp_unit_r (inclusion Y mon_unit) @ grp_homo_unit (inclusion Y)	       :	       grp_pullback_pr1 (projection Y) (projection E)	         (abses_pullback_splits_induced_map' E (Y; Q).1 (ab_biprod_inr b)) =	       mon_unit))) X.1 X.2)	";
            responses[i]=data;
          

            i = 431;
            data = "1 goal (ID 904)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  ============================	  projection (abses_pullback_trivial_preimage E F p) ==	  projection (Y; Q).1 $o	  grp_quotient_rec F	    {|	      normalsubgroup_subgroup :=	        abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	      normalsubgroup_isnormal :=	        isnormal_ab_subgroup F	          (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	    |} (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	    (fun (f : F)	       (X : {|	              normalsubgroup_subgroup :=	                abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	              normalsubgroup_isnormal :=	                isnormal_ab_subgroup F	                  (abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p)	            |} f) =>	     (fun (b : B)	        (q0 : (grp_pullback_pr1 (projection F) (inclusion E) $o	               grp_iso_inverse p.1 $o ab_biprod_inr) b = f) =>	      ap (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1) q0^ @	      (ap (grp_pullback_pr1 (projection Y) (projection E))	         (induced_map_eq E F p (Y; Q) (ab_biprod_inr b)) @	       (grp_unit_r (inclusion Y mon_unit) @ grp_homo_unit (inclusion Y)	        :	        grp_pullback_pr1 (projection Y) (projection E)	          (abses_pullback_splits_induced_map' E (Y; Q).1 (ab_biprod_inr b)) =	        mon_unit))) X.1 X.2)	";
            responses[i]=data;
          

            i = 432;
            data = "";
            responses[i]=data;
          

            i = 433;
            data = "3 focused goals (shelved: 1) (ID 1104)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  ============================	  IsConnMap ?Goal grp_quotient_map		goal 2 (ID 1105) is:	 forall	 b : QuotientGroup F	       {|	         normalsubgroup_subgroup :=	           abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	         normalsubgroup_isnormal :=	           isnormal_ab_subgroup F	             (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	       |},	 In ?Goal	   (projection (abses_pullback_trivial_preimage E F p) b =	    (projection (Y; Q).1 $o	     grp_quotient_rec F	       {|	         normalsubgroup_subgroup :=	           abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	         normalsubgroup_isnormal :=	           isnormal_ab_subgroup F	             (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	       |} (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	       (fun (f : F)	          (X : {|	                 normalsubgroup_subgroup :=	                   abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p;	                 normalsubgroup_isnormal :=	                   isnormal_ab_subgroup F	                     (abses_pullback_inclusion_transpose_subgroup	                        (inclusion E) F p)	               |} f) =>	        ap (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	          (X.2)^ @	        (ap (grp_pullback_pr1 (projection Y) (projection E))	           (induced_map_eq E F p (Y; Q) (ab_biprod_inr X.1)) @	         (grp_unit_r (inclusion Y mon_unit) @ grp_homo_unit (inclusion Y)))))	      b)	goal 3 (ID 1106) is:	 forall a : F,	 projection (abses_pullback_trivial_preimage E F p) (grp_quotient_map a) =	 (projection (Y; Q).1 $o	  grp_quotient_rec F	    {|	      normalsubgroup_subgroup :=	        abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	      normalsubgroup_isnormal :=	        isnormal_ab_subgroup F	          (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	    |} (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	    (fun (f : F)	       (X : {|	              normalsubgroup_subgroup :=	                abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	              normalsubgroup_isnormal :=	                isnormal_ab_subgroup F	                  (abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p)	            |} f) =>	     ap (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	       (X.2)^ @	     (ap (grp_pullback_pr1 (projection Y) (projection E))	        (induced_map_eq E F p (Y; Q) (ab_biprod_inr X.1)) @	      (grp_unit_r (inclusion Y mon_unit) @ grp_homo_unit (inclusion Y)))))	   (grp_quotient_map a)	";
            responses[i]=data;
          

            i = 434;
            data = "2 goals (ID 1105)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  ============================	  forall	  b : QuotientGroup F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |},	  In (Tr (-1))	    (projection (abses_pullback_trivial_preimage E F p) b =	     (projection (Y; Q).1 $o	      grp_quotient_rec F	        {|	          normalsubgroup_subgroup :=	            abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	          normalsubgroup_isnormal :=	            isnormal_ab_subgroup F	              (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	        |} (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	        (fun (f : F)	           (X : {|	                  normalsubgroup_subgroup :=	                    abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p;	                  normalsubgroup_isnormal :=	                    isnormal_ab_subgroup F	                      (abses_pullback_inclusion_transpose_subgroup	                         (inclusion E) F p)	                |} f) =>	         ap (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	           (X.2)^ @	         (ap (grp_pullback_pr1 (projection Y) (projection E))	            (induced_map_eq E F p (Y; Q) (ab_biprod_inr X.1)) @	          (grp_unit_r (inclusion Y mon_unit) @ grp_homo_unit (inclusion Y)))))	       b)		goal 2 (ID 1106) is:	 forall a : F,	 projection (abses_pullback_trivial_preimage E F p) (grp_quotient_map a) =	 (projection (Y; Q).1 $o	  grp_quotient_rec F	    {|	      normalsubgroup_subgroup :=	        abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	      normalsubgroup_isnormal :=	        isnormal_ab_subgroup F	          (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	    |} (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	    (fun (f : F)	       (X : {|	              normalsubgroup_subgroup :=	                abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	              normalsubgroup_isnormal :=	                isnormal_ab_subgroup F	                  (abses_pullback_inclusion_transpose_subgroup 	                     (inclusion E) F p)	            |} f) =>	     ap (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	       (X.2)^ @	     (ap (grp_pullback_pr1 (projection Y) (projection E))	        (induced_map_eq E F p (Y; Q) (ab_biprod_inr X.1)) @	      (grp_unit_r (inclusion Y mon_unit) @ grp_homo_unit (inclusion Y)))))	   (grp_quotient_map a)	1 goal (ID 1106)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  ============================	  forall a : F,	  projection (abses_pullback_trivial_preimage E F p) (grp_quotient_map a) =	  (projection (Y; Q).1 $o	   grp_quotient_rec F	     {|	       normalsubgroup_subgroup :=	         abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	       normalsubgroup_isnormal :=	         isnormal_ab_subgroup F	           (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	     |} (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	     (fun (f : F)	        (X : {|	               normalsubgroup_subgroup :=	                 abses_pullback_inclusion_transpose_subgroup 	                   (inclusion E) F p;	               normalsubgroup_isnormal :=	                 isnormal_ab_subgroup F	                   (abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p)	             |} f) =>	      ap (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	        (X.2)^ @	      (ap (grp_pullback_pr1 (projection Y) (projection E))	         (induced_map_eq E F p (Y; Q) (ab_biprod_inr X.1)) @	       (grp_unit_r (inclusion Y mon_unit) @ grp_homo_unit (inclusion Y)))))	    (grp_quotient_map a)	1 goal (ID 1124)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  f : F	  ============================	  projection (abses_pullback_trivial_preimage E F p) (grp_quotient_map f) =	  (projection (Y; Q).1 $o	   grp_quotient_rec F	     {|	       normalsubgroup_subgroup :=	         abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	       normalsubgroup_isnormal :=	         isnormal_ab_subgroup F	           (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	     |} (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	     (fun (f0 : F)	        (X : {|	               normalsubgroup_subgroup :=	                 abses_pullback_inclusion_transpose_subgroup 	                   (inclusion E) F p;	               normalsubgroup_isnormal :=	                 isnormal_ab_subgroup F	                   (abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p)	             |} f0) =>	      ap (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	        (X.2)^ @	      (ap (grp_pullback_pr1 (projection Y) (projection E))	         (induced_map_eq E F p (Y; Q) (ab_biprod_inr X.1)) @	       (grp_unit_r (inclusion Y mon_unit) @ grp_homo_unit (inclusion Y)))))	    (grp_quotient_map f)	";
            responses[i]=data;
          

            i = 435;
            data = "1 goal (ID 1150)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  Q : hfiber_abses_path (cxfib' E Y) (F; p)	  f : F	  ============================	  projection E ((projection (cxfib' E Y).1 $o ((Q.1)^$).1) f) =	  (projection Y $o	   grp_quotient_rec F	     {|	       normalsubgroup_subgroup :=	         abses_pullback_inclusion_transpose_subgroup (inclusion E) F p;	       normalsubgroup_isnormal :=	         isnormal_ab_subgroup F	           (abses_pullback_inclusion_transpose_subgroup (inclusion E) F p)	     |} (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	     (fun (f0 : F)	        (X : {|	               normalsubgroup_subgroup :=	                 abses_pullback_inclusion_transpose_subgroup 	                   (inclusion E) F p;	               normalsubgroup_isnormal :=	                 isnormal_ab_subgroup F	                   (abses_pullback_inclusion_transpose_subgroup 	                      (inclusion E) F p)	             |} f0) =>	      ap (grp_pullback_pr1 (projection Y) (projection E) $o ((Q.1)^$).1)	        (X.2)^ @	      (ap (grp_pullback_pr1 (projection Y) (projection E))	         (induced_map_eq E F p (Y; Q) (ab_biprod_inr X.1)) @	       (grp_unit_r (inclusion Y mon_unit) @ grp_homo_unit (inclusion Y)))))	    (grp_quotient_map f)	";
            responses[i]=data;
          

            i = 436;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 437;
            data = "";
            responses[i]=data;
          

            i = 438;
            data = "";
            responses[i]=data;
          

            i = 439;
            data = "";
            responses[i]=data;
          

            i = 440;
            data = "1 goal (ID 922)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  ============================	  path_hfiber_cxfib' (hfiber_cxfib'_inhabited E F p) Y	1 goal (ID 928)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  ============================	  (fmap (abses_pullback0 (projection E))	     (hfiber_cxfib'_induced_path'0 E F p Y))^$ $@	  ((hfiber_cxfib'_inhabited E F p).2).1 $== (Y.2).1	";
            responses[i]=data;
          

            i = 441;
            data = "1 goal (ID 961)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  ============================	  (fmap (abses_pullback0 (projection E))	     (hfiber_cxfib'_induced_path'0 E F p Y))^$ $==	  abses_component1_trivial_pullback' (abses_pullback_inclusion0_map' E F p)	    (fun x0 : A => 1%path) $o (Y.2).1	";
            responses[i]=data;
          

            i = 442;
            data = "1 goal (ID 992)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  ============================	  (fmap (abses_pullback0 (projection E))	     (hfiber_cxfib'_induced_path'0 E F p Y))^$ $o 	  ((Y.2).1)^$ $==	  abses_component1_trivial_pullback' (abses_pullback_inclusion0_map' E F p)	    (fun x0 : A => 1%path)	";
            responses[i]=data;
          

            i = 443;
            data = "1 goal (ID 1023)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  ============================	  ((Y.2).1)^$ $==	  fmap (abses_pullback0 (projection E))	    (hfiber_cxfib'_induced_path'0 E F p Y) $o	  abses_component1_trivial_pullback' (abses_pullback_inclusion0_map' E F p)	    (fun x0 : A => 1%path)	";
            responses[i]=data;
          

            i = 444;
            data = "1 goal (ID 1025)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  x : (F; p).1	  ============================	  (((Y.2).1)^$).1 x =	  (fmap (abses_pullback0 (projection E))	     (hfiber_cxfib'_induced_path'0 E F p Y) $o	   abses_component1_trivial_pullback' (abses_pullback_inclusion0_map' E F p)	     (fun x0 : A => 1%path)).1 x	";
            responses[i]=data;
          

            i = 445;
            data = "2 goals (ID 1369)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  x : (F; p).1	  ============================	  ((((Y.2).1)^$).1 x).1 =	  ((fmap (abses_pullback0 (projection E))	      (hfiber_cxfib'_induced_path'0 E F p Y) $o	    abses_component1_trivial_pullback' (abses_pullback_inclusion0_map' E F p)	      (fun x0 : A => 1%path)).1 x).1		goal 2 (ID 1370) is:	 (((((Y.2).1)^$).1 x).2).1 =	 (((fmap (abses_pullback0 (projection E))	      (hfiber_cxfib'_induced_path'0 E F p Y) $o	    abses_component1_trivial_pullback' (abses_pullback_inclusion0_map' E F p)	      (fun x0 : A => 1%path)).1 x).2).1	";
            responses[i]=data;
          

            i = 446;
            data = "1 goal (ID 1369)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : hfiber_cxfib' E F p	  x : (F; p).1	  ============================	  ((((Y.2).1)^$).1 x).1 =	  ((fmap (abses_pullback0 (projection E))	      (hfiber_cxfib'_induced_path'0 E F p Y) $o	    abses_component1_trivial_pullback' (abses_pullback_inclusion0_map' E F p)	      (fun x0 : A => 1%path)).1 x).1	";
            responses[i]=data;
          

            i = 447;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 448;
            data = "";
            responses[i]=data;
          

            i = 449;
            data = "";
            responses[i]=data;
          

            i = 450;
            data = "";
            responses[i]=data;
          

            i = 451;
            data = "";
            responses[i]=data;
          

            i = 452;
            data = "";
            responses[i]=data;
          

            i = 453;
            data = "";
            responses[i]=data;
          

            i = 454;
            data = "";
            responses[i]=data;
          

            i = 455;
            data = "";
            responses[i]=data;
          

            i = 456;
            data = "1 goal (ID 951)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  Contr (hfiber_cxfib' E F p)	";
            responses[i]=data;
          

            i = 457;
            data = "2 goals (ID 969)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  hfiber_cxfib' E F p		goal 2 (ID 971) is:	 forall y : hfiber_cxfib' E F p, ?center = y	";
            responses[i]=data;
          

            i = 458;
            data = "1 goal (ID 971)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  ============================	  forall y : hfiber_cxfib' E F p, hfiber_cxfib'_inhabited E F p = y	";
            responses[i]=data;
          

            i = 459;
            data = "1 goal (ID 980)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  q : hfiber_abses_path (cxfib' E Y) (F; p)	  ============================	  hfiber_cxfib'_inhabited E F p = (Y; q)	";
            responses[i]=data;
          

            i = 460;
            data = "1 goal (ID 989)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $== point (AbSES B A)	  Y : AbSES C A	  q : hfiber_abses_path (cxfib' E Y) (F; p)	  ============================	  path_hfiber_cxfib' (hfiber_cxfib'_inhabited E F p) (Y; q)	";
            responses[i]=data;
          

            i = 461;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 462;
            data = "";
            responses[i]=data;
          

            i = 463;
            data = "";
            responses[i]=data;
          

            i = 464;
            data = "";
            responses[i]=data;
          

            i = 465;
            data = "";
            responses[i]=data;
          

            i = 466;
            data = "";
            responses[i]=data;
          

            i = 467;
            data = "1 goal (ID 971)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  ============================	  IsExact purely (abses_pullback (projection E))	    (abses_pullback (inclusion E))	";
            responses[i]=data;
          

            i = 468;
            data = "";
            responses[i]=data;
          

            i = 469;
            data = "2 goals (ID 1041)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  ============================	  IsComplex (abses_pullback (projection E)) (abses_pullback (inclusion E))		goal 2 (ID 1043) is:	 IsConnMap purely (cxfib ?cx_isexact)	";
            responses[i]=data;
          

            i = 470;
            data = "1 goal (ID 1043)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  ============================	  IsConnMap purely (cxfib (iscomplex_pullback_abses E))	";
            responses[i]=data;
          

            i = 471;
            data = "1 goal (ID 1125)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  ============================	  forall	  x : graph_hfiber (abses_pullback0 (inclusion E)) (point (AbSES B A)),	  (fun y : hfiber (abses_pullback0 (inclusion E)) (point (AbSES B A)) =>	   IsConnected purely (hfiber (cxfib (iscomplex_pullback_abses E)) y))	    (equiv_hfiber_abses (abses_pullback0 (inclusion E)) (point (AbSES B A)) x)	";
            responses[i]=data;
          

            i = 472;
            data = "1 goal (ID 1132)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $-> point (AbSES B A)	  ============================	  IsConnected purely	    (hfiber (cxfib (iscomplex_pullback_abses E))	       (equiv_hfiber_abses (abses_pullback0 (inclusion E))	          (point (AbSES B A)) (F; p)))	";
            responses[i]=data;
          

            i = 473;
            data = "2 focused goals (shelved: 1) (ID 1171)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $-> point (AbSES B A)	  ============================	  ?Goal <~>	  purely	    (hfiber (cxfib (iscomplex_pullback_abses E))	       (equiv_hfiber_abses (abses_pullback0 (inclusion E))	          (point (AbSES B A)) (F; p)))		goal 2 (ID 1172) is:	 Contr ?Goal	";
            responses[i]=data;
          

            i = 474;
            data = "1 goal (ID 1172)	  	  H : Univalence	  A, B, C : AbGroup	  E : AbSES C B	  F : AbSES E A	  p : abses_pullback0 (inclusion E) F $-> point (AbSES B A)	  ============================	  Contr (hfiber_cxfib' E F p)	";
            responses[i]=data;
          

            i = 475;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 476;
            data = "";
            responses[i]=data;
          

            i = 477;
            data = "";
            responses[i]=data;
          

            i = 478;
            data = "";
            responses[i]=data;
          

            i = 479;
            data = "";
            responses[i]=data;
          

            i = 480;
            data = "";
            responses[i]=data;
          

            i = 481;
            data = "";
            responses[i]=data;
          

            i = 482;
            data = "";
            responses[i]=data;
          

            i = 483;
            data = "";
            responses[i]=data;
          

            i = 484;
            data = "";
            responses[i]=data;
          

            i = 485;
            data = "";
            responses[i]=data;
          

            i = 486;
            data = "";
            responses[i]=data;
          

            i = 487;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence</h1>
<div scenenumber="3" class="code">
<span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">Basics</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">Types</span></a> <a class="idref" href="HoTT.HSet.html#"><span class="id" title="library">HSet</span></a> <a class="idref" href="HoTT.HFiber.html#"><span class="id" title="library">HFiber</span></a> <a class="idref" href="HoTT.Limits.Pullback.html#"><span class="id" title="library">Limits.Pullback</span></a> <a class="idref" href="HoTT.Cubical.PathSquare.html#"><span class="id" title="library">Cubical.PathSquare</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(7, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.WildCat.html#"><span class="id" title="library">WildCat</span></a> <a class="idref" href="HoTT.Pointed.html#"><span class="id" title="library">Pointed</span></a> <a class="idref" href="HoTT.Homotopy.ExactSequence.html#"><span class="id" title="library">Homotopy.ExactSequence</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(8, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#"><span class="id" title="library">AbGroups.AbelianGroup</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#"><span class="id" title="library">AbSES.Core</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#"><span class="id" title="library">AbSES.Pullback</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(9, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Modalities.Identity.html#"><span class="id" title="library">Modalities.Identity</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(10, '0_3_3');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
<a id="lab22"></a><h1 class="section">The fiber sequence induced by pulling back along a short exact sequence</h1>
<div class="doc" scenenumber="4"> </div>

 We show that pulling back along a short exact sequence <span class="inlinecode"><a class="idref" href="HoTT.Categories.NaturalTransformation.Prod.html#induced.E"><span class="id" title="variable">E</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Factorization.html#FactSys.C"><span class="id" title="variable">C</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#PR_1382.B"><span class="id" title="constructor">B</span></a></span> produces a fiber sequence <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Factorization.html#FactSys.C"><span class="id" title="variable">C</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#PR_1382.A"><span class="id" title="inductive">A</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.NaturalTransformation.Prod.html#induced.E"><span class="id" title="variable">E</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#PR_1382.A"><span class="id" title="inductive">A</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#PR_1382.B"><span class="id" title="constructor">B</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#PR_1382.A"><span class="id" title="inductive">A</span></a></span>. The associated long exact sequence of homotopy groups recovers the usual (contravariant) six-term exact sequence of Ext groups.

<div class="doc" scenenumber="38"> </div>

We will prove the analog of exactness in terms of path data, and deduce the usual notion. 
<div class="doc" scenenumber="40"> </div>

 If a short exact sequence <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#PR_1382.A"><span class="id" title="inductive">A</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.NaturalTransformation.Prod.html#induced.E"><span class="id" title="variable">E</span></a></span> becomes trivial after pulling back along an inclusion <span class="inlinecode"><a class="idref" href="HoTT.Classes.theory.ua_second_isomorphism.html#i"><span class="id" title="abbreviation">i</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#PR_1382.B"><span class="id" title="constructor">B</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.NaturalTransformation.Prod.html#induced.E"><span class="id" title="variable">E</span></a></span>, then there is a "transpose" short exact sequence <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#PR_1382.B"><span class="id" title="constructor">B</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a>/<a class="idref" href="HoTT.Tests.html#PR_1382.B"><span class="id" title="constructor">B</span></a></span>. We begin by constructing the endpoint <span class="inlinecode"><a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a>/<a class="idref" href="HoTT.Tests.html#PR_1382.B"><span class="id" title="constructor">B</span></a></span>. 
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(87, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a id="abses_pullback_inclusion_transpose_subgroup" class="idref" href="#abses_pullback_inclusion_transpose_subgroup"><span class="id" title="definition">abses_pullback_inclusion_transpose_subgroup</span></a> `{<a id="H:1" class="idref" href="#H:1"><span class="id" title="binder">Univalence</span></a>} {<a id="A:2" class="idref" href="#A:2"><span class="id" title="binder">A</span></a> <a id="B:3" class="idref" href="#B:3"><span class="id" title="binder">B</span></a> <a id="E:4" class="idref" href="#E:4"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>}<br>
      (<a id="i:5" class="idref" href="#i:5"><span class="id" title="binder">i</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:3"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.WildCat.Core.html#c02781df22df625c7b63399d41d90de5"><span class="id" title="notation">$-&gt;</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:4"><span class="id" title="variable">E</span></a>) `{<a id="IsEmbedding0:6" class="idref" href="#IsEmbedding0:6"><span class="id" title="binder">IsEmbedding</span></a> <a id="IsEmbedding0:6" class="idref" href="#IsEmbedding0:6"><span class="id" title="binder">i</span></a>}<br>
      (<a id="F:7" class="idref" href="#F:7"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:4"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:2"><span class="id" title="variable">A</span></a>) (<a id="p:8" class="idref" href="#p:8"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#i:5"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:7"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)<br>
  : <a class="idref" href="HoTT.Algebra.Groups.Subgroup.html#NormalSubgroup"><span class="id" title="record">NormalSubgroup</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:7"><span class="id" title="variable">F</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(88, '0_3_7');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(89, '0_3_7');
      "><br>
  <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#ab_image_embedding"><span class="id" title="definition">ab_image_embedding</span></a> (<a class="idref" href="HoTT.Algebra.Groups.GrpPullback.html#grp_pullback_pr1"><span class="id" title="definition">grp_pullback_pr1</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">$</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_iso_inverse"><span class="id" title="definition">grp_iso_inverse</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">$</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#ab_biprod_inr"><span class="id" title="definition">ab_biprod_inr</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(90, '0_3_7');
      "><br>
  1,2: <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.   <span class="id" title="var">nrapply</span> (<a class="idref" href="HoTT.HFiber.html#istruncmap_compose"><span class="id" title="instance">istruncmap_compose</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_iso_inverse"><span class="id" title="definition">grp_iso_inverse</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#ab_biprod_inr"><span class="id" title="definition">ab_biprod_inr</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(91, '0_3_7');
      "><br>
  <span class="id" title="var">all</span> : <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Truncations.Core.html#istruncmap_mapinO_tr"><span class="id" title="definition">istruncmap_mapinO_tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(92, '0_3_7');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(93, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="abses_pullback_inclusion_transpose_endpoint'" class="idref" href="#abses_pullback_inclusion_transpose_endpoint'"><span class="id" title="definition">abses_pullback_inclusion_transpose_endpoint'</span></a> `{<a id="H:9" class="idref" href="#H:9"><span class="id" title="binder">Univalence</span></a>} {<a id="A:10" class="idref" href="#A:10"><span class="id" title="binder">A</span></a> <a id="B:11" class="idref" href="#B:11"><span class="id" title="binder">B</span></a> <a id="E:12" class="idref" href="#E:12"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>}<br>
           (<a id="i:13" class="idref" href="#i:13"><span class="id" title="binder">i</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:11"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.WildCat.Core.html#c02781df22df625c7b63399d41d90de5"><span class="id" title="notation">$-&gt;</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:12"><span class="id" title="variable">E</span></a>) `{<a id="IsEmbedding0:14" class="idref" href="#IsEmbedding0:14"><span class="id" title="binder">IsEmbedding</span></a> <a id="IsEmbedding0:14" class="idref" href="#IsEmbedding0:14"><span class="id" title="binder">i</span></a>}<br>
           (<a id="F:15" class="idref" href="#F:15"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:12"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:10"><span class="id" title="variable">A</span></a>) (<a id="p:16" class="idref" href="#p:16"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#i:13"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:15"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)<br>
  : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a> := <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#QuotientAbGroup"><span class="id" title="definition">QuotientAbGroup</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:15"><span class="id" title="variable">F</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#abses_pullback_inclusion_transpose_subgroup"><span class="id" title="definition">abses_pullback_inclusion_transpose_subgroup</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#i:13"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:15"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:16"><span class="id" title="variable">p</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(94, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
By <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#abses_from_inclusion"><span class="id" title="definition">abses_from_inclusion</span></a></span> we get a short exact sequence <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#PR_1382.B"><span class="id" title="constructor">B</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a>/<a class="idref" href="HoTT.Tests.html#PR_1382.B"><span class="id" title="constructor">B</span></a></span> associated to the subgroup and quotient just above. 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(110, '0_3_11');
      ">
<br>
<span class="id" title="keyword">Lemma</span> <a id="abses_pullback_inclusion_transpose_beta" class="idref" href="#abses_pullback_inclusion_transpose_beta"><span class="id" title="lemma">abses_pullback_inclusion_transpose_beta</span></a> `{<a id="H:17" class="idref" href="#H:17"><span class="id" title="binder">Univalence</span></a>} {<a id="A:18" class="idref" href="#A:18"><span class="id" title="binder">A</span></a> <a id="B:19" class="idref" href="#B:19"><span class="id" title="binder">B</span></a> <a id="E:20" class="idref" href="#E:20"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>}<br>
      (<a id="i:21" class="idref" href="#i:21"><span class="id" title="binder">i</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:19"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.WildCat.Core.html#c02781df22df625c7b63399d41d90de5"><span class="id" title="notation">$-&gt;</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:20"><span class="id" title="variable">E</span></a>) `{<a id="IsEmbedding0:22" class="idref" href="#IsEmbedding0:22"><span class="id" title="binder">IsEmbedding</span></a> <a id="IsEmbedding0:22" class="idref" href="#IsEmbedding0:22"><span class="id" title="binder">i</span></a>}<br>
      (<a id="F:23" class="idref" href="#F:23"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:20"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:18"><span class="id" title="variable">A</span></a>) (<a id="p:24" class="idref" href="#p:24"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#i:21"><span class="id" title="variable">i</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:23"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)<br>
  : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:23"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">$</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.GrpPullback.html#grp_pullback_pr1"><span class="id" title="definition">grp_pullback_pr1</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:23"><span class="id" title="variable">F</span></a>) <span class="id" title="var">_</span> <a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">$</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:24"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">$</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#ab_biprod_inr"><span class="id" title="definition">ab_biprod_inr</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#i:21"><span class="id" title="variable">i</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(111, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(112, '0_3_11');
      "><br>
  <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#conn_map_elim"><span class="id" title="definition">conn_map_elim</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#ab_biprod_pr2"><span class="id" title="definition">ab_biprod_pr2</span></a> (<span class="id" title="var">A</span>:=<span class="id" title="var">A</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(113, '0_3_11');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">ab</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(114, '0_3_11');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Limits.Pullback.html#pullback_commsq"><span class="id" title="definition">pullback_commsq</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">i</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(115, '0_3_11');
      "><br>
  <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(116, '0_3_11');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(117, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
Short exact sequences in the fiber of <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.NaturalTransformation.Prod.html#induced.E"><span class="id" title="variable">E</span></a></span> descend along <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.NaturalTransformation.Prod.html#induced.E"><span class="id" title="variable">E</span></a></span>. 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(129, '0_3_15');
      ">
<span class="id" title="keyword">Definition</span> <a id="abses_pullback_trivial_preimage" class="idref" href="#abses_pullback_trivial_preimage"><span class="id" title="definition">abses_pullback_trivial_preimage</span></a> `{<a id="H:25" class="idref" href="#H:25"><span class="id" title="binder">Univalence</span></a>} {<a id="A:26" class="idref" href="#A:26"><span class="id" title="binder">A</span></a> <a id="B:27" class="idref" href="#B:27"><span class="id" title="binder">B</span></a> <a id="C:28" class="idref" href="#C:28"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} (<a id="E:29" class="idref" href="#E:29"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:28"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:27"><span class="id" title="variable">B</span></a>)<br>
           (<a id="F:30" class="idref" href="#F:30"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#middle"><span class="id" title="projection">middle</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:29"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:26"><span class="id" title="variable">A</span></a>) (<a id="p:31" class="idref" href="#p:31"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:29"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:30"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)<br>
  : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:28"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:26"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(130, '0_3_15');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(131, '0_3_15');
      "><br>
  <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#Build_AbSES"><span class="id" title="definition">Build_AbSES</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(132, '0_3_15');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#abses_pullback_inclusion_transpose_endpoint'"><span class="id" title="definition">abses_pullback_inclusion_transpose_endpoint'</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <span class="id" title="var">E</span>) <span class="id" title="var">F</span> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(133, '0_3_15');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.QuotientGroup.html#grp_quotient_map"><span class="id" title="definition">grp_quotient_map</span></a> <a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">$</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <span class="id" title="var">F</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(134, '0_3_15');
      "><br>
  - <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Algebra.Groups.QuotientGroup.html#grp_quotient_rec"><span class="id" title="definition">grp_quotient_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(135, '0_3_15');
      "><br>
    + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <span class="id" title="var">E</span> <a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">$</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <span class="id" title="var">F</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(136, '0_3_15');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span> [<span class="id" title="var">b</span> <span class="id" title="var">q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(137, '0_3_15');
      "><br>
      <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">q</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(138, '0_3_15');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <span class="id" title="var">E</span>) (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#abses_pullback_inclusion_transpose_beta"><span class="id" title="lemma">abses_pullback_inclusion_transpose_beta</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <span class="id" title="var">E</span>) <span class="id" title="var">F</span> <span class="id" title="var">p</span> <span class="id" title="var">b</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(139, '0_3_15');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#iscomplex_abses"><span class="id" title="definition">iscomplex_abses</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(140, '0_3_15');
      "><br>
  - <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#isembedding_grouphomomorphism"><span class="id" title="lemma">isembedding_grouphomomorphism</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(141, '0_3_15');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">q0</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(142, '0_3_15');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">in_coset</span> :  <a class="idref" href="HoTT.Algebra.Groups.Subgroup.html#in_cosetL"><span class="id" title="definition">in_cosetL</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#abses_pullback_inclusion_transpose_subgroup"><span class="id" title="definition">abses_pullback_inclusion_transpose_subgroup</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <span class="id" title="var">E</span>) <span class="id" title="var">F</span> <span class="id" title="var">p</span>)<br>
                           (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <span class="id" title="var">F</span> <span class="id" title="var">a</span>) <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(143, '0_3_15');
      "><br>
    1:{ <span class="id" title="var">nrapply</span> <a class="idref" href="HoTT.Colimits.Quotient.html#related_quotient_paths"><span class="id" title="lemma">related_quotient_paths</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(144, '0_3_15');
      "><br>
        1,2,3,4: <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(145, '0_3_15');
      "><br>
        <span class="id" title="tactic">exact</span> <span class="id" title="var">q0</span>. }<br>
    <br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">in_coset</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">b</span> <span class="id" title="var">q1</span>]; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_unit_r"><span class="id" title="definition">grp_unit_r</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">q1</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(146, '0_3_15');
      "><br>
    <span class="id" title="tactic">assert</span> (<span class="id" title="var">q2</span> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#ab_biprod_inr"><span class="id" title="definition">ab_biprod_inr</span></a> <span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#ab_biprod_inl"><span class="id" title="definition">ab_biprod_inl</span></a> (<a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#::mc_scope:'-'_x"><span class="id" title="notation">-</span></a><span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(147, '0_3_15');
      "><br>
    1: { <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.HSet.html#isinj_embedding"><span class="id" title="lemma">isinj_embedding</span></a> (<a class="idref" href="HoTT.Algebra.Groups.GrpPullback.html#grp_pullback_pr1"><span class="id" title="definition">grp_pullback_pr1</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">$</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">o</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(148, '0_3_15');
      "><br>
         - <span class="id" title="var">nrapply</span> (<a class="idref" href="HoTT.HFiber.html#istruncmap_compose"><span class="id" title="instance">istruncmap_compose</span></a> (-1) <span class="id" title="var">p</span><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a> (<a class="idref" href="HoTT.Algebra.Groups.GrpPullback.html#grp_pullback_pr1"><span class="id" title="definition">grp_pullback_pr1</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <span class="id" title="var">F</span>) (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <span class="id" title="var">E</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(149, '0_3_15');
      "><br>
           <span class="id" title="var">all</span>: <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Truncations.Core.html#istruncmap_mapinO_tr"><span class="id" title="definition">istruncmap_mapinO_tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(150, '0_3_15');
      "><br>
         - <span class="id" title="var">nrefine</span> (<span class="id" title="var">q1</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>); <span class="id" title="tactic">symmetry</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(151, '0_3_15');
      "><br>
           <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Algebra.Groups.GrpPullback.html#grp_pullback_pr1"><span class="id" title="definition">grp_pullback_pr1</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a> (<a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#::mc_scope:'-'_x"><span class="id" title="notation">-</span></a><span class="id" title="var">a</span>)) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(152, '0_3_15');
      "><br>
           <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_inv"><span class="id" title="definition">grp_homo_inv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>). }</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(153, '0_3_15');
      "><br>
    <br>
    <span class="id" title="tactic">pose</span> <span class="id" title="var">proof</span> (<span class="id" title="var">q3</span> := <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#5c0e5d2620de080941397df49905323f"><span class="id" title="notation">(-)</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Types.Prod.html#equiv_path_prod"><span class="id" title="definition">equiv_path_prod</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">)^-1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">q2</span></a>))); <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">q3</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(154, '0_3_15');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Classes.theory.groups.html#negate_involutive"><span class="id" title="instance">negate_involutive</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">q3</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Classes.theory.groups.html#negate_mon_unit"><span class="id" title="lemma">negate_mon_unit</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(155, '0_3_15');
      "><br>
  - <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#cancelR_conn_map"><span class="id" title="definition">cancelR_conn_map</span></a> (<a class="idref" href="HoTT.Truncations.Core.html#Tr"><span class="id" title="definition">Tr</span></a> (-1)) <a class="idref" href="HoTT.Algebra.Groups.QuotientGroup.html#grp_quotient_map"><span class="id" title="definition">grp_quotient_map</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(156, '0_3_15');
      "><br>
    1: <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(157, '0_3_15');
      "><br>
    <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(158, '0_3_15');
      "><br>
    <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(159, '0_3_15');
      "><br>
  - <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Homotopy.ExactSequence.html#Build_IsExact"><span class="id" title="constructor">Build_IsExact</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(160, '0_3_15');
      "><br>
    + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Pointed.Core.html#Build_pHomotopy"><span class="id" title="definition">Build_pHomotopy</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(161, '0_3_15');
      "><br>
      × <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(162, '0_3_15');
      "><br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <span class="id" title="var">E</span>) <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(163, '0_3_15');
      "><br>
        1: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#iscomplex_abses"><span class="id" title="definition">iscomplex_abses</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(164, '0_3_15');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_unit"><span class="id" title="definition">grp_homo_unit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(165, '0_3_15');
      "><br>
      × <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(166, '0_3_15');
      "><br>
    + <span class="id" title="tactic">intros</span> [<span class="id" title="var">y</span> <span class="id" title="var">q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(167, '0_3_15');
      "><br>
      <span class="id" title="tactic">apply</span> (@<a class="idref" href="HoTT.Basics.Trunc.html#contr_inhabited_hprop"><span class="id" title="lemma">contr_inhabited_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(168, '0_3_15');
      "><br>
      <span class="id" title="tactic">assert</span> (<span class="id" title="var">f</span> : <a class="idref" href="HoTT.Truncations.Core.html#merely"><span class="id" title="definition">merely</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a> <a class="idref" href="HoTT.Algebra.Groups.QuotientGroup.html#grp_quotient_map"><span class="id" title="definition">grp_quotient_map</span></a> <span class="id" title="var">y</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(169, '0_3_15');
      "><br>
      1: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#center"><span class="id" title="method">center</span></a>, <a class="idref" href="HoTT.Colimits.Quotient.html#issurj_class_of"><span class="id" title="instance">issurj_class_of</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(170, '0_3_15');
      "><br>
      <span class="id" title="var">revert_opaque</span> <span class="id" title="var">f</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>; <span class="id" title="tactic">intros</span> [<span class="id" title="var">f</span> <span class="id" title="var">q0</span>].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(171, '0_3_15');
      "><br>
      <span class="id" title="tactic">assert</span> (<span class="id" title="var">b</span> : <a class="idref" href="HoTT.Truncations.Core.html#merely"><span class="id" title="definition">merely</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <span class="id" title="var">E</span>) (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <span class="id" title="var">F</span> <span class="id" title="var">f</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(172, '0_3_15');
      "><br>
      1: { <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Homotopy.ExactSequence.html#isexact_preimage"><span class="id" title="lemma">isexact_preimage</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(173, '0_3_15');
      "><br>
           <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> <span class="id" title="var">q0</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">q</span>). }</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(174, '0_3_15');
      "><br>
      <span class="id" title="var">revert_opaque</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>; <span class="id" title="tactic">intros</span> [<span class="id" title="var">b</span> <span class="id" title="var">q1</span>].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(175, '0_3_15');
      "><br>
      <span class="id" title="tactic">assert</span> (<span class="id" title="var">a</span> : <a class="idref" href="HoTT.Truncations.Core.html#merely"><span class="id" title="definition">merely</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <span class="id" title="var">F</span>)<br>
                                 (<a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#sg_op"><span class="id" title="definition">sg_op</span></a> <span class="id" title="var">f</span> (<a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#::mc_scope:'-'_x"><span class="id" title="notation">-(</span></a><a class="idref" href="HoTT.Algebra.Groups.GrpPullback.html#grp_pullback_pr1"><span class="id" title="definition">grp_pullback_pr1</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">p</span><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">ab_biprod_inr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">)</span></a>)<a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#::mc_scope:'-'_x"><span class="id" title="notation">)</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(176, '0_3_15');
      "><br>
      1: { <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Homotopy.ExactSequence.html#isexact_preimage"><span class="id" title="lemma">isexact_preimage</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(177, '0_3_15');
      "><br>
           <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_op"><span class="id" title="definition">grp_homo_op</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(178, '0_3_15');
      "><br>
           <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="x:33" class="idref" href="#x:33"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">_</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#a4d7e4771ea39b5cf663e20d42f11815"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#x:32"><span class="id" title="variable">x</span></a>) (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_inv"><span class="id" title="definition">grp_homo_inv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(179, '0_3_15');
      "><br>
           <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="x:35" class="idref" href="#x:35"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">_</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#::mc_scope:x_'-'_x"><span class="id" title="notation">-</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#x:34"><span class="id" title="variable">x</span></a>) (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#abses_pullback_inclusion_transpose_beta"><span class="id" title="lemma">abses_pullback_inclusion_transpose_beta</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <span class="id" title="var">E</span>) <span class="id" title="var">F</span> <span class="id" title="var">p</span> <span class="id" title="var">b</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">q1</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(180, '0_3_15');
      "><br>
           <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#right_inverse"><span class="id" title="definition">right_inverse</span></a>. }<br>
      <span class="id" title="var">revert_opaque</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc_rec"><span class="id" title="definition">Trunc_rec</span></a>; <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">q2</span>].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(181, '0_3_15');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(182, '0_3_15');
      "><br>
      <span class="id" title="keyword">let</span> <span class="id" title="var">T</span> := <span class="id" title="keyword">type</span> <span class="id" title="keyword">of</span> <span class="id" title="var">y</span> <span class="id" title="tactic">in</span> <span class="id" title="tactic">apply</span> (@<a class="idref" href="HoTT.Types.Sigma.html#path_sigma_hprop"><span class="id" title="definition">path_sigma_hprop</span></a> <span class="id" title="var">T</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(183, '0_3_15');
      "><br>
      1: <span class="id" title="tactic">intros</span> ?; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#istrunc_paths"><span class="id" title="instance">istrunc_paths</span></a>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#group_isgroup"><span class="id" title="projection">group_isgroup</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(184, '0_3_15');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.QuotientGroup.html#grp_quotient_map"><span class="id" title="definition">grp_quotient_map</span></a> <span class="id" title="var">q2</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">q0</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(185, '0_3_15');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_op"><span class="id" title="definition">grp_homo_op</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(186, '0_3_15');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_moveR_Mg"><span class="id" title="definition">grp_moveR_Mg</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(187, '0_3_15');
      "><br>
      <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#left_inverse"><span class="id" title="definition">left_inverse</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(188, '0_3_15');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Colimits.Quotient.html#qglue"><span class="id" title="definition">qglue</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(189, '0_3_15');
      "><br>
      <span class="id" title="tactic">∃</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(190, '0_3_15');
      "><br>
      <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_unit_r"><span class="id" title="definition">grp_unit_r</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(191, '0_3_15');
      "><br>
      <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Classes.theory.groups.html#negate_involutive"><span class="id" title="instance">negate_involutive</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(192, '0_3_15');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(193, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
That <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#abses_pullback_trivial_preimage"><span class="id" title="definition">abses_pullback_trivial_preimage</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.NaturalTransformation.Prod.html#induced.E"><span class="id" title="variable">E</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.LaxComma.CoreParts.html#LaxCommaCategoryParts.p"><span class="id" title="projection">p</span></a></span> pulls back to <span class="inlinecode"><a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a></span> is immediate from <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_component1_trivial_pullback"><span class="id" title="definition">abses_component1_trivial_pullback</span></a></span> and the following map. As such, we've shown that sequences which become trivial after pulling back along <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.NaturalTransformation.Prod.html#induced.E"><span class="id" title="variable">E</span></a></span> are in the image of pullback along <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.NaturalTransformation.Prod.html#induced.E"><span class="id" title="variable">E</span></a></span>. 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(217, '0_3_19');
      ">
<br>
<span class="id" title="keyword">Definition</span> <a id="abses_pullback_inclusion0_map'" class="idref" href="#abses_pullback_inclusion0_map'"><span class="id" title="definition">abses_pullback_inclusion0_map'</span></a> `{<a id="H:36" class="idref" href="#H:36"><span class="id" title="binder">Univalence</span></a>} {<a id="A:37" class="idref" href="#A:37"><span class="id" title="binder">A</span></a> <a id="B:38" class="idref" href="#B:38"><span class="id" title="binder">B</span></a> <a id="C:39" class="idref" href="#C:39"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} (<a id="E:40" class="idref" href="#E:40"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:39"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:38"><span class="id" title="variable">B</span></a>)<br>
           (<a id="F:41" class="idref" href="#F:41"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#middle"><span class="id" title="projection">middle</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:40"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:37"><span class="id" title="variable">A</span></a>) (<a id="p:42" class="idref" href="#p:42"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:40"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:41"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)<br>
  : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSESMorphism"><span class="id" title="record">AbSESMorphism</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:41"><span class="id" title="variable">F</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#abses_pullback_trivial_preimage"><span class="id" title="definition">abses_pullback_trivial_preimage</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:40"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:41"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:42"><span class="id" title="variable">p</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(218, '0_3_19');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(219, '0_3_19');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#Build_AbSESMorphism"><span class="id" title="constructor">Build_AbSESMorphism</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(220, '0_3_19');
      "><br>
  - <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_id"><span class="id" title="definition">grp_homo_id</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(221, '0_3_19');
      "><br>
  - <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Algebra.Groups.QuotientGroup.html#grp_quotient_map"><span class="id" title="definition">grp_quotient_map</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(222, '0_3_19');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <span class="id" title="var">E</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(223, '0_3_19');
      "><br>
  - <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(224, '0_3_19');
      "><br>
  - <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(225, '0_3_19');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(226, '0_3_19');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
For exactness we need not only a preimage of <span class="inlinecode"><a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a></span> but a preimage of <span class="inlinecode">(<a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a>,<a class="idref" href="HoTT.Categories.LaxComma.CoreParts.html#LaxCommaCategoryParts.p"><span class="id" title="projection">p</span></a>)</span> along <span class="inlinecode"><a class="idref" href="HoTT.Homotopy.ExactSequence.html#cxfib"><span class="id" title="definition">cxfib</span></a></span>. We now define and prove this in terms of path data. 
<div class="doc" scenenumber="7"> </div>

 The analog of <span class="inlinecode"><a class="idref" href="HoTT.Homotopy.ExactSequence.html#cxfib"><span class="id" title="definition">cxfib</span></a></span> induced by pullback in terms of path data. 
</div>
<div scenenumber="23" class="code">
<span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(240, '0_3_23');
      ">
<span class="id" title="keyword">Definition</span> <a id="cxfib'" class="idref" href="#cxfib'"><span class="id" title="definition">cxfib'</span></a> `{<a id="H:43" class="idref" href="#H:43"><span class="id" title="binder">Funext</span></a>} {<a id="A:44" class="idref" href="#A:44"><span class="id" title="binder">A</span></a> <a id="B:45" class="idref" href="#B:45"><span class="id" title="binder">B</span></a> <a id="C:46" class="idref" href="#C:46"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} (<a id="E:47" class="idref" href="#E:47"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:46"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:45"><span class="id" title="variable">B</span></a>)<br>
  : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:46"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:44"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.WildCat.Core.html#graph_hfiber"><span class="id" title="definition">graph_hfiber</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<span class="id" title="var">A</span>:=<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:44"><span class="id" title="variable">A</span></a>) (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:47"><span class="id" title="variable">E</span></a>)) (<a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(241, '0_3_23');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(242, '0_3_23');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">Y</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(243, '0_3_23');
      "><br>
  <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <span class="id" title="var">E</span>) <span class="id" title="var">Y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(244, '0_3_23');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback_compose'"><span class="id" title="definition">abses_pullback_compose'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">Y</span> <a class="idref" href="HoTT.WildCat.Core.html#f5c149dc2f355016086a7de7ef6fc992"><span class="id" title="notation">$@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(245, '0_3_23');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback_homotopic'"><span class="id" title="lemma">abses_pullback_homotopic'</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_const"><span class="id" title="definition">grp_homo_const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">Y</span> <a class="idref" href="HoTT.WildCat.Core.html#f5c149dc2f355016086a7de7ef6fc992"><span class="id" title="notation">$@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(246, '0_3_23');
      "><br>
  1: <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#iscomplex_abses"><span class="id" title="definition">iscomplex_abses</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(247, '0_3_23');
      "><br>
  <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback_const'"><span class="id" title="lemma">abses_pullback_const'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(248, '0_3_23');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(249, '0_3_23');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="hfiber_cxfib'" class="idref" href="#hfiber_cxfib'"><span class="id" title="definition">hfiber_cxfib'</span></a> `{<a id="H:48" class="idref" href="#H:48"><span class="id" title="binder">Funext</span></a>} {<a id="A:49" class="idref" href="#A:49"><span class="id" title="binder">A</span></a> <a id="B:50" class="idref" href="#B:50"><span class="id" title="binder">B</span></a> <a id="C:51" class="idref" href="#C:51"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} (<a id="E:52" class="idref" href="#E:52"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:51"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:50"><span class="id" title="variable">B</span></a>)<br>
           (<a id="F:53" class="idref" href="#F:53"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#middle"><span class="id" title="projection">middle</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:52"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:49"><span class="id" title="variable">A</span></a>) (<a id="p:54" class="idref" href="#p:54"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:52"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:53"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)<br>
  := <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="Y:55" class="idref" href="#Y:55"><span class="id" title="binder">Y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:51"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:49"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#hfiber_abses_path"><span class="id" title="definition">hfiber_abses_path</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#cxfib'"><span class="id" title="definition">cxfib'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:52"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#Y:55"><span class="id" title="variable">Y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:53"><span class="id" title="variable">F</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:54"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(250, '0_3_23');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="pr2_cxfib'" class="idref" href="#pr2_cxfib'"><span class="id" title="definition">pr2_cxfib'</span></a> `{<a id="H:56" class="idref" href="#H:56"><span class="id" title="binder">Univalence</span></a>} {<a id="A:57" class="idref" href="#A:57"><span class="id" title="binder">A</span></a> <a id="B:58" class="idref" href="#B:58"><span class="id" title="binder">B</span></a> <a id="C:59" class="idref" href="#C:59"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} {<a id="E:60" class="idref" href="#E:60"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:59"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:58"><span class="id" title="variable">B</span></a>} (<a id="U:61" class="idref" href="#U:61"><span class="id" title="binder">U</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:59"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:57"><span class="id" title="variable">A</span></a>)<br>
  : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#equiv_ptransformation_phomotopy"><span class="id" title="definition">equiv_ptransformation_phomotopy</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#iscomplex_abses_pullback'"><span class="id" title="definition">iscomplex_abses_pullback'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#iscomplex_abses"><span class="id" title="definition">iscomplex_abses</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:60"><span class="id" title="variable">E</span></a>)) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#U:61"><span class="id" title="variable">U</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#equiv_path_abses_iso"><span class="id" title="lemma">equiv_path_abses_iso</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#cxfib'"><span class="id" title="definition">cxfib'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:60"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#U:61"><span class="id" title="variable">U</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">).2</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(251, '0_3_23');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(252, '0_3_23');
      "><br>
  <span class="id" title="tactic">change</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#equiv_ptransformation_phomotopy"><span class="id" title="definition">equiv_ptransformation_phomotopy</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#iscomplex_abses_pullback'"><span class="id" title="definition">iscomplex_abses_pullback'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#iscomplex_abses"><span class="id" title="definition">iscomplex_abses</span></a> <span class="id" title="var">E</span>)) <span class="id" title="var">U</span>)<br>
    <span class="id" title="keyword">with</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#equiv_path_abses_iso"><span class="id" title="lemma">equiv_path_abses_iso</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#iscomplex_abses_pullback'"><span class="id" title="definition">iscomplex_abses_pullback'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#iscomplex_abses"><span class="id" title="definition">iscomplex_abses</span></a> <span class="id" title="var">E</span>)<a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">U</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(253, '0_3_23');
      "><br>
  <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#equiv_path_abses_iso"><span class="id" title="lemma">equiv_path_abses_iso</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(254, '0_3_23');
      "><br>
  <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.WildCat.Core.html#path_hom"><span class="id" title="definition">path_hom</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(255, '0_3_23');
      "><br>
  <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.WildCat.Core.html#1725408234aafc096d19d4ed837fdba5"><span class="id" title="notation">$@</span></a><a class="idref" href="HoTT.WildCat.Core.html#1725408234aafc096d19d4ed837fdba5"><span class="id" title="notation">R</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback_compose'"><span class="id" title="definition">abses_pullback_compose'</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <span class="id" title="var">E</span>) (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <span class="id" title="var">E</span>) <span class="id" title="var">U</span>);<br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.WildCat.NatTrans.html#trans_comp"><span class="id" title="definition">trans_comp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(256, '0_3_23');
      "><br>
  <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.WildCat.Core.html#1725408234aafc096d19d4ed837fdba5"><span class="id" title="notation">$@</span></a><a class="idref" href="HoTT.WildCat.Core.html#1725408234aafc096d19d4ed837fdba5"><span class="id" title="notation">R</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback_homotopic'"><span class="id" title="lemma">abses_pullback_homotopic'</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <span class="id" title="var">E</span> <a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">$</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <span class="id" title="var">E</span>) <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_const"><span class="id" title="definition">grp_homo_const</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#iscomplex_abses"><span class="id" title="definition">iscomplex_abses</span></a> <span class="id" title="var">E</span>) <span class="id" title="var">U</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(257, '0_3_23');
      "><br>
  <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(258, '0_3_23');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(259, '0_3_23');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
<div class="doc" scenenumber="25">
Making <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback'"><span class="id" title="definition">abses_pullback'</span></a></span> opaque speeds up the following proof. 
</div>
<div scenenumber="27" class="code">
<span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(265, '0_3_27');
      ">
<span class="id" title="keyword">Opaque</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback'"><span class="id" title="definition">abses_pullback'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(266, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="eq_cxfib_cxfib'" class="idref" href="#eq_cxfib_cxfib'"><span class="id" title="definition">eq_cxfib_cxfib'</span></a> `{<a id="H:62" class="idref" href="#H:62"><span class="id" title="binder">Univalence</span></a>} {<a id="A:63" class="idref" href="#A:63"><span class="id" title="binder">A</span></a> <a id="B:64" class="idref" href="#B:64"><span class="id" title="binder">B</span></a> <a id="C:65" class="idref" href="#C:65"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} {<a id="E:66" class="idref" href="#E:66"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:65"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:64"><span class="id" title="variable">B</span></a>} (<a id="U:67" class="idref" href="#U:67"><span class="id" title="binder">U</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:65"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:63"><span class="id" title="variable">A</span></a>)<br>
  : <a class="idref" href="HoTT.Homotopy.ExactSequence.html#cxfib"><span class="id" title="definition">cxfib</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#iscomplex_pullback_abses"><span class="id" title="definition">iscomplex_pullback_abses</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:66"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#U:67"><span class="id" title="variable">U</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#equiv_hfiber_abses"><span class="id" title="definition">equiv_hfiber_abses</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#cxfib'"><span class="id" title="definition">cxfib'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:66"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#U:67"><span class="id" title="variable">U</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(267, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(268, '0_3_27');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma"><span class="id" title="definition">path_sigma</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(269, '0_3_27');
      "><br>
  1: <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(270, '0_3_27');
      "><br>
  <span class="id" title="var">nrefine</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(271, '0_3_27');
      "><br>
  <span class="id" title="var">nrefine</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(272, '0_3_27');
      "><br>
  <span class="id" title="var">cbn</span> <span class="id" title="keyword">zeta</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(273, '0_3_27');
      "><br>
  <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#equiv_hfiber_abses"><span class="id" title="definition">equiv_hfiber_abses</span></a>, <a class="idref" href="HoTT.Types.Sigma.html#equiv_functor_sigma_id"><span class="id" title="definition">equiv_functor_sigma_id</span></a>, <a class="idref" href="HoTT.Types.Sigma.html#equiv_functor_sigma'"><span class="id" title="definition">equiv_functor_sigma'</span></a>, <a class="idref" href="HoTT.Types.Sigma.html#equiv_functor_sigma"><span class="id" title="definition">equiv_functor_sigma</span></a>, <a class="idref" href="HoTT.Basics.Overture.html#equiv_fun"><span class="id" title="projection">equiv_fun</span></a>, <a class="idref" href="HoTT.Types.Sigma.html#functor_sigma"><span class="id" title="definition">functor_sigma</span></a>, ".2".</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(274, '0_3_27');
      "><br>
  <span class="id" title="tactic">exact</span> (@<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#pr2_cxfib'"><span class="id" title="definition">pr2_cxfib'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">E</span> <span class="id" title="var">U</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(275, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(276, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Transparent</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback'"><span class="id" title="definition">abses_pullback'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(277, '0_3_27');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_hfiber_cxfib'" class="idref" href="#equiv_hfiber_cxfib'"><span class="id" title="definition">equiv_hfiber_cxfib'</span></a> `{<a id="H:68" class="idref" href="#H:68"><span class="id" title="binder">Univalence</span></a>} {<a id="A:69" class="idref" href="#A:69"><span class="id" title="binder">A</span></a> <a id="B:70" class="idref" href="#B:70"><span class="id" title="binder">B</span></a> <a id="C:71" class="idref" href="#C:71"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} {<a id="E:72" class="idref" href="#E:72"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:71"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:70"><span class="id" title="variable">B</span></a>}<br>
           (<a id="F:73" class="idref" href="#F:73"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#middle"><span class="id" title="projection">middle</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:72"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:69"><span class="id" title="variable">A</span></a>) (<a id="p:74" class="idref" href="#p:74"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:72"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:73"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)<br>
  : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'"><span class="id" title="definition">hfiber_cxfib'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:72"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:73"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:74"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#hfiber"><span class="id" title="definition">hfiber</span></a> (<a class="idref" href="HoTT.Homotopy.ExactSequence.html#cxfib"><span class="id" title="definition">cxfib</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#iscomplex_pullback_abses"><span class="id" title="definition">iscomplex_pullback_abses</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:72"><span class="id" title="variable">E</span></a>))<br>
                  (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#equiv_hfiber_abses"><span class="id" title="definition">equiv_hfiber_abses</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:73"><span class="id" title="variable">F</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:74"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(278, '0_3_27');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(279, '0_3_27');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Types.Sigma.html#equiv_functor_sigma_id"><span class="id" title="definition">equiv_functor_sigma_id</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">U</span>; <span class="id" title="tactic">lazy</span> <span class="id" title="keyword">beta</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(280, '0_3_27');
      "><br>
  <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#::equiv_scope:x_'oE'_x"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#equiv_hfiber_abses_pullback"><span class="id" title="definition">equiv_hfiber_abses_pullback</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(281, '0_3_27');
      "><br>
  <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#::equiv_scope:x_'oE'_x"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ap'"><span class="id" title="definition">equiv_ap'</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#equiv_hfiber_abses"><span class="id" title="definition">equiv_hfiber_abses</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(282, '0_3_27');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Paths.html#equiv_concat_l"><span class="id" title="definition">equiv_concat_l</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(283, '0_3_27');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#eq_cxfib_cxfib'"><span class="id" title="definition">eq_cxfib_cxfib'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(284, '0_3_27');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(285, '0_3_27');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_27"><pre><span></span></pre></div>
<div class="doc" scenenumber="29">
The type of paths in <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'"><span class="id" title="definition">hfiber_cxfib'</span></a></span> in terms of path data. 
</div>
<div scenenumber="31" class="code">
<span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(291, '0_3_31');
      ">
<span class="id" title="keyword">Definition</span> <a id="path_hfiber_cxfib'" class="idref" href="#path_hfiber_cxfib'"><span class="id" title="definition">path_hfiber_cxfib'</span></a> `{<a id="H:75" class="idref" href="#H:75"><span class="id" title="binder">Funext</span></a>} {<a id="A:76" class="idref" href="#A:76"><span class="id" title="binder">A</span></a> <a id="B:77" class="idref" href="#B:77"><span class="id" title="binder">B</span></a> <a id="C:78" class="idref" href="#C:78"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} {<a id="E:79" class="idref" href="#E:79"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:78"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:77"><span class="id" title="variable">B</span></a>}<br>
           {<a id="F:80" class="idref" href="#F:80"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#middle"><span class="id" title="projection">middle</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:79"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:76"><span class="id" title="variable">A</span></a>} {<a id="p:81" class="idref" href="#p:81"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:79"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:80"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>}<br>
           (<a id="X:82" class="idref" href="#X:82"><span class="id" title="binder">X</span></a> <a id="Y:83" class="idref" href="#Y:83"><span class="id" title="binder">Y</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'"><span class="id" title="definition">hfiber_cxfib'</span></a> (<span class="id" title="var">B</span>:=<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:77"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:79"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:80"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:81"><span class="id" title="variable">p</span></a>)<br>
  : <span class="id" title="keyword">Type</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(292, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(293, '0_3_31');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> (<span class="id" title="keyword">fun</span> <a id="q0:85" class="idref" href="#q0:85"><span class="id" title="binder">q0</span></a> : <span class="id" title="var">X</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <span class="id" title="var">Y</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a> ⇒ <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(294, '0_3_31');
      "><br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.WildCat.Core.html#fmap"><span class="id" title="method">fmap</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <span class="id" title="var">E</span>)) <span class="id" title="var">q0</span><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">)^$</span></a> <a class="idref" href="HoTT.WildCat.Core.html#f5c149dc2f355016086a7de7ef6fc992"><span class="id" title="notation">$@</span></a> <span class="id" title="var">X</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <span class="id" title="var">Y</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(295, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(296, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="transport_hfiber_abses_path_cxfib'_l" class="idref" href="#transport_hfiber_abses_path_cxfib'_l"><span class="id" title="definition">transport_hfiber_abses_path_cxfib'_l</span></a> `{<a id="H:86" class="idref" href="#H:86"><span class="id" title="binder">Univalence</span></a>} {<a id="A:87" class="idref" href="#A:87"><span class="id" title="binder">A</span></a> <a id="B:88" class="idref" href="#B:88"><span class="id" title="binder">B</span></a> <a id="C:89" class="idref" href="#C:89"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} {<a id="E:90" class="idref" href="#E:90"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:89"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:88"><span class="id" title="variable">B</span></a>}<br>
           (<a id="F:91" class="idref" href="#F:91"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#middle"><span class="id" title="projection">middle</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:90"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:87"><span class="id" title="variable">A</span></a>) (<a id="p:92" class="idref" href="#p:92"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:90"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:91"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)<br>
           (<a id="U:93" class="idref" href="#U:93"><span class="id" title="binder">U</span></a> <a id="V:94" class="idref" href="#V:94"><span class="id" title="binder">V</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'"><span class="id" title="definition">hfiber_cxfib'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:90"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:91"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:92"><span class="id" title="variable">p</span></a>) (<a id="q:95" class="idref" href="#q:95"><span class="id" title="binder">q</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#U:93"><span class="id" title="variable">U</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#V:94"><span class="id" title="variable">V</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a>)<br>
  : <a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="Y:96" class="idref" href="#Y:96"><span class="id" title="binder">Y</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:89"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:87"><span class="id" title="variable">A</span></a> ⇒ <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#hfiber_abses_path"><span class="id" title="definition">hfiber_abses_path</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#cxfib'"><span class="id" title="definition">cxfib'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:90"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#Y:96"><span class="id" title="variable">Y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:91"><span class="id" title="variable">F</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:92"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#q:95"><span class="id" title="variable">q</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#U:93"><span class="id" title="variable">U</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">).1</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.WildCat.Core.html#fmap"><span class="id" title="method">fmap</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:90"><span class="id" title="variable">E</span></a>)) (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#equiv_path_abses_iso"><span class="id" title="lemma">equiv_path_abses_iso</span></a><a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">^-1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">q</span></a><a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">^</span></a>) <a class="idref" href="HoTT.WildCat.Core.html#f5c149dc2f355016086a7de7ef6fc992"><span class="id" title="notation">$@</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#U:93"><span class="id" title="variable">U</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(297, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(298, '0_3_31');
      "><br>
  <span class="id" title="tactic">induction</span> <span class="id" title="var">q</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(299, '0_3_31');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_1"><span class="id" title="definition">transport_1</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(300, '0_3_31');
      "><br>
  <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="x:98" class="idref" href="#x:98"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.WildCat.Core.html#fmap"><span class="id" title="method">fmap</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <span class="id" title="var">E</span>)) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#x:97"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.WildCat.Core.html#f5c149dc2f355016086a7de7ef6fc992"><span class="id" title="notation">$@</span></a> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#equiv_path_absesV_1"><span class="id" title="definition">equiv_path_absesV_1</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(301, '0_3_31');
      "><br>
  <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="x:100" class="idref" href="#x:100"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#x:99"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.WildCat.Core.html#f5c149dc2f355016086a7de7ef6fc992"><span class="id" title="notation">$@</span></a> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.WildCat.Core.html#fmap_id_strong"><span class="id" title="definition">fmap_id_strong</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(302, '0_3_31');
      "><br>
  <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.WildCat.Core.html#cat_idr_strong"><span class="id" title="method">cat_idr_strong</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(303, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(304, '0_3_31');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_path_hfiber_cxfib'" class="idref" href="#equiv_path_hfiber_cxfib'"><span class="id" title="definition">equiv_path_hfiber_cxfib'</span></a> `{<a id="H:101" class="idref" href="#H:101"><span class="id" title="binder">Univalence</span></a>} {<a id="A:102" class="idref" href="#A:102"><span class="id" title="binder">A</span></a> <a id="B:103" class="idref" href="#B:103"><span class="id" title="binder">B</span></a> <a id="C:104" class="idref" href="#C:104"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} {<a id="E:105" class="idref" href="#E:105"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:104"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:103"><span class="id" title="variable">B</span></a>}<br>
           (<a id="F:106" class="idref" href="#F:106"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#middle"><span class="id" title="projection">middle</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:105"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:102"><span class="id" title="variable">A</span></a>) (<a id="p:107" class="idref" href="#p:107"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:105"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:106"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)<br>
           (<a id="U:108" class="idref" href="#U:108"><span class="id" title="binder">U</span></a> <a id="V:109" class="idref" href="#V:109"><span class="id" title="binder">V</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'"><span class="id" title="definition">hfiber_cxfib'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:105"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:106"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:107"><span class="id" title="variable">p</span></a>)<br>
  : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#path_hfiber_cxfib'"><span class="id" title="definition">path_hfiber_cxfib'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#U:108"><span class="id" title="variable">U</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#V:109"><span class="id" title="variable">V</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#U:108"><span class="id" title="variable">U</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#V:109"><span class="id" title="variable">V</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(305, '0_3_31');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(306, '0_3_31');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_path_sigma"><span class="id" title="definition">equiv_path_sigma</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#::equiv_scope:x_'oE'_x"><span class="id" title="notation">oE</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(307, '0_3_31');
      "><br>
  <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_functor_sigma'"><span class="id" title="definition">equiv_functor_sigma'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#equiv_path_abses_iso"><span class="id" title="lemma">equiv_path_abses_iso</span></a>);<br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">q</span>; <span class="id" title="tactic">lazy</span> <span class="id" title="keyword">beta</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(308, '0_3_31');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_path_sigma_hprop"><span class="id" title="definition">equiv_path_sigma_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#::equiv_scope:x_'oE'_x"><span class="id" title="notation">oE</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(309, '0_3_31');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Paths.html#equiv_concat_l"><span class="id" title="definition">equiv_concat_l</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#::equiv_scope:x_'oE'_x"><span class="id" title="notation">oE</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(310, '0_3_31');
      "><br>
  1: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#transport_hfiber_abses_path_cxfib'_l"><span class="id" title="definition">transport_hfiber_abses_path_cxfib'_l</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(311, '0_3_31');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_path_sigma_hprop"><span class="id" title="definition">equiv_path_sigma_hprop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#::equiv_scope:x_'oE'_x"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Types.Paths.html#equiv_concat_l"><span class="id" title="definition">equiv_concat_l</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#::equiv_scope:x_'oE'_x"><span class="id" title="notation">oE</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(312, '0_3_31');
      "><br>
  1: { <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="x:111" class="idref" href="#x:111"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.WildCat.Core.html#fmap"><span class="id" title="method">fmap</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#x:110"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.WildCat.Core.html#f5c149dc2f355016086a7de7ef6fc992"><span class="id" title="notation">$@</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">).1</span></a>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(313, '0_3_31');
      "><br>
       <span class="id" title="var">nrefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#abses_path_data_V"><span class="id" title="definition">abses_path_data_V</span></a> <span class="id" title="var">q</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(314, '0_3_31');
      "><br>
       <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#eissect"><span class="id" title="method">eissect</span></a>. }<br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Paths.html#equiv_concat_l"><span class="id" title="definition">equiv_concat_l</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#::equiv_scope:x_'oE'_x"><span class="id" title="notation">oE</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(315, '0_3_31');
      "><br>
  1: { <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="x:113" class="idref" href="#x:113"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#x:112"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.WildCat.Core.html#f5c149dc2f355016086a7de7ef6fc992"><span class="id" title="notation">$@</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">).1</span></a>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(316, '0_3_31');
      "><br>
       <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.WildCat.Core.html#gpd_strong_1functor_V"><span class="id" title="definition">gpd_strong_1functor_V</span></a>. }<br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#equiv_path_groupisomorphism"><span class="id" title="definition">equiv_path_groupisomorphism</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(317, '0_3_31');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(318, '0_3_31');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_31"><pre><span></span></pre></div>
<div class="doc" scenenumber="33">
The fibre of <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#cxfib'"><span class="id" title="definition">cxfib'</span></a></span> over <span class="inlinecode">(<a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a>;<a class="idref" href="HoTT.Categories.LaxComma.CoreParts.html#LaxCommaCategoryParts.p"><span class="id" title="projection">p</span></a>)</span> is inhabited. 
</div>
<div scenenumber="35" class="code">
<span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(326, '0_3_35');
      ">
<span class="id" title="keyword">Definition</span> <a id="hfiber_cxfib'_inhabited" class="idref" href="#hfiber_cxfib'_inhabited"><span class="id" title="definition">hfiber_cxfib'_inhabited</span></a> `{<a id="H:114" class="idref" href="#H:114"><span class="id" title="binder">Univalence</span></a>} {<a id="A:115" class="idref" href="#A:115"><span class="id" title="binder">A</span></a> <a id="B:116" class="idref" href="#B:116"><span class="id" title="binder">B</span></a> <a id="C:117" class="idref" href="#C:117"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} (<a id="E:118" class="idref" href="#E:118"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:117"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:116"><span class="id" title="variable">B</span></a>)<br>
      (<a id="F:119" class="idref" href="#F:119"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#middle"><span class="id" title="projection">middle</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:118"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:115"><span class="id" title="variable">A</span></a>) (<a id="p:120" class="idref" href="#p:120"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback"><span class="id" title="definition">abses_pullback</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:118"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:119"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)<br>
  : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'"><span class="id" title="definition">hfiber_cxfib'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:118"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:119"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:120"><span class="id" title="variable">p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(327, '0_3_35');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(328, '0_3_35');
      "><br>
  <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#abses_pullback_trivial_preimage"><span class="id" title="definition">abses_pullback_trivial_preimage</span></a> <span class="id" title="var">E</span> <span class="id" title="var">F</span> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(329, '0_3_35');
      "><br>
  <span class="id" title="var">srefine</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">_</span><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(330, '0_3_35');
      "><br>
  1: <span class="id" title="tactic">by</span> <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_component1_trivial_pullback'"><span class="id" title="definition">abses_component1_trivial_pullback'</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#abses_pullback_inclusion0_map'"><span class="id" title="definition">abses_pullback_inclusion0_map'</span></a> <span class="id" title="var">E</span> <span class="id" title="var">F</span> <span class="id" title="var">p</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(331, '0_3_35');
      "><br>
  <span class="id" title="tactic">lazy</span> <span class="id" title="keyword">beta</span>; <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#proj2"><span class="id" title="projection">pr2</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(332, '0_3_35');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.WildCat.Core.html#cat_assoc"><span class="id" title="method">cat_assoc</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.WildCat.Core.html#f5c149dc2f355016086a7de7ef6fc992"><span class="id" title="notation">$@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(333, '0_3_35');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.WildCat.Core.html#cat_assoc"><span class="id" title="method">cat_assoc</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.WildCat.Core.html#f5c149dc2f355016086a7de7ef6fc992"><span class="id" title="notation">$@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(334, '0_3_35');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.WildCat.Core.html#gpd_moveR_Vh"><span class="id" title="definition">gpd_moveR_Vh</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(335, '0_3_35');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.WildCat.Core.html#gpd_moveL_hM"><span class="id" title="definition">gpd_moveL_hM</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(336, '0_3_35');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#equiv_path_biprod_corec"><span class="id" title="lemma">equiv_path_biprod_corec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(337, '0_3_35');
      "><br>
  <span class="id" title="tactic">split</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Limits.Pullback.html#equiv_path_pullback_rec_hset"><span class="id" title="lemma">equiv_path_pullback_rec_hset</span></a>; <span class="id" title="tactic">split</span>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(338, '0_3_35');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(339, '0_3_35');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Quotient.html#class_of"><span class="id" title="definition">class_of</span></a> <span class="id" title="var">_</span>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(340, '0_3_35');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Limits.Pullback.html#pullback_pr1"><span class="id" title="definition">pullback_pr1</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(341, '0_3_35');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(342, '0_3_35');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(343, '0_3_35');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Colimits.Quotient.html#qglue"><span class="id" title="definition">qglue</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(344, '0_3_35');
      "><br>
    <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#::mc_scope:'-'_x"><span class="id" title="notation">-</span></a><span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(345, '0_3_35');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_moveL_Vg"><span class="id" title="definition">grp_moveL_Vg</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(346, '0_3_35');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_op"><span class="id" title="definition">grp_homo_op</span></a> (<a class="idref" href="HoTT.Algebra.Groups.GrpPullback.html#grp_pullback_pr1"><span class="id" title="definition">grp_pullback_pr1</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">$</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">o</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a> <a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">$</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#ab_biprod_inr"><span class="id" title="definition">ab_biprod_inr</span></a>) <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(347, '0_3_35');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#right_inverse"><span class="id" title="definition">right_inverse</span></a> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_unit"><span class="id" title="definition">grp_homo_unit</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_unit"><span class="id" title="definition">grp_homo_unit</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(348, '0_3_35');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(349, '0_3_35');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(350, '0_3_35');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(351, '0_3_35');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_35"><pre><span></span></pre></div>
<div class="doc" scenenumber="37">
To conclude exactness in terms of path data, we show that the fibre is a proposition, hence contractible. 
<div class="doc" scenenumber="1"> </div>

 Given a point <span class="inlinecode">(<a class="idref" href="HoTT.HIT.iso.html#iso.Y"><span class="id" title="variable">Y</span></a>;<a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a>)</span> in the fiber of <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#cxfib'"><span class="id" title="definition">cxfib'</span></a></span> over <span class="inlinecode">(<a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a>;<a class="idref" href="HoTT.Categories.LaxComma.CoreParts.html#LaxCommaCategoryParts.p"><span class="id" title="projection">p</span></a>)</span> there is an induced map as follows. 
</div>
<div scenenumber="39" class="code">
<span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(363, '0_3_39');
      ">
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="hfiber_cxfib'_induced_map" class="idref" href="#hfiber_cxfib'_induced_map"><span class="id" title="definition">hfiber_cxfib'_induced_map</span></a> `{<a id="H:121" class="idref" href="#H:121"><span class="id" title="binder">Funext</span></a>} {<a id="A:122" class="idref" href="#A:122"><span class="id" title="binder">A</span></a> <a id="B:123" class="idref" href="#B:123"><span class="id" title="binder">B</span></a> <a id="C:124" class="idref" href="#C:124"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} (<a id="E:125" class="idref" href="#E:125"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:124"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:123"><span class="id" title="variable">B</span></a>)<br>
      (<a id="F:126" class="idref" href="#F:126"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#middle"><span class="id" title="projection">middle</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:125"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:122"><span class="id" title="variable">A</span></a>) (<a id="p:127" class="idref" href="#p:127"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:125"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:126"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)<br>
      (<a id="Y:128" class="idref" href="#Y:128"><span class="id" title="binder">Y</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'"><span class="id" title="definition">hfiber_cxfib'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:125"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:126"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:127"><span class="id" title="variable">p</span></a>)<br>
  : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#ab_biprod"><span class="id" title="definition">ab_biprod</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:122"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:123"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.WildCat.Core.html#c02781df22df625c7b63399d41d90de5"><span class="id" title="notation">$-&gt;</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:125"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#Y:128"><span class="id" title="variable">Y</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(364, '0_3_39');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(365, '0_3_39');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">Y</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Y</span> <span class="id" title="var">q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(366, '0_3_39');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_compose"><span class="id" title="definition">grp_homo_compose</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_iso_inverse"><span class="id" title="definition">grp_iso_inverse</span></a> <span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(367, '0_3_39');
      "><br>
  <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">$</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.Groups.GrpPullback.html#grp_pullback_pr1"><span class="id" title="definition">grp_pullback_pr1</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(368, '0_3_39');
      "><br>
  <span class="id" title="tactic">exact</span> (<span class="id" title="var">q</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(369, '0_3_39');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(370, '0_3_39');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_39"><pre><span></span></pre></div>
<div class="doc" scenenumber="41">
There is "another" obvious induced map. 
</div>
<div scenenumber="43" class="code">
<span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(374, '0_3_43');
      ">
<span class="id" title="keyword">Definition</span> <a id="abses_pullback_splits_induced_map'" class="idref" href="#abses_pullback_splits_induced_map'"><span class="id" title="definition">abses_pullback_splits_induced_map'</span></a> {<a id="A:129" class="idref" href="#A:129"><span class="id" title="binder">A</span></a> <a id="B:130" class="idref" href="#B:130"><span class="id" title="binder">B</span></a> <a id="C:131" class="idref" href="#C:131"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>}<br>
           (<a id="E:132" class="idref" href="#E:132"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:131"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:130"><span class="id" title="variable">B</span></a>) (<a id="Y:133" class="idref" href="#Y:133"><span class="id" title="binder">Y</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:131"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:129"><span class="id" title="variable">A</span></a>)<br>
  : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#ab_biprod"><span class="id" title="definition">ab_biprod</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:129"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:130"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.WildCat.Core.html#c02781df22df625c7b63399d41d90de5"><span class="id" title="notation">$-&gt;</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:132"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#Y:133"><span class="id" title="variable">Y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(375, '0_3_43');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(376, '0_3_43');
      "><br>
  <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#ab_biprod_rec"><span class="id" title="lemma">ab_biprod_rec</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(377, '0_3_43');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Algebra.Groups.GrpPullback.html#grp_pullback_corec"><span class="id" title="lemma">grp_pullback_corec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(378, '0_3_43');
      "><br>
  - <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_const"><span class="id" title="definition">grp_homo_const</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(379, '0_3_43');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <span class="id" title="var">E</span>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(380, '0_3_43');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(381, '0_3_43');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_unit"><span class="id" title="definition">grp_homo_unit</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(382, '0_3_43');
      "><br>
    <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#iscomplex_abses"><span class="id" title="definition">iscomplex_abses</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(383, '0_3_43');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(384, '0_3_43');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="fmap_hfiber_abses_lemma" class="idref" href="#fmap_hfiber_abses_lemma"><span class="id" title="lemma">fmap_hfiber_abses_lemma</span></a> `{<a id="H:134" class="idref" href="#H:134"><span class="id" title="binder">Univalence</span></a>} {<a id="A:135" class="idref" href="#A:135"><span class="id" title="binder">A</span></a> <a id="B:136" class="idref" href="#B:136"><span class="id" title="binder">B</span></a> <a id="B':137" class="idref" href="#B':137"><span class="id" title="binder">B'</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} (<a id="f:138" class="idref" href="#f:138"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B':137"><span class="id" title="variable">B'</span></a> <a class="idref" href="HoTT.WildCat.Core.html#c02781df22df625c7b63399d41d90de5"><span class="id" title="notation">$-&gt;</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:136"><span class="id" title="variable">B</span></a>)<br>
           (<a id="X:139" class="idref" href="#X:139"><span class="id" title="binder">X</span></a> <a id="Y:140" class="idref" href="#Y:140"><span class="id" title="binder">Y</span></a> : <a class="idref" href="HoTT.WildCat.Core.html#graph_hfiber"><span class="id" title="definition">graph_hfiber</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<span class="id" title="var">A</span>:=<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:135"><span class="id" title="variable">A</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#f:138"><span class="id" title="variable">f</span></a>) (<a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)) (<a id="Q:141" class="idref" href="#Q:141"><span class="id" title="binder">Q</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#hfiber_abses_path"><span class="id" title="definition">hfiber_abses_path</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#X:139"><span class="id" title="variable">X</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#Y:140"><span class="id" title="variable">Y</span></a>)<br>
  : <a class="idref" href="HoTT.WildCat.Core.html#fmap"><span class="id" title="method">fmap</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#f:138"><span class="id" title="variable">f</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#Q:141"><span class="id" title="variable">Q</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a> <a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">$</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#Y:140"><span class="id" title="variable">Y</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#X:139"><span class="id" title="variable">X</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(385, '0_3_43');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(386, '0_3_43');
      "><br>
  <span class="id" title="tactic">generalize</span> <span class="id" title="var">Q</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(387, '0_3_43');
      "><br>
  <span class="id" title="var">equiv_intro</span> <a class="idref" href="HoTT.Basics.Equivalences.html#76214fa316f18d720833e810bbfd71fb"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#equiv_hfiber_abses_pullback"><span class="id" title="definition">equiv_hfiber_abses_pullback</span></a> <span class="id" title="var">_</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span><a class="idref" href="HoTT.Basics.Equivalences.html#76214fa316f18d720833e810bbfd71fb"><span class="id" title="notation">)^-1</span></a>%<span class="id" title="var">equiv</span> <span class="id" title="var">p</span>;<br>
    <span class="id" title="tactic">induction</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(388, '0_3_43');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.WildCat.Core.html#f5c149dc2f355016086a7de7ef6fc992"><span class="id" title="notation">(</span></a><span class="id" title="var">_</span> <a class="idref" href="HoTT.WildCat.Core.html#1725408234aafc096d19d4ed837fdba5"><span class="id" title="notation">$@</span></a><a class="idref" href="HoTT.WildCat.Core.html#1725408234aafc096d19d4ed837fdba5"><span class="id" title="notation">R</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.WildCat.Core.html#f5c149dc2f355016086a7de7ef6fc992"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.WildCat.Core.html#f5c149dc2f355016086a7de7ef6fc992"><span class="id" title="notation">$@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(389, '0_3_43');
      "><br>
  { <span class="id" title="var">Unshelve</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(390, '0_3_43');
      "><br>
    2: <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.WildCat.Core.html#Id"><span class="id" title="method">Id</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(391, '0_3_43');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.WildCat.Core.html#fmap2"><span class="id" title="method">fmap2</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.WildCat.Core.html#f5c149dc2f355016086a7de7ef6fc992"><span class="id" title="notation">$@</span></a> <a class="idref" href="HoTT.WildCat.Core.html#fmap_id"><span class="id" title="method">fmap_id</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(392, '0_3_43');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">reflexivity</span>. }<br>
  <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.WildCat.Core.html#cat_idl"><span class="id" title="method">cat_idl</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(393, '0_3_43');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(394, '0_3_43');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="induced_map_eq" class="idref" href="#induced_map_eq"><span class="id" title="lemma">induced_map_eq</span></a> `{<a id="H:142" class="idref" href="#H:142"><span class="id" title="binder">Univalence</span></a>} {<a id="A:143" class="idref" href="#A:143"><span class="id" title="binder">A</span></a> <a id="B:144" class="idref" href="#B:144"><span class="id" title="binder">B</span></a> <a id="C:145" class="idref" href="#C:145"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} (<a id="E:146" class="idref" href="#E:146"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:145"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:144"><span class="id" title="variable">B</span></a>)<br>
      (<a id="F:147" class="idref" href="#F:147"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#middle"><span class="id" title="projection">middle</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:146"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:143"><span class="id" title="variable">A</span></a>) (<a id="p:148" class="idref" href="#p:148"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:146"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:147"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)<br>
      (<a id="Y:149" class="idref" href="#Y:149"><span class="id" title="binder">Y</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'"><span class="id" title="definition">hfiber_cxfib'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:146"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:147"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:148"><span class="id" title="variable">p</span></a>)<br>
  : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'_induced_map"><span class="id" title="definition">hfiber_cxfib'_induced_map</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:146"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:147"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:148"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#Y:149"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#abses_pullback_splits_induced_map'"><span class="id" title="definition">abses_pullback_splits_induced_map'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:146"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#Y:149"><span class="id" title="variable">Y</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(395, '0_3_43');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(396, '0_3_43');
      "><br>
  <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(397, '0_3_43');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Limits.Pullback.html#pullback_pr1"><span class="id" title="definition">pullback_pr1</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#fmap_hfiber_abses_lemma"><span class="id" title="lemma">fmap_hfiber_abses_lemma</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">F</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">p</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a> <span class="id" title="var">Y</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(398, '0_3_43');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Limits.Pullback.html#equiv_path_pullback_hset"><span class="id" title="definition">equiv_path_pullback_hset</span></a>; <span class="id" title="tactic">split</span>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(399, '0_3_43');
      "><br>
  - <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_unit_r"><span class="id" title="definition">grp_unit_r</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(400, '0_3_43');
      "><br>
  - <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_unit_l"><span class="id" title="definition">grp_unit_l</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(401, '0_3_43');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(402, '0_3_43');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_43"><pre><span></span></pre></div>
<div class="doc" scenenumber="45">
Given another point <span class="inlinecode">(<a class="idref" href="HoTT.HIT.iso.html#iso.Y"><span class="id" title="variable">Y</span></a>,<a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a>)</span> in the fibre of <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#cxfib'"><span class="id" title="definition">cxfib'</span></a></span> over <span class="inlinecode">(<a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a>;<a class="idref" href="HoTT.Categories.LaxComma.CoreParts.html#LaxCommaCategoryParts.p"><span class="id" title="projection">p</span></a>)</span>, we get path data in <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Factorization.html#FactSys.C"><span class="id" title="variable">C</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Tests.html#PR_1382.A"><span class="id" title="inductive">A</span></a></span>. 
</div>
<div scenenumber="47" class="code">
<span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(418, '0_3_47');
      ">
<span class="id" title="keyword">Lemma</span> <a id="hfiber_cxfib'_induced_path'0" class="idref" href="#hfiber_cxfib'_induced_path'0"><span class="id" title="lemma">hfiber_cxfib'_induced_path'0</span></a> `{<a id="H:150" class="idref" href="#H:150"><span class="id" title="binder">Univalence</span></a>} {<a id="A:151" class="idref" href="#A:151"><span class="id" title="binder">A</span></a> <a id="B:152" class="idref" href="#B:152"><span class="id" title="binder">B</span></a> <a id="C:153" class="idref" href="#C:153"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} (<a id="E:154" class="idref" href="#E:154"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:153"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:152"><span class="id" title="variable">B</span></a>)<br>
      (<a id="F:155" class="idref" href="#F:155"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#middle"><span class="id" title="projection">middle</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:154"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:151"><span class="id" title="variable">A</span></a>) (<a id="p:156" class="idref" href="#p:156"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:154"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:155"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)<br>
      (<a id="Y:157" class="idref" href="#Y:157"><span class="id" title="binder">Y</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'"><span class="id" title="definition">hfiber_cxfib'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:154"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:155"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:156"><span class="id" title="variable">p</span></a>)<br>
  : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#abses_pullback_trivial_preimage"><span class="id" title="definition">abses_pullback_trivial_preimage</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:154"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:155"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:156"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#Y:157"><span class="id" title="variable">Y</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(419, '0_3_47');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(420, '0_3_47');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">Y</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Y</span> <span class="id" title="var">Q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(421, '0_3_47');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#abses_path_data_to_iso"><span class="id" title="definition">abses_path_data_to_iso</span></a>;<br>
    <span class="id" title="var">srefine</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(422, '0_3_47');
      "><br>
  - <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Algebra.Groups.QuotientGroup.html#grp_quotient_rec"><span class="id" title="definition">grp_quotient_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(423, '0_3_47');
      "><br>
    1: <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.GrpPullback.html#grp_pullback_pr1"><span class="id" title="definition">grp_pullback_pr1</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">$</span></a><a class="idref" href="HoTT.WildCat.Core.html#dccd97e5e8654d6017c4fbeb4597fdb1"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">(</span></a><span class="id" title="var">Q</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">).1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(424, '0_3_47');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span> [<span class="id" title="var">b</span> <span class="id" title="var">q0</span>].</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(425, '0_3_47');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> <span class="id" title="var">q0</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(426, '0_3_47');
      "><br>
    <span class="id" title="var">nrefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#induced_map_eq"><span class="id" title="lemma">induced_map_eq</span></a> <span class="id" title="var">E</span> <span class="id" title="var">F</span> <span class="id" title="var">p</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">Y</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">Q</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>); <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(427, '0_3_47');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_unit_r"><span class="id" title="definition">grp_unit_r</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_unit"><span class="id" title="definition">grp_homo_unit</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(428, '0_3_47');
      "><br>
  - <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(429, '0_3_47');
      "><br>
    <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Algebra.Groups.GrpPullback.html#grp_pullback_pr1"><span class="id" title="definition">grp_pullback_pr1</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">(</span></a><span class="id" title="var">Q</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">).2</span></a> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(430, '0_3_47');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.QuotientGroup.html#grp_quotient_rec_beta'"><span class="id" title="definition">grp_quotient_rec_beta'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">F</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <span class="id" title="var">F</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(431, '0_3_47');
      "><br>
  - <span class="id" title="var">nrapply</span> (<a class="idref" href="HoTT.Modalities.ReflectiveSubuniverse.html#conn_map_elim"><span class="id" title="definition">conn_map_elim</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Algebra.Groups.QuotientGroup.html#grp_quotient_map"><span class="id" title="definition">grp_quotient_map</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(432, '0_3_47');
      "><br>
    1: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Colimits.Quotient.html#issurj_class_of"><span class="id" title="instance">issurj_class_of</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(433, '0_3_47');
      "><br>
    1: <span class="id" title="tactic">intros</span> ?; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#istrunc_paths"><span class="id" title="instance">istrunc_paths</span></a>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#group_isgroup"><span class="id" title="projection">group_isgroup</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(434, '0_3_47');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">f</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(435, '0_3_47');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <span class="id" title="var">E</span>) (<a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">(</span></a><span class="id" title="var">Q</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">).2</span></a> <span class="id" title="var">f</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>); <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Basics.Overture.html#proj1"><span class="id" title="projection">pr1</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(436, '0_3_47');
      "><br>
    <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Limits.Pullback.html#pullback_commsq"><span class="id" title="definition">pullback_commsq</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">(</span></a><span class="id" title="var">Q</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">).1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">f</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(437, '0_3_47');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(438, '0_3_47');
      "><br>
<br>
<span class="id" title="keyword">Lemma</span> <a id="hfiber_cxfib'_induced_path'" class="idref" href="#hfiber_cxfib'_induced_path'"><span class="id" title="lemma">hfiber_cxfib'_induced_path'</span></a> `{<a id="H:158" class="idref" href="#H:158"><span class="id" title="binder">Univalence</span></a>} {<a id="A:159" class="idref" href="#A:159"><span class="id" title="binder">A</span></a> <a id="B:160" class="idref" href="#B:160"><span class="id" title="binder">B</span></a> <a id="C:161" class="idref" href="#C:161"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} (<a id="E:162" class="idref" href="#E:162"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:161"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:160"><span class="id" title="variable">B</span></a>)<br>
      (<a id="F:163" class="idref" href="#F:163"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#middle"><span class="id" title="projection">middle</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:162"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:159"><span class="id" title="variable">A</span></a>) (<a id="p:164" class="idref" href="#p:164"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:162"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:163"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)<br>
      (<a id="Y:165" class="idref" href="#Y:165"><span class="id" title="binder">Y</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'"><span class="id" title="definition">hfiber_cxfib'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:162"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:163"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:164"><span class="id" title="variable">p</span></a>)<br>
  : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#path_hfiber_cxfib'"><span class="id" title="definition">path_hfiber_cxfib'</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'_inhabited"><span class="id" title="definition">hfiber_cxfib'_inhabited</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:162"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:163"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:164"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#Y:165"><span class="id" title="variable">Y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(439, '0_3_47');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(440, '0_3_47');
      "><br>
  <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'_induced_path'0"><span class="id" title="lemma">hfiber_cxfib'_induced_path'0</span></a> <span class="id" title="var">E</span> <span class="id" title="var">F</span> <span class="id" title="var">p</span> <span class="id" title="var">Y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(441, '0_3_47');
      "><br>
  <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.WildCat.Core.html#gpd_moveR_Vh"><span class="id" title="definition">gpd_moveR_Vh</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(442, '0_3_47');
      "><br>
  <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.WildCat.Core.html#gpd_moveL_hM"><span class="id" title="definition">gpd_moveL_hM</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(443, '0_3_47');
      "><br>
  <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.WildCat.Core.html#gpd_moveR_Vh"><span class="id" title="definition">gpd_moveR_Vh</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(444, '0_3_47');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(445, '0_3_47');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Limits.Pullback.html#equiv_path_pullback_hset"><span class="id" title="definition">equiv_path_pullback_hset</span></a>; <span class="id" title="tactic">split</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(446, '0_3_47');
      "><br>
  2: <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <span class="id" title="var">Y</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a><a class="idref" href="HoTT.WildCat.Core.html#8ee154f795cff7ee80397472b84ea7a8"><span class="id" title="notation">^$</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(447, '0_3_47');
      "><br>
  <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(448, '0_3_47');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(449, '0_3_47');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_47"><pre><span></span></pre></div>
<div class="doc" scenenumber="49">
It follows that <span class="inlinecode"><a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'"><span class="id" title="definition">hfiber_cxfib'</span></a></span> is contractible. 
</div>
<div scenenumber="51" class="code">
<span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(455, '0_3_51');
      ">
<span class="id" title="keyword">Lemma</span> <a id="contr_hfiber_cxfib'" class="idref" href="#contr_hfiber_cxfib'"><span class="id" title="lemma">contr_hfiber_cxfib'</span></a> `{<a id="H:166" class="idref" href="#H:166"><span class="id" title="binder">Univalence</span></a>} {<a id="A:167" class="idref" href="#A:167"><span class="id" title="binder">A</span></a> <a id="B:168" class="idref" href="#B:168"><span class="id" title="binder">B</span></a> <a id="C:169" class="idref" href="#C:169"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} (<a id="E:170" class="idref" href="#E:170"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:169"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:168"><span class="id" title="variable">B</span></a>)<br>
      (<a id="F:171" class="idref" href="#F:171"><span class="id" title="binder">F</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#middle"><span class="id" title="projection">middle</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:170"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:167"><span class="id" title="variable">A</span></a>) (<a id="p:172" class="idref" href="#p:172"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:170"><span class="id" title="variable">E</span></a>) <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:171"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.WildCat.Core.html#96ad82935041c71951ddbfbeea7fcc62"><span class="id" title="notation">$==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> <span class="id" title="var">_</span>)<br>
  : <a class="idref" href="HoTT.Basics.Overture.html#Contr"><span class="id" title="abbreviation">Contr</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'"><span class="id" title="definition">hfiber_cxfib'</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:170"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#F:171"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#p:172"><span class="id" title="variable">p</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(456, '0_3_51');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(457, '0_3_51');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Overture.html#Build_Contr"><span class="id" title="constructor">Build_Contr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(458, '0_3_51');
      "><br>
  1: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'_inhabited"><span class="id" title="definition">hfiber_cxfib'_inhabited</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(459, '0_3_51');
      "><br>
  <span class="id" title="tactic">intros</span> [<span class="id" title="var">Y</span> <span class="id" title="var">q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(460, '0_3_51');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#equiv_path_hfiber_cxfib'"><span class="id" title="definition">equiv_path_hfiber_cxfib'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(461, '0_3_51');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#hfiber_cxfib'_induced_path'"><span class="id" title="lemma">hfiber_cxfib'_induced_path'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(462, '0_3_51');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(463, '0_3_51');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_51"><pre><span></span></pre></div>
<div class="doc" scenenumber="53">
From this we deduce exactness. 
</div>
<div scenenumber="55" class="code">
<span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(467, '0_3_55');
      ">
<span class="id" title="keyword">Global Instance</span> <a id="isexact_abses_pullback" class="idref" href="#isexact_abses_pullback"><span class="id" title="instance">isexact_abses_pullback</span></a> `{<a id="H:173" class="idref" href="#H:173"><span class="id" title="binder">Univalence</span></a>} {<a id="A:174" class="idref" href="#A:174"><span class="id" title="binder">A</span></a> <a id="B:175" class="idref" href="#B:175"><span class="id" title="binder">B</span></a> <a id="C:176" class="idref" href="#C:176"><span class="id" title="binder">C</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbelianGroup.html#AbGroup"><span class="id" title="record">AbGroup</span></a>} {<a id="E:177" class="idref" href="#E:177"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#C:176"><span class="id" title="variable">C</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#B:175"><span class="id" title="variable">B</span></a>}<br>
  : <a class="idref" href="HoTT.Homotopy.ExactSequence.html#IsExact"><span class="id" title="class">IsExact</span></a> <a class="idref" href="HoTT.Modalities.Identity.html#purely"><span class="id" title="definition">purely</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback"><span class="id" title="definition">abses_pullback</span></a> (<span class="id" title="var">A</span>:=<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#A:174"><span class="id" title="variable">A</span></a>) (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#projection"><span class="id" title="projection">projection</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:177"><span class="id" title="variable">E</span></a>)) (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback"><span class="id" title="definition">abses_pullback</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#E:177"><span class="id" title="variable">E</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(468, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(469, '0_3_55');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Homotopy.ExactSequence.html#Build_IsExact"><span class="id" title="constructor">Build_IsExact</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(470, '0_3_55');
      "><br>
  1: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#iscomplex_pullback_abses"><span class="id" title="definition">iscomplex_pullback_abses</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(471, '0_3_55');
      "><br>
  <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ind"><span class="id" title="definition">equiv_ind</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#equiv_hfiber_abses"><span class="id" title="definition">equiv_hfiber_abses</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Pullback.html#abses_pullback0"><span class="id" title="definition">abses_pullback0</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#inclusion"><span class="id" title="projection">inclusion</span></a> <span class="id" title="var">E</span>)) (<a class="idref" href="HoTT.Basics.Overture.html#point"><span class="id" title="definition">point</span></a> (<a class="idref" href="HoTT.Algebra.AbGroups.AbSES.Core.html#AbSES"><span class="id" title="definition">AbSES</span></a> <span class="id" title="var">B</span> <span class="id" title="var">A</span>)))).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(472, '0_3_55');
      "><br>
  <span class="id" title="tactic">intros</span> [<span class="id" title="var">F</span> <span class="id" title="var">p</span>].</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(473, '0_3_55');
      "><br>
  <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#contr_equiv'"><span class="id" title="definition">contr_equiv'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(474, '0_3_55');
      "><br>
  1: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#equiv_hfiber_cxfib'"><span class="id" title="definition">equiv_hfiber_cxfib'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(475, '0_3_55');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.AbGroups.AbSES.PullbackFiberSequence.html#contr_hfiber_cxfib'"><span class="id" title="lemma">contr_hfiber_cxfib'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(476, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(477, '0_3_55');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_55"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
