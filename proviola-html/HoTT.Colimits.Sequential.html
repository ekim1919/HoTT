<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "<infomsg>[Loading ML file ltac_plugin.cmxs ... done]</infomsg>	<infomsg>[Loading ML file number_string_notation_plugin.cmxs ... done]	</infomsg>	";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "";
            responses[i]=data;
          

            i = 23;
            data = "";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "1 goal (ID 12)	  	  H : Funext	  A : Sequence	  P : Type	  IsHProp0 : IsHProp P	  ============================	  (Colimit A -> P) <~> (forall n : Graph.graph0 sequence_graph, A n -> P)	";
            responses[i]=data;
          

            i = 28;
            data = "";
            responses[i]=data;
          

            i = 29;
            data = "1 goal (ID 21)	  	  H : Funext	  A : Sequence	  P : Type	  IsHProp0 : IsHProp P	  ============================	  (forall n : Graph.graph0 sequence_graph, A n -> P) <~> (Colimit A -> P)	";
            responses[i]=data;
          

            i = 30;
            data = "1 goal (ID 30)	  	  H : Funext	  A : Sequence	  P : Type	  IsHProp0 : IsHProp P	  ============================	  (forall n : Graph.graph0 sequence_graph, A n -> P) <~> Cocone A P	";
            responses[i]=data;
          

            i = 31;
            data = "1 goal (ID 41)	  	  H : Funext	  A : Sequence	  P : Type	  IsHProp0 : IsHProp P	  ============================	  (forall n : Graph.graph0 sequence_graph, A n -> P) <~>	  {H0 : forall i : Graph.graph0 sequence_graph, A i -> P &	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun x : A i => H0 j ((A _f g) x)) == H0 i}	";
            responses[i]=data;
          

            i = 32;
            data = "1 goal (ID 50)	  	  H : Funext	  A : Sequence	  P : Type	  IsHProp0 : IsHProp P	  ============================	  {H0 : forall i : Graph.graph0 sequence_graph, A i -> P &	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun x : A i => H0 j ((A _f g) x)) == H0 i} <~>	  (forall n : Graph.graph0 sequence_graph, A n -> P)	";
            responses[i]=data;
          

            i = 33;
            data = "2 goals (ID 68)	  	  H : Funext	  A : Sequence	  P : Type	  IsHProp0 : IsHProp P	  ============================	  {H0 : forall i : Graph.graph0 sequence_graph, A i -> P &	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun x : A i => H0 j ((A _f g) x)) == H0 i} ->	  forall n : Graph.graph0 sequence_graph, A n -> P		goal 2 (ID 70) is:	 IsEquiv ?equiv_fun	";
            responses[i]=data;
          

            i = 34;
            data = "1 goal (ID 70)	  	  H : Funext	  A : Sequence	  P : Type	  IsHProp0 : IsHProp P	  ============================	  IsEquiv pr1	";
            responses[i]=data;
          

            i = 35;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 36;
            data = "";
            responses[i]=data;
          

            i = 37;
            data = "";
            responses[i]=data;
          

            i = 38;
            data = "";
            responses[i]=data;
          

            i = 39;
            data = "";
            responses[i]=data;
          

            i = 40;
            data = "";
            responses[i]=data;
          

            i = 41;
            data = "1 goal (ID 31)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  ============================	  Contr (Colimit A)	";
            responses[i]=data;
          

            i = 42;
            data = "";
            responses[i]=data;
          

            i = 43;
            data = "2 goals (ID 32)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  ============================	  Sequence		goal 2 (ID 41) is:	 Contr (Colimit A)	";
            responses[i]=data;
          

            i = 44;
            data = "1 goal (ID 32)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  ============================	  Sequence	2 goals (ID 45)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  ============================	  nat -> Type		goal 2 (ID 47) is:	 forall n : nat, ?X n -> ?X n.+1	";
            responses[i]=data;
          

            i = 45;
            data = "1 goal (ID 47)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  ============================	  forall n : nat, A n -> A n.+1	";
            responses[i]=data;
          

            i = 46;
            data = "1 goal (ID 48)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  n : nat	  ============================	  A n -> A n.+1	";
            responses[i]=data;
          

            i = 47;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 41) is:	 Contr (Colimit A)	";
            responses[i]=data;
          

            i = 48;
            data = "1 goal (ID 41)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  ============================	  Contr (Colimit A)	2 focused goals (shelved: 1) (ID 87)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  ============================	  ?Goal <~> Colimit A		goal 2 (ID 88) is:	 Contr ?Goal	";
            responses[i]=data;
          

            i = 49;
            data = "2 focused goals (shelved: 1) (ID 153)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  ============================	  ?Goal0 ~d~ A		goal 2 (ID 88) is:	 Contr (Colimit ?Goal0)	";
            responses[i]=data;
          

            i = 50;
            data = "3 goals (ID 160)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  ============================	  B 0 <~> A 0		goal 2 (ID 161) is:	 forall (n : Graph.graph0 sequence_graph) (e : B n <~> A n),	 {e' : B n.+1 <~> A n.+1 &	 (fun x : B n => (e x) ^+) == (fun x : B n => e' (x) ^+)}	goal 3 (ID 88) is:	 Contr (Colimit B)	";
            responses[i]=data;
          

            i = 51;
            data = "2 goals (ID 161)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  ============================	  forall (n : Graph.graph0 sequence_graph) (e : B n <~> A n),	  {e' : B n.+1 <~> A n.+1 &	  (fun x : B n => (e x) ^+) == (fun x : B n => e' (x) ^+)}		goal 2 (ID 88) is:	 Contr (Colimit B)	";
            responses[i]=data;
          

            i = 52;
            data = "1 goal (ID 161)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  ============================	  forall (n : Graph.graph0 sequence_graph) (e : B n <~> A n),	  {e' : B n.+1 <~> A n.+1 &	  (fun x : B n => (e x) ^+) == (fun x : B n => e' (x) ^+)}	1 goal (ID 170)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  n : Graph.graph0 sequence_graph	  e : B n <~> A n	  ============================	  {e' : B n.+1 <~> A n.+1 &	  (fun x : B n => (e x) ^+) == (fun x : B n => e' (x) ^+)}	";
            responses[i]=data;
          

            i = 53;
            data = "1 goal (ID 173)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  n : Graph.graph0 sequence_graph	  e : B n <~> A n	  ============================	  (fun x : B n => (e x) ^+) == (fun x : B n => 1%equiv (x) ^+)	";
            responses[i]=data;
          

            i = 54;
            data = "1 goal (ID 175)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  n : Graph.graph0 sequence_graph	  e : B n <~> A n	  x : B n	  ============================	  (e x) ^+ = 1%equiv (x) ^+	";
            responses[i]=data;
          

            i = 55;
            data = "1 goal (ID 185)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  n : Graph.graph0 sequence_graph	  e : B n <~> A n	  x : B n	  ============================	  1%equiv (x) ^+ = (e x) ^+	";
            responses[i]=data;
          

            i = 56;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 88) is:	 Contr (Colimit B)	";
            responses[i]=data;
          

            i = 57;
            data = "1 goal (ID 88)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  ============================	  Contr (Colimit B)	2 goals (ID 207)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  ============================	  Colimit B		goal 2 (ID 209) is:	 forall y : Colimit B, ?center = y	";
            responses[i]=data;
          

            i = 58;
            data = "1 goal (ID 209)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  ============================	  forall y : Colimit B, colim 1 (a 1) = y	";
            responses[i]=data;
          

            i = 59;
            data = "2 goals (ID 228)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : B i),	  colim 1 (a 1) = colim i x		goal 2 (ID 230) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : B i),	 transport (paths (colim 1 (a 1))) (colimp i j g x) (?q j ((B _f g) x)) =	 ?q i x	";
            responses[i]=data;
          

            i = 60;
            data = "1 goal (ID 228)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : B i),	  colim 1 (a 1) = colim i x	1 goal (ID 232)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  i : Graph.graph0 sequence_graph	  x : B i	  ============================	  colim 1 (a 1) = colim i x	";
            responses[i]=data;
          

            i = 61;
            data = "2 goals (ID 241)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  x : B 0	  ============================	  colim 1 (a 1) = colim 0 x		goal 2 (ID 245) is:	 colim 1 (a 1) = colim i.+1 x	";
            responses[i]=data;
          

            i = 62;
            data = "1 goal (ID 245)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  i : nat	  x : B i.+1	  IHi : forall x : B i, colim 1 (a 1) = colim i x	  ============================	  colim 1 (a 1) = colim i.+1 x	";
            responses[i]=data;
          

            i = 63;
            data = "1 goal (ID 259)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  i : nat	  x : B i.+1	  IHi : forall x : B i, colim 1 (a 1) = colim i x	  ============================	  colim i (a i) = colim i.+1 x	";
            responses[i]=data;
          

            i = 64;
            data = "1 goal (ID 276)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  i : nat	  x : B i.+1	  IHi : forall x : B i, colim 1 (a 1) = colim i x	  ============================	  colim i.+1 (a i) ^+ = colim i.+1 x	";
            responses[i]=data;
          

            i = 65;
            data = "1 goal (ID 293)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  i : nat	  x : B i.+1	  IHi : forall x : B i, colim 1 (a 1) = colim i x	  ============================	  colim i.+2 (a i.+1) ^+ = colim i.+1 x	";
            responses[i]=data;
          

            i = 66;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 230) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : B i),	 transport (paths (colim 1 (a 1))) (colimp i j g x)	   ((fun (i0 : Graph.graph0 sequence_graph) (x0 : B i0) =>	     Overture.nat_rect	       (fun i1 : nat => forall x1 : B i1, colim 1 (a 1) = colim i1 x1)	       (fun x1 : B 0 => colimp 0 1 1 x1)	       (fun (i1 : nat) (IHi : forall x1 : B i1, colim 1 (a 1) = colim i1 x1)	          (x1 : B i1.+1) =>	        IHi (a i1) @	        ((colimp i1 i1.+1 1 (a i1))^ @	         ((colimp i1.+1 i1.+2 1 (a i1.+1))^ @ colimp i1.+1 i1.+2 1 x1))) i0	       x0) j ((B _f g) x)) =	 (fun (i0 : Graph.graph0 sequence_graph) (x0 : B i0) =>	  Overture.nat_rect	    (fun i1 : nat => forall x1 : B i1, colim 1 (a 1) = colim i1 x1)	    (fun x1 : B 0 => colimp 0 1 1 x1)	    (fun (i1 : nat) (IHi : forall x1 : B i1, colim 1 (a 1) = colim i1 x1)	       (x1 : B i1.+1) =>	     IHi (a i1) @	     ((colimp i1 i1.+1 1 (a i1))^ @	      ((colimp i1.+1 i1.+2 1 (a i1.+1))^ @ colimp i1.+1 i1.+2 1 x1))) i0 x0)	   i x	";
            responses[i]=data;
          

            i = 67;
            data = "1 goal (ID 230)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : B i),	  transport (paths (colim 1 (a 1))) (colimp i j g x)	    ((fun (i0 : Graph.graph0 sequence_graph) (x0 : B i0) =>	      Overture.nat_rect	        (fun i1 : nat => forall x1 : B i1, colim 1 (a 1) = colim i1 x1)	        (fun x1 : B 0 => colimp 0 1 1 x1)	        (fun (i1 : nat) (IHi : forall x1 : B i1, colim 1 (a 1) = colim i1 x1)	           (x1 : B i1.+1) =>	         IHi (a i1) @	         ((colimp i1 i1.+1 1 (a i1))^ @	          ((colimp i1.+1 i1.+2 1 (a i1.+1))^ @ colimp i1.+1 i1.+2 1 x1))) i0	        x0) j ((B _f g) x)) =	  (fun (i0 : Graph.graph0 sequence_graph) (x0 : B i0) =>	   Overture.nat_rect	     (fun i1 : nat => forall x1 : B i1, colim 1 (a 1) = colim i1 x1)	     (fun x1 : B 0 => colimp 0 1 1 x1)	     (fun (i1 : nat) (IHi : forall x1 : B i1, colim 1 (a 1) = colim i1 x1)	        (x1 : B i1.+1) =>	      IHi (a i1) @	      ((colimp i1 i1.+1 1 (a i1))^ @	       ((colimp i1.+1 i1.+2 1 (a i1.+1))^ @ colimp i1.+1 i1.+2 1 x1))) i0 x0)	    i x	1 goal (ID 306)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  n, m : Graph.graph0 sequence_graph	  x : B n	  ============================	  transport (paths (colim 1 (a 1))) (colimp n n.+1 1 x)	    (Overture.nat_rect	       (fun i : nat => forall x0 : B i, colim 1 (a 1) = colim i x0)	       (fun x0 : B 0 => colimp 0 1 1 x0)	       (fun (i : nat) (IHi : forall x0 : B i, colim 1 (a 1) = colim i x0)	          (x0 : B i.+1) =>	        IHi (a i) @	        ((colimp i i.+1 1 (a i))^ @	         ((colimp i.+1 i.+2 1 (a i.+1))^ @ colimp i.+1 i.+2 1 x0))) n.+1	       (x) ^+) =	  Overture.nat_rect	    (fun i : nat => forall x0 : B i, colim 1 (a 1) = colim i x0)	    (fun x0 : B 0 => colimp 0 1 1 x0)	    (fun (i : nat) (IHi : forall x0 : B i, colim 1 (a 1) = colim i x0)	       (x0 : B i.+1) =>	     IHi (a i) @	     ((colimp i i.+1 1 (a i))^ @	      ((colimp i.+1 i.+2 1 (a i.+1))^ @ colimp i.+1 i.+2 1 x0))) n x	";
            responses[i]=data;
          

            i = 68;
            data = "1 goal (ID 313)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  n, m : Graph.graph0 sequence_graph	  x : B n	  ============================	  ((ap (fun _ : Colimit B => colim 1 (a 1)) (colimp n n.+1 1 x))^ @	   Overture.nat_rect	     (fun i : nat => forall x0 : B i, colim 1 (a 1) = colim i x0)	     (fun x0 : B 0 => colimp 0 1 1 x0)	     (fun (i : nat) (IHi : forall x0 : B i, colim 1 (a 1) = colim i x0)	        (x0 : B i.+1) =>	      IHi (a i) @	      ((colimp i i.+1 1 (a i))^ @	       ((colimp i.+1 i.+2 1 (a i.+1))^ @ colimp i.+1 i.+2 1 x0))) n.+1 	     (x) ^+) @ ap idmap (colimp n n.+1 1 x) =	  Overture.nat_rect	    (fun i : nat => forall x0 : B i, colim 1 (a 1) = colim i x0)	    (fun x0 : B 0 => colimp 0 1 1 x0)	    (fun (i : nat) (IHi : forall x0 : B i, colim 1 (a 1) = colim i x0)	       (x0 : B i.+1) =>	     IHi (a i) @	     ((colimp i i.+1 1 (a i))^ @	      ((colimp i.+1 i.+2 1 (a i.+1))^ @ colimp i.+1 i.+2 1 x0))) n x	";
            responses[i]=data;
          

            i = 69;
            data = "1 goal (ID 324)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  n, m : Graph.graph0 sequence_graph	  x : B n	  ============================	  (1^ @	   Overture.nat_rect	     (fun i : nat => forall x0 : B i, colim 1 (a 1) = colim i x0)	     (fun x0 : B 0 => colimp 0 1 1 x0)	     (fun (i : nat) (IHi : forall x0 : B i, colim 1 (a 1) = colim i x0)	        (x0 : B i.+1) =>	      IHi (a i) @	      ((colimp i i.+1 1 (a i))^ @	       ((colimp i.+1 i.+2 1 (a i.+1))^ @ colimp i.+1 i.+2 1 x0))) n.+1 	     (x) ^+) @ ap idmap (colimp n n.+1 1 x) =	  Overture.nat_rect	    (fun i : nat => forall x0 : B i, colim 1 (a 1) = colim i x0)	    (fun x0 : B 0 => colimp 0 1 1 x0)	    (fun (i : nat) (IHi : forall x0 : B i, colim 1 (a 1) = colim i x0)	       (x0 : B i.+1) =>	     IHi (a i) @	     ((colimp i i.+1 1 (a i))^ @	      ((colimp i.+1 i.+2 1 (a i.+1))^ @ colimp i.+1 i.+2 1 x0))) n x	";
            responses[i]=data;
          

            i = 70;
            data = "1 goal (ID 332)	  	  funext : Funext	  A : Sequence	  a : forall n : Graph.graph0 sequence_graph, A n	  H : forall n : nat, const (a n.+1) == A _f 1	  B := Build_Sequence A (fun n : nat => const (a n.+1)) : Sequence	  n, m : Graph.graph0 sequence_graph	  x : B n	  ============================	  (1^ @	   Overture.nat_rect	     (fun i : nat => forall x0 : B i, colim 1 (a 1) = colim i x0)	     (fun x0 : B 0 => colimp 0 1 1 x0)	     (fun (i : nat) (IHi : forall x0 : B i, colim 1 (a 1) = colim i x0)	        (x0 : B i.+1) =>	      IHi (a i) @	      ((colimp i i.+1 1 (a i))^ @	       ((colimp i.+1 i.+2 1 (a i.+1))^ @ colimp i.+1 i.+2 1 x0))) n.+1 	     (x) ^+) @ colimp n n.+1 1 x =	  Overture.nat_rect	    (fun i : nat => forall x0 : B i, colim 1 (a 1) = colim i x0)	    (fun x0 : B 0 => colimp 0 1 1 x0)	    (fun (i : nat) (IHi : forall x0 : B i, colim 1 (a 1) = colim i x0)	       (x0 : B i.+1) =>	     IHi (a i) @	     ((colimp i i.+1 1 (a i))^ @	      ((colimp i.+1 i.+2 1 (a i.+1))^ @ colimp i.+1 i.+2 1 x0))) n x	";
            responses[i]=data;
          

            i = 71;
            data = "";
            responses[i]=data;
          

            i = 72;
            data = "";
            responses[i]=data;
          

            i = 73;
            data = "";
            responses[i]=data;
          

            i = 74;
            data = "";
            responses[i]=data;
          

            i = 75;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 76;
            data = "1 goal (ID 40)	  	  A : Sequence	  a : A 0	  k : Graph.graph0 sequence_graph	  ============================	  A k	2 goals (ID 44)	  	  A : Sequence	  a : A 0	  ============================	  A 0		goal 2 (ID 47) is:	 A k.+1	1 goal (ID 44)	  	  A : Sequence	  a : A 0	  ============================	  A 0	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 47) is:	 A k.+1	";
            responses[i]=data;
          

            i = 77;
            data = "1 goal (ID 47)	  	  A : Sequence	  a : A 0	  k : nat	  q : A k	  ============================	  A k.+1	No more goals.	";
            responses[i]=data;
          

            i = 78;
            data = "";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "";
            responses[i]=data;
          

            i = 83;
            data = "";
            responses[i]=data;
          

            i = 84;
            data = "1 goal (ID 45)	  	  A : Sequence	  x : {x : _ & A x}	  ============================	  {x : _ & A x}	";
            responses[i]=data;
          

            i = 85;
            data = "";
            responses[i]=data;
          

            i = 86;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 87;
            data = "";
            responses[i]=data;
          

            i = 88;
            data = "1 goal (ID 51)	  	  A : Sequence	  x : {x : _ & A x}	  k : nat	  ============================	  {x : _ & A x}	";
            responses[i]=data;
          

            i = 89;
            data = "";
            responses[i]=data;
          

            i = 90;
            data = "2 goals (ID 55)	  	  A : Sequence	  x : {x : _ & A x}	  ============================	  {x : _ & A x}		goal 2 (ID 58) is:	 {x : _ & A x}	";
            responses[i]=data;
          

            i = 91;
            data = "1 goal (ID 55)	  	  A : Sequence	  x : {x : _ & A x}	  ============================	  {x : _ & A x}	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 58) is:	 {x : _ & A x}	";
            responses[i]=data;
          

            i = 92;
            data = "1 goal (ID 58)	  	  A : Sequence	  x : {x : _ & A x}	  k : nat	  y : {x : _ & A x}	  ============================	  {x : _ & A x}	No more goals.	";
            responses[i]=data;
          

            i = 93;
            data = "";
            responses[i]=data;
          

            i = 94;
            data = "";
            responses[i]=data;
          

            i = 95;
            data = "";
            responses[i]=data;
          

            i = 96;
            data = "1 goal (ID 61)	  	  A : Sequence	  x : {x : _ & A x}	  k : nat	  ============================	  ((x) ^++) ^++ (k) = (x) ^++ (k.+1)	";
            responses[i]=data;
          

            i = 97;
            data = "";
            responses[i]=data;
          

            i = 98;
            data = "2 goals (ID 65)	  	  A : Sequence	  x : {x : _ & A x}	  ============================	  ((x) ^++) ^++ (0) = (x) ^++ (1)		goal 2 (ID 68) is:	 ((x) ^++) ^++ (k.+1) = (x) ^++ (k.+2)	";
            responses[i]=data;
          

            i = 99;
            data = "1 goal (ID 65)	  	  A : Sequence	  x : {x : _ & A x}	  ============================	  ((x) ^++) ^++ (0) = (x) ^++ (1)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 68) is:	 ((x) ^++) ^++ (k.+1) = (x) ^++ (k.+2)	";
            responses[i]=data;
          

            i = 100;
            data = "1 goal (ID 68)	  	  A : Sequence	  x : {x : _ & A x}	  k : nat	  q : ((x) ^++) ^++ (k) = (x) ^++ (k.+1)	  ============================	  ((x) ^++) ^++ (k.+1) = (x) ^++ (k.+2)	No more goals.	";
            responses[i]=data;
          

            i = 101;
            data = "";
            responses[i]=data;
          

            i = 102;
            data = "1 goal (ID 78)	  	  A : Sequence	  a : A 0	  k : nat	  ============================	  ((0; a)) ^++ (k) = (k; (a) ^+ (k))	";
            responses[i]=data;
          

            i = 103;
            data = "";
            responses[i]=data;
          

            i = 104;
            data = "2 goals (ID 82)	  	  A : Sequence	  a : A 0	  ============================	  ((0; a)) ^++ (0) = (0; (a) ^+ (0))		goal 2 (ID 85) is:	 ((0; a)) ^++ (k.+1) = (k.+1; (a) ^+ (k.+1))	";
            responses[i]=data;
          

            i = 105;
            data = "1 goal (ID 82)	  	  A : Sequence	  a : A 0	  ============================	  ((0; a)) ^++ (0) = (0; (a) ^+ (0))	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 85) is:	 ((0; a)) ^++ (k.+1) = (k.+1; (a) ^+ (k.+1))	";
            responses[i]=data;
          

            i = 106;
            data = "1 goal (ID 85)	  	  A : Sequence	  a : A 0	  k : nat	  q : ((0; a)) ^++ (k) = (k; (a) ^+ (k))	  ============================	  ((0; a)) ^++ (k.+1) = (k.+1; (a) ^+ (k.+1))	No more goals.	";
            responses[i]=data;
          

            i = 107;
            data = "";
            responses[i]=data;
          

            i = 108;
            data = "";
            responses[i]=data;
          

            i = 109;
            data = "";
            responses[i]=data;
          

            i = 110;
            data = "";
            responses[i]=data;
          

            i = 111;
            data = "";
            responses[i]=data;
          

            i = 112;
            data = "";
            responses[i]=data;
          

            i = 113;
            data = "";
            responses[i]=data;
          

            i = 114;
            data = "1 goal (ID 145)	  	  A : Sequence	  E : Type	  F, G : Colimit A -> E	  h : forall n : Graph.graph0 sequence_graph, F o inj A n == G o inj A n	  H : forall (n : Graph.graph0 sequence_graph) (a : A n),	      ap F (glue A n a) @ h n a = h n.+1 (a) ^+ @ ap G (glue A n a)	  ============================	  F == G	";
            responses[i]=data;
          

            i = 115;
            data = "";
            responses[i]=data;
          

            i = 116;
            data = "1 goal (ID 163)	  	  A : Sequence	  E : Type	  F, G : Colimit A -> E	  h : forall n : Graph.graph0 sequence_graph, F o inj A n == G o inj A n	  H : forall (n : Graph.graph0 sequence_graph) (a : A n),	      ap F (glue A n a) @ h n a = h n.+1 (a) ^+ @ ap G (glue A n a)	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  transport (fun w : Colimit A => F w = G w) (colimp n n.+1 1 a)	    (h n.+1 (a) ^+) = h n a	";
            responses[i]=data;
          

            i = 117;
            data = "1 goal (ID 179)	  	  A : Sequence	  E : Type	  F, G : Colimit A -> E	  h : forall n : Graph.graph0 sequence_graph, F o inj A n == G o inj A n	  H : forall (n : Graph.graph0 sequence_graph) (a : A n),	      ap F (glue A n a) @ h n a = h n.+1 (a) ^+ @ ap G (glue A n a)	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall p : F (inj A n.+1 (a) ^+) = G (inj A n.+1 (a) ^+),	  ap F 1 @ p = h n.+1 (a) ^+ @ ap G 1 ->	  transport (fun w : Colimit A => F w = G w) 1 (h n.+1 (a) ^+) = p	";
            responses[i]=data;
          

            i = 118;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 119;
            data = "";
            responses[i]=data;
          

            i = 120;
            data = "";
            responses[i]=data;
          

            i = 121;
            data = "";
            responses[i]=data;
          

            i = 122;
            data = "";
            responses[i]=data;
          

            i = 123;
            data = "";
            responses[i]=data;
          

            i = 124;
            data = "<infomsg>succ_seq is defined</infomsg>	";
            responses[i]=data;
          

            i = 125;
            data = "";
            responses[i]=data;
          

            i = 126;
            data = "";
            responses[i]=data;
          

            i = 127;
            data = "";
            responses[i]=data;
          

            i = 128;
            data = "";
            responses[i]=data;
          

            i = 129;
            data = "<infomsg>shift_seq is defined</infomsg>	";
            responses[i]=data;
          

            i = 130;
            data = "";
            responses[i]=data;
          

            i = 131;
            data = "";
            responses[i]=data;
          

            i = 132;
            data = "";
            responses[i]=data;
          

            i = 133;
            data = "";
            responses[i]=data;
          

            i = 134;
            data = "1 goal (ID 177)	  	  A : Sequence	  ============================	  Colimit (succ_seq A) -> Colimit A	";
            responses[i]=data;
          

            i = 135;
            data = "";
            responses[i]=data;
          

            i = 136;
            data = "2 goals (ID 207)	  	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, succ_seq A i -> Colimit A		goal 2 (ID 209) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 ?legs j o (succ_seq A) _f g == ?legs i	";
            responses[i]=data;
          

            i = 137;
            data = "1 goal (ID 207)	  	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, succ_seq A i -> Colimit A	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 209) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (n : Graph.graph0 sequence_graph) (a : succ_seq A n) => inj A n.+1 a) j	 o (succ_seq A) _f g ==	 (fun (n : Graph.graph0 sequence_graph) (a : succ_seq A n) => inj A n.+1 a) i	";
            responses[i]=data;
          

            i = 138;
            data = "1 goal (ID 209)	  	  A : Sequence	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (n : Graph.graph0 sequence_graph) (a : succ_seq A n) => inj A n.+1 a)	    j o (succ_seq A) _f g ==	  (fun (n : Graph.graph0 sequence_graph) (a : succ_seq A n) => inj A n.+1 a)	    i	No more goals.	";
            responses[i]=data;
          

            i = 139;
            data = "";
            responses[i]=data;
          

            i = 140;
            data = "1 goal (ID 196)	  	  A : Sequence	  n : Graph.graph0 sequence_graph	  a : succ_seq A n	  ============================	  ap (colim_succ_seq_to_colim_seq A) (glue (succ_seq A) n a) = glue A n.+1 a	";
            responses[i]=data;
          

            i = 141;
            data = "";
            responses[i]=data;
          

            i = 142;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 143;
            data = "";
            responses[i]=data;
          

            i = 144;
            data = "1 goal (ID 228)	  	  A : Sequence	  n : Graph.graph0 sequence_graph	  a1, a2 : succ_seq A n	  p : a1 = a2	  ============================	  ap (colim_succ_seq_to_colim_seq A) (ap (inj (succ_seq A) n) p) =	  ap (inj A n.+1) p	";
            responses[i]=data;
          

            i = 145;
            data = "";
            responses[i]=data;
          

            i = 146;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 147;
            data = "";
            responses[i]=data;
          

            i = 148;
            data = "1 goal (ID 233)	  	  A : Sequence	  ============================	  IsEquiv (colim_succ_seq_to_colim_seq A)	";
            responses[i]=data;
          

            i = 149;
            data = "";
            responses[i]=data;
          

            i = 150;
            data = "3 goals (ID 259)	  	  A : Sequence	  ============================	  Colimit A -> Colimit (succ_seq A)		goal 2 (ID 261) is:	 colim_succ_seq_to_colim_seq A o ?g == idmap	goal 3 (ID 263) is:	 ?g o colim_succ_seq_to_colim_seq A == idmap	";
            responses[i]=data;
          

            i = 151;
            data = "1 goal (ID 259)	  	  A : Sequence	  ============================	  Colimit A -> Colimit (succ_seq A)	2 goals (ID 293)	  	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> Colimit (succ_seq A)		goal 2 (ID 295) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j), ?legs j o A _f g == ?legs i	";
            responses[i]=data;
          

            i = 152;
            data = "1 goal (ID 293)	  	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> Colimit (succ_seq A)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 goals		goal 1 (ID 295) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	  inj (succ_seq A) n (a) ^+) j o A _f g ==	 (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	  inj (succ_seq A) n (a) ^+) i	goal 2 (ID 261) is:	 colim_succ_seq_to_colim_seq A	 o Colimit_rec (Colimit (succ_seq A))	     {|	       legs :=	         fun (n : Graph.graph0 sequence_graph) (a : A n) =>	         inj (succ_seq A) n (a) ^+;	       legs_comm := ?legs_comm	     |} == idmap	goal 3 (ID 263) is:	 Colimit_rec (Colimit (succ_seq A))	   {|	     legs :=	       fun (n : Graph.graph0 sequence_graph) (a : A n) =>	       inj (succ_seq A) n (a) ^+;	     legs_comm := ?legs_comm	   |} o colim_succ_seq_to_colim_seq A == idmap	";
            responses[i]=data;
          

            i = 153;
            data = "1 goal (ID 295)	  	  A : Sequence	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	   inj (succ_seq A) n (a) ^+) j o A _f g ==	  (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	   inj (succ_seq A) n (a) ^+) i	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 261) is:	 colim_succ_seq_to_colim_seq A	 o Colimit_rec (Colimit (succ_seq A))	     {|	       legs :=	         fun (n : Graph.graph0 sequence_graph) (a : A n) =>	         inj (succ_seq A) n (a) ^+;	       legs_comm :=	         fun (n m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n m) =>	         (fun a : A n =>	          match	            p as p0 in (_ = y)	            return	              (inj (succ_seq A) y ((A _f p0) a) ^+ =	               inj (succ_seq A) n (a) ^+)	          with	          | 1 => glue (succ_seq A) n (a) ^+	          end)	         :	         (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	          inj (succ_seq A) n0 (a) ^+) m o A _f p ==	         (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	          inj (succ_seq A) n0 (a) ^+) n	     |} == idmap	goal 2 (ID 263) is:	 Colimit_rec (Colimit (succ_seq A))	   {|	     legs :=	       fun (n : Graph.graph0 sequence_graph) (a : A n) =>	       inj (succ_seq A) n (a) ^+;	     legs_comm :=	       fun (n m : Graph.graph0 sequence_graph)	         (p : Graph.graph1 sequence_graph n m) =>	       (fun a : A n =>	        match	          p as p0 in (_ = y)	          return	            (inj (succ_seq A) y ((A _f p0) a) ^+ = inj (succ_seq A) n (a) ^+)	        with	        | 1 => glue (succ_seq A) n (a) ^+	        end)	       :	       (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	        inj (succ_seq A) n0 (a) ^+) m o A _f p ==	       (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	        inj (succ_seq A) n0 (a) ^+) n	   |} o colim_succ_seq_to_colim_seq A == idmap	";
            responses[i]=data;
          

            i = 154;
            data = "1 goal (ID 261)	  	  A : Sequence	  ============================	  colim_succ_seq_to_colim_seq A	  o Colimit_rec (Colimit (succ_seq A))	      {|	        legs :=	          fun (n : Graph.graph0 sequence_graph) (a : A n) =>	          inj (succ_seq A) n (a) ^+;	        legs_comm :=	          fun (n m : Graph.graph0 sequence_graph)	            (p : Graph.graph1 sequence_graph n m) =>	          (fun a : A n =>	           match	             p as p0 in (_ = y)	             return	               (inj (succ_seq A) y ((A _f p0) a) ^+ =	                inj (succ_seq A) n (a) ^+)	           with	           | 1 => glue (succ_seq A) n (a) ^+	           end)	          :	          (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	           inj (succ_seq A) n0 (a) ^+) m o A _f p ==	          (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	           inj (succ_seq A) n0 (a) ^+) n	      |} == idmap	2 goals (ID 359)	  	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit A =>	   colim_succ_seq_to_colim_seq A	     (Colimit_rec (Colimit (succ_seq A))	        {|	          legs :=	            fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	            inj (succ_seq A) n0 (a) ^+;	          legs_comm :=	            fun (n0 m : Graph.graph0 sequence_graph)	              (p : Graph.graph1 sequence_graph n0 m) =>	            (fun a : A n0 =>	             match	               p as p0 in (_ = y)	               return	                 (inj (succ_seq A) y ((A _f p0) a) ^+ =	                  inj (succ_seq A) n0 (a) ^+)	             with	             | 1 => glue (succ_seq A) n0 (a) ^+	             end)	            :	            (fun (n1 : Graph.graph0 sequence_graph) (a : A n1) =>	             inj (succ_seq A) n1 (a) ^+) m o A _f p ==	            (fun (n1 : Graph.graph0 sequence_graph) (a : A n1) =>	             inj (succ_seq A) n1 (a) ^+) n0	        |} x)) o inj A n == idmap o inj A n		goal 2 (ID 361) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n),	 ap	   (fun x : Colimit A =>	    colim_succ_seq_to_colim_seq A	      (Colimit_rec (Colimit (succ_seq A))	         {|	           legs :=	             fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	             inj (succ_seq A) n0 (a0) ^+;	           legs_comm :=	             fun (n0 m : Graph.graph0 sequence_graph)	               (p : Graph.graph1 sequence_graph n0 m) =>	             (fun a0 : A n0 =>	              match	                p as p0 in (_ = y)	                return	                  (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                   inj (succ_seq A) n0 (a0) ^+)	              with	              | 1 => glue (succ_seq A) n0 (a0) ^+	              end)	             :	             (fun (n1 : Graph.graph0 sequence_graph) (a0 : A n1) =>	              inj (succ_seq A) n1 (a0) ^+) m o A _f p ==	             (fun (n1 : Graph.graph0 sequence_graph) (a0 : A n1) =>	              inj (succ_seq A) n1 (a0) ^+) n0	         |} x)) (glue A n a) @ ?h n a =	 ?h n.+1 (a) ^+ @ ap idmap (glue A n a)	";
            responses[i]=data;
          

            i = 155;
            data = "1 goal (ID 359)	  	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit A =>	   colim_succ_seq_to_colim_seq A	     (Colimit_rec (Colimit (succ_seq A))	        {|	          legs :=	            fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	            inj (succ_seq A) n0 (a) ^+;	          legs_comm :=	            fun (n0 m : Graph.graph0 sequence_graph)	              (p : Graph.graph1 sequence_graph n0 m) =>	            (fun a : A n0 =>	             match	               p as p0 in (_ = y)	               return	                 (inj (succ_seq A) y ((A _f p0) a) ^+ =	                  inj (succ_seq A) n0 (a) ^+)	             with	             | 1 => glue (succ_seq A) n0 (a) ^+	             end)	            :	            (fun (n1 : Graph.graph0 sequence_graph) (a : A n1) =>	             inj (succ_seq A) n1 (a) ^+) m o A _f p ==	            (fun (n1 : Graph.graph0 sequence_graph) (a : A n1) =>	             inj (succ_seq A) n1 (a) ^+) n0	        |} x)) o inj A n == idmap o inj A n	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 361) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n),	 ap	   (fun x : Colimit A =>	    colim_succ_seq_to_colim_seq A	      (Colimit_rec (Colimit (succ_seq A))	         {|	           legs :=	             fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	             inj (succ_seq A) n0 (a0) ^+;	           legs_comm :=	             fun (n0 m : Graph.graph0 sequence_graph)	               (p : Graph.graph1 sequence_graph n0 m) =>	             (fun a0 : A n0 =>	              match	                p as p0 in (_ = y)	                return	                  (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                   inj (succ_seq A) n0 (a0) ^+)	              with	              | 1 => glue (succ_seq A) n0 (a0) ^+	              end)	             :	             (fun (n1 : Graph.graph0 sequence_graph) (a0 : A n1) =>	              inj (succ_seq A) n1 (a0) ^+) m o A _f p ==	             (fun (n1 : Graph.graph0 sequence_graph) (a0 : A n1) =>	              inj (succ_seq A) n1 (a0) ^+) n0	         |} x)) (glue A n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) => glue A n0 a0) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) => glue A n0 a0) n.+1	   (a) ^+ @ ap idmap (glue A n a)	goal 2 (ID 263) is:	 Colimit_rec (Colimit (succ_seq A))	   {|	     legs :=	       fun (n : Graph.graph0 sequence_graph) (a : A n) =>	       inj (succ_seq A) n (a) ^+;	     legs_comm :=	       fun (n m : Graph.graph0 sequence_graph)	         (p : Graph.graph1 sequence_graph n m) =>	       (fun a : A n =>	        match	          p as p0 in (_ = y)	          return	            (inj (succ_seq A) y ((A _f p0) a) ^+ = inj (succ_seq A) n (a) ^+)	        with	        | 1 => glue (succ_seq A) n (a) ^+	        end)	       :	       (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	        inj (succ_seq A) n0 (a) ^+) m o A _f p ==	       (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	        inj (succ_seq A) n0 (a) ^+) n	   |} o colim_succ_seq_to_colim_seq A == idmap	";
            responses[i]=data;
          

            i = 156;
            data = "1 goal (ID 361)	  	  A : Sequence	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n),	  ap	    (fun x : Colimit A =>	     colim_succ_seq_to_colim_seq A	       (Colimit_rec (Colimit (succ_seq A))	          {|	            legs :=	              fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	              inj (succ_seq A) n0 (a0) ^+;	            legs_comm :=	              fun (n0 m : Graph.graph0 sequence_graph)	                (p : Graph.graph1 sequence_graph n0 m) =>	              (fun a0 : A n0 =>	               match	                 p as p0 in (_ = y)	                 return	                   (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                    inj (succ_seq A) n0 (a0) ^+)	               with	               | 1 => glue (succ_seq A) n0 (a0) ^+	               end)	              :	              (fun (n1 : Graph.graph0 sequence_graph) (a0 : A n1) =>	               inj (succ_seq A) n1 (a0) ^+) m o A _f p ==	              (fun (n1 : Graph.graph0 sequence_graph) (a0 : A n1) =>	               inj (succ_seq A) n1 (a0) ^+) n0	          |} x)) (glue A n a) @	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) => glue A n0 a0) n a =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) => glue A n0 a0) n.+1	    (a) ^+ @ ap idmap (glue A n a)	1 goal (ID 387)	  	  A : Sequence	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  ap (colim_succ_seq_to_colim_seq A)	    (legs_comm	       {|	         legs :=	           fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	           inj (succ_seq A) n0 (a0) ^+;	         legs_comm :=	           fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (a0 : A n0) =>	           match	             p as p0 in (_ = y)	             return	               (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                inj (succ_seq A) n0 (a0) ^+)	           with	           | 1 => colimp n0 n0.+1 1 (a0) ^+	           end	       |} n n.+1 1 a) @ colimp n n.+1 1 a =	  colimp n.+1 n.+2 1 (a) ^+ @ colimp n n.+1 1 a	";
            responses[i]=data;
          

            i = 157;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 263) is:	 Colimit_rec (Colimit (succ_seq A))	   {|	     legs :=	       fun (n : Graph.graph0 sequence_graph) (a : A n) =>	       inj (succ_seq A) n (a) ^+;	     legs_comm :=	       fun (n m : Graph.graph0 sequence_graph)	         (p : Graph.graph1 sequence_graph n m) =>	       (fun a : A n =>	        match	          p as p0 in (_ = y)	          return	            (inj (succ_seq A) y ((A _f p0) a) ^+ = inj (succ_seq A) n (a) ^+)	        with	        | 1 => glue (succ_seq A) n (a) ^+	        end)	       :	       (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	        inj (succ_seq A) n0 (a) ^+) m o A _f p ==	       (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	        inj (succ_seq A) n0 (a) ^+) n	   |} o colim_succ_seq_to_colim_seq A == idmap	";
            responses[i]=data;
          

            i = 158;
            data = "1 goal (ID 263)	  	  A : Sequence	  ============================	  Colimit_rec (Colimit (succ_seq A))	    {|	      legs :=	        fun (n : Graph.graph0 sequence_graph) (a : A n) =>	        inj (succ_seq A) n (a) ^+;	      legs_comm :=	        fun (n m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n m) =>	        (fun a : A n =>	         match	           p as p0 in (_ = y)	           return	             (inj (succ_seq A) y ((A _f p0) a) ^+ = inj (succ_seq A) n (a) ^+)	         with	         | 1 => glue (succ_seq A) n (a) ^+	         end)	        :	        (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	         inj (succ_seq A) n0 (a) ^+) m o A _f p ==	        (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	         inj (succ_seq A) n0 (a) ^+) n	    |} o colim_succ_seq_to_colim_seq A == idmap	2 goals (ID 425)	  	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (succ_seq A) =>	   Colimit_rec (Colimit (succ_seq A))	     {|	       legs :=	         fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	         inj (succ_seq A) n0 (a) ^+;	       legs_comm :=	         fun (n0 m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n0 m) =>	         (fun a : A n0 =>	          match	            p as p0 in (_ = y)	            return	              (inj (succ_seq A) y ((A _f p0) a) ^+ =	               inj (succ_seq A) n0 (a) ^+)	          with	          | 1 => glue (succ_seq A) n0 (a) ^+	          end)	         :	         (fun (n1 : Graph.graph0 sequence_graph) (a : A n1) =>	          inj (succ_seq A) n1 (a) ^+) m o A _f p ==	         (fun (n1 : Graph.graph0 sequence_graph) (a : A n1) =>	          inj (succ_seq A) n1 (a) ^+) n0	     |} (colim_succ_seq_to_colim_seq A x)) o inj (succ_seq A) n ==	  idmap o inj (succ_seq A) n		goal 2 (ID 427) is:	 forall (n : Graph.graph0 sequence_graph) (a : succ_seq A n),	 ap	   (fun x : Colimit (succ_seq A) =>	    Colimit_rec (Colimit (succ_seq A))	      {|	        legs :=	          fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	          inj (succ_seq A) n0 (a0) ^+;	        legs_comm :=	          fun (n0 m : Graph.graph0 sequence_graph)	            (p : Graph.graph1 sequence_graph n0 m) =>	          (fun a0 : A n0 =>	           match	             p as p0 in (_ = y)	             return	               (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                inj (succ_seq A) n0 (a0) ^+)	           with	           | 1 => glue (succ_seq A) n0 (a0) ^+	           end)	          :	          (fun (n1 : Graph.graph0 sequence_graph) (a0 : A n1) =>	           inj (succ_seq A) n1 (a0) ^+) m o A _f p ==	          (fun (n1 : Graph.graph0 sequence_graph) (a0 : A n1) =>	           inj (succ_seq A) n1 (a0) ^+) n0	      |} (colim_succ_seq_to_colim_seq A x)) (glue (succ_seq A) n a) @ 	 ?h n a = ?h n.+1 (a) ^+ @ ap idmap (glue (succ_seq A) n a)	";
            responses[i]=data;
          

            i = 159;
            data = "1 goal (ID 425)	  	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (succ_seq A) =>	   Colimit_rec (Colimit (succ_seq A))	     {|	       legs :=	         fun (n0 : Graph.graph0 sequence_graph) (a : A n0) =>	         inj (succ_seq A) n0 (a) ^+;	       legs_comm :=	         fun (n0 m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n0 m) =>	         (fun a : A n0 =>	          match	            p as p0 in (_ = y)	            return	              (inj (succ_seq A) y ((A _f p0) a) ^+ =	               inj (succ_seq A) n0 (a) ^+)	          with	          | 1 => glue (succ_seq A) n0 (a) ^+	          end)	         :	         (fun (n1 : Graph.graph0 sequence_graph) (a : A n1) =>	          inj (succ_seq A) n1 (a) ^+) m o A _f p ==	         (fun (n1 : Graph.graph0 sequence_graph) (a : A n1) =>	          inj (succ_seq A) n1 (a) ^+) n0	     |} (colim_succ_seq_to_colim_seq A x)) o inj (succ_seq A) n ==	  idmap o inj (succ_seq A) n	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 goal		goal 1 (ID 427) is:	 forall (n : Graph.graph0 sequence_graph) (a : succ_seq A n),	 ap	   (fun x : Colimit (succ_seq A) =>	    Colimit_rec (Colimit (succ_seq A))	      {|	        legs :=	          fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	          inj (succ_seq A) n0 (a0) ^+;	        legs_comm :=	          fun (n0 m : Graph.graph0 sequence_graph)	            (p : Graph.graph1 sequence_graph n0 m) =>	          (fun a0 : A n0 =>	           match	             p as p0 in (_ = y)	             return	               (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                inj (succ_seq A) n0 (a0) ^+)	           with	           | 1 => glue (succ_seq A) n0 (a0) ^+	           end)	          :	          (fun (n1 : Graph.graph0 sequence_graph) (a0 : A n1) =>	           inj (succ_seq A) n1 (a0) ^+) m o A _f p ==	          (fun (n1 : Graph.graph0 sequence_graph) (a0 : A n1) =>	           inj (succ_seq A) n1 (a0) ^+) n0	      |} (colim_succ_seq_to_colim_seq A x)) (glue (succ_seq A) n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : succ_seq A n0) =>	  glue (succ_seq A) n0 a0) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : succ_seq A n0) =>	  glue (succ_seq A) n0 a0) n.+1 (a) ^+ @ ap idmap (glue (succ_seq A) n a)	";
            responses[i]=data;
          

            i = 160;
            data = "1 goal (ID 427)	  	  A : Sequence	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : succ_seq A n),	  ap	    (fun x : Colimit (succ_seq A) =>	     Colimit_rec (Colimit (succ_seq A))	       {|	         legs :=	           fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	           inj (succ_seq A) n0 (a0) ^+;	         legs_comm :=	           fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) =>	           (fun a0 : A n0 =>	            match	              p as p0 in (_ = y)	              return	                (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                 inj (succ_seq A) n0 (a0) ^+)	            with	            | 1 => glue (succ_seq A) n0 (a0) ^+	            end)	           :	           (fun (n1 : Graph.graph0 sequence_graph) (a0 : A n1) =>	            inj (succ_seq A) n1 (a0) ^+) m o A _f p ==	           (fun (n1 : Graph.graph0 sequence_graph) (a0 : A n1) =>	            inj (succ_seq A) n1 (a0) ^+) n0	       |} (colim_succ_seq_to_colim_seq A x)) (glue (succ_seq A) n a) @	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : succ_seq A n0) =>	   glue (succ_seq A) n0 a0) n a =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : succ_seq A n0) =>	   glue (succ_seq A) n0 a0) n.+1 (a) ^+ @ ap idmap (glue (succ_seq A) n a)	1 goal (ID 453)	  	  A : Sequence	  n : Graph.graph0 sequence_graph	  a : succ_seq A n	  ============================	  ap	    (Colimit_rec (Colimit (succ_seq A))	       {|	         legs :=	           fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	           inj (succ_seq A) n0 (a0) ^+;	         legs_comm :=	           fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (a0 : A n0) =>	           match	             p as p0 in (_ = y)	             return	               (inj (succ_seq A) y ((A _f p0) a0) ^+ =	                inj (succ_seq A) n0 (a0) ^+)	           with	           | 1 => colimp n0 n0.+1 1 (a0) ^+	           end	       |})	    (legs_comm	       {|	         legs :=	           fun (n0 : Graph.graph0 sequence_graph) (a0 : succ_seq A n0) =>	           inj A n0.+1 a0;	         legs_comm :=	           fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) =>	           match	             p as p0 in (_ = y)	             return	               ((fun x : succ_seq A n0 => inj A y.+1 (((succ_seq A) _f p0) x)) ==	                (fun a0 : succ_seq A n0 => inj A n0.+1 a0))	           with	           | 1 => colimp n0.+1 n0.+2 1	           end	       |} n n.+1 1 a) @ colimp n n.+1 1 a =	  colimp n.+1 n.+2 1 (a) ^+ @ colimp n n.+1 1 a	";
            responses[i]=data;
          

            i = 161;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 162;
            data = "";
            responses[i]=data;
          

            i = 163;
            data = "<infomsg>equiv_colim_succ_seq_to_colim_seq is defined</infomsg>	";
            responses[i]=data;
          

            i = 164;
            data = "";
            responses[i]=data;
          

            i = 165;
            data = "";
            responses[i]=data;
          

            i = 166;
            data = "";
            responses[i]=data;
          

            i = 167;
            data = "";
            responses[i]=data;
          

            i = 168;
            data = "1 goal (ID 249)	  	  A : Sequence	  n : nat	  ============================	  Colimit (shift_seq A n) -> Colimit A	";
            responses[i]=data;
          

            i = 169;
            data = "";
            responses[i]=data;
          

            i = 170;
            data = "2 goals (ID 279)	  	  A : Sequence	  n : nat	  ============================	  forall i : Graph.graph0 sequence_graph, shift_seq A n i -> Colimit A		goal 2 (ID 281) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 ?legs j o (shift_seq A n) _f g == ?legs i	";
            responses[i]=data;
          

            i = 171;
            data = "1 goal (ID 279)	  	  A : Sequence	  n : nat	  ============================	  forall i : Graph.graph0 sequence_graph, shift_seq A n i -> Colimit A	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 281) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (k : Graph.graph0 sequence_graph) (a : shift_seq A n k) =>	  inj A (k + n) a) j o (shift_seq A n) _f g ==	 (fun (k : Graph.graph0 sequence_graph) (a : shift_seq A n k) =>	  inj A (k + n) a) i	";
            responses[i]=data;
          

            i = 172;
            data = "1 goal (ID 281)	  	  A : Sequence	  n : nat	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (k : Graph.graph0 sequence_graph) (a : shift_seq A n k) =>	   inj A (k + n) a) j o (shift_seq A n) _f g ==	  (fun (k : Graph.graph0 sequence_graph) (a : shift_seq A n k) =>	   inj A (k + n) a) i	No more goals.	";
            responses[i]=data;
          

            i = 173;
            data = "";
            responses[i]=data;
          

            i = 174;
            data = "1 goal (ID 270)	  	  A : Sequence	  n : nat	  k : Graph.graph0 sequence_graph	  a : shift_seq A n k	  ============================	  ap (colim_shift_seq_to_colim_seq A n) (glue (shift_seq A n) k a) =	  glue A (k + n) a	";
            responses[i]=data;
          

            i = 175;
            data = "";
            responses[i]=data;
          

            i = 176;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 177;
            data = "";
            responses[i]=data;
          

            i = 178;
            data = "1 goal (ID 304)	  	  A : Sequence	  n : nat	  k : Graph.graph0 sequence_graph	  a1, a2 : shift_seq A n k	  p : a1 = a2	  ============================	  ap (colim_shift_seq_to_colim_seq A n) (ap (inj (shift_seq A n) k) p) =	  ap (inj A (k + n)) p	";
            responses[i]=data;
          

            i = 179;
            data = "";
            responses[i]=data;
          

            i = 180;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 181;
            data = "";
            responses[i]=data;
          

            i = 182;
            data = "1 goal (ID 336)	  	  X : Type	  Y : X -> Type	  Z : Type	  x1, x2 : X	  y : Y x2	  I : forall x : X, Y x -> Z	  p : x1 = x2	  ============================	  I x2 y = I x1 (coe (ap Y p^) y)	";
            responses[i]=data;
          

            i = 183;
            data = "";
            responses[i]=data;
          

            i = 184;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 185;
            data = "";
            responses[i]=data;
          

            i = 186;
            data = "1 goal (ID 389)	  	  X : Type	  Y : X -> Type	  x1, x2 : X	  y : Y x1	  F : X -> X	  G : forall x : X, Y x -> Y (F x)	  p : x1 = x2	  ============================	  G x2 (coe (ap Y p) y) = coe (ap Y (ap F p)) (G x1 y)	";
            responses[i]=data;
          

            i = 187;
            data = "";
            responses[i]=data;
          

            i = 188;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 189;
            data = "";
            responses[i]=data;
          

            i = 190;
            data = "1 goal (ID 520)	  	  X : Type	  Y : X -> Type	  Z : Type	  x1, x2 : X	  y : Y x2	  F : X -> X	  G : forall x : X, Y x -> Y (F x)	  I : forall x : X, Y x -> Z	  p : x1 = x2	  Q : forall (x : X) (y : Y x), I (F x) (G x y) = I x y	  ============================	  Q x2 y @ J p =	  J (ap F p) @	  (ap (I (F x1)) (K F G p^ @ ap10 (ap coe (ap (ap Y) (ap_V F p))) (G x2 y))^ @	   Q x1 (coe (ap Y p^) y))	";
            responses[i]=data;
          

            i = 191;
            data = "";
            responses[i]=data;
          

            i = 192;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 193;
            data = "";
            responses[i]=data;
          

            i = 194;
            data = "1 goal (ID 528)	  	  H : Funext	  A : Sequence	  n : nat	  ============================	  IsEquiv (colim_shift_seq_to_colim_seq A n)	";
            responses[i]=data;
          

            i = 195;
            data = "";
            responses[i]=data;
          

            i = 196;
            data = "4 goals (ID 551)	  	  H : Funext	  A : Sequence	  ============================	  Colimit (shift_seq A 0) <~> Colimit A		goal 2 (ID 555) is:	 ?f == colim_shift_seq_to_colim_seq A 0	goal 3 (ID 571) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	goal 4 (ID 575) is:	 ?f0 == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 197;
            data = "1 goal (ID 551)	  	  H : Funext	  A : Sequence	  ============================	  Colimit (shift_seq A 0) <~> Colimit A	2 goals (ID 661)	  	  H : Funext	  A : Sequence	  ============================	  DiagramMap (shift_seq A 0) A		goal 2 (ID 663) is:	 forall i : Graph.graph0 sequence_graph, IsEquiv (?m i)	";
            responses[i]=data;
          

            i = 198;
            data = "1 goal (ID 661)	  	  H : Funext	  A : Sequence	  ============================	  DiagramMap (shift_seq A 0) A	2 goals (ID 704)	  	  H : Funext	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, shift_seq A 0 i -> A i		goal 2 (ID 706) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : shift_seq A 0 i),	 (A _f g) (?DiagramMap_obj i x) =	 ?DiagramMap_obj j (((shift_seq A 0) _f g) x)	";
            responses[i]=data;
          

            i = 199;
            data = "1 goal (ID 704)	  	  H : Funext	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, shift_seq A 0 i -> A i	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	5 goals		goal 1 (ID 706) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : shift_seq A 0 i),	 (A _f g)	   ((fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_O k)^)) i x) =	 (fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_O k)^)) j	   (((shift_seq A 0) _f g) x)	goal 2 (ID 663) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_O k)^);	      DiagramMap_comm := ?DiagramMap_comm	    |} i)	goal 3 (ID 555) is:	 equiv_functor_colimit	   {|	     diag_equiv_map :=	       {|	         DiagramMap_obj :=	           fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_O k)^);	         DiagramMap_comm := ?DiagramMap_comm	       |};	     diag_equiv_isequiv := ?H	   |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A) ==	 colim_shift_seq_to_colim_seq A 0	goal 4 (ID 571) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	goal 5 (ID 575) is:	 ?f == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 200;
            data = "1 goal (ID 706)	  	  H : Funext	  A : Sequence	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : shift_seq A 0 i),	  (A _f g)	    ((fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_O k)^)) i x) =	  (fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_O k)^)) j	    (((shift_seq A 0) _f g) x)	1 goal (ID 751)	  	  H : Funext	  A : Sequence	  k : Graph.graph0 sequence_graph	  a : shift_seq A 0 k	  ============================	  coe (ap A (ap S (nat_add_n_O k)^))	    ((fun (n : nat) (a0 : A n) => (a0) ^+) (k + 0) a) =	  coe (ap A (nat_add_n_O k.+1)^) (a) ^+	";
            responses[i]=data;
          

            i = 201;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	4 goals		goal 1 (ID 663) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_O k)^);	      DiagramMap_comm :=	        fun (k l : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph k l) (a : shift_seq A 0 k) =>	        match	          p as p0 in (_ = y)	          return	            ((A _f p0) (coe (ap A (nat_add_n_O k)^) a) =	             coe (ap A (nat_add_n_O y)^) (((shift_seq A 0) _f p0) a))	        with	        | 1 =>	            K S (fun (n : nat) (a0 : A n) => (a0) ^+) (nat_add_n_O k)^ @	            ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_O k)))) (a) ^+	        end	    |} i)	goal 2 (ID 555) is:	 equiv_functor_colimit	   {|	     diag_equiv_map :=	       {|	         DiagramMap_obj :=	           fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_O k)^);	         DiagramMap_comm :=	           fun (k l : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph k l) 	             (a : shift_seq A 0 k) =>	           match	             p as p0 in (_ = y)	             return	               ((A _f p0) (coe (ap A (nat_add_n_O k)^) a) =	                coe (ap A (nat_add_n_O y)^) (((shift_seq A 0) _f p0) a))	           with	           | 1 =>	               K S (fun (n : nat) (a0 : A n) => (a0) ^+) (nat_add_n_O k)^ @	               ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_O k)))) (a) ^+	           end	       |};	     diag_equiv_isequiv := ?H	   |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A) ==	 colim_shift_seq_to_colim_seq A 0	goal 3 (ID 571) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	goal 4 (ID 575) is:	 ?f == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 202;
            data = "1 goal (ID 663)	  	  H : Funext	  A : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph,	  IsEquiv	    ({|	       DiagramMap_obj :=	         fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_O k)^);	       DiagramMap_comm :=	         fun (k l : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph k l) (a : shift_seq A 0 k) =>	         match	           p as p0 in (_ = y)	           return	             ((A _f p0) (coe (ap A (nat_add_n_O k)^) a) =	              coe (ap A (nat_add_n_O y)^) (((shift_seq A 0) _f p0) a))	         with	         | 1 =>	             K S (fun (n : nat) (a0 : A n) => (a0) ^+) (nat_add_n_O k)^ @	             ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_O k)))) (a) ^+	         end	     |} i)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 goals		goal 1 (ID 555) is:	 equiv_functor_colimit	   {|	     diag_equiv_map :=	       {|	         DiagramMap_obj :=	           fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_O k)^);	         DiagramMap_comm :=	           fun (k l : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph k l) 	             (a : shift_seq A 0 k) =>	           match	             p as p0 in (_ = y)	             return	               ((A _f p0) (coe (ap A (nat_add_n_O k)^) a) =	                coe (ap A (nat_add_n_O y)^) (((shift_seq A 0) _f p0) a))	           with	           | 1 =>	               K S (fun (n : nat) (a0 : A n) => (a0) ^+) (nat_add_n_O k)^ @	               ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_O k)))) (a) ^+	           end	       |};	     diag_equiv_isequiv :=	       fun k : Graph.graph0 sequence_graph =>	       isequiv_path (ap A (nat_add_n_O k)^)	   |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A) ==	 colim_shift_seq_to_colim_seq A 0	goal 2 (ID 571) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	goal 3 (ID 575) is:	 ?f == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 203;
            data = "1 goal (ID 555)	  	  H : Funext	  A : Sequence	  ============================	  equiv_functor_colimit	    {|	      diag_equiv_map :=	        {|	          DiagramMap_obj :=	            fun k : Graph.graph0 sequence_graph =>	            coe (ap A (nat_add_n_O k)^);	          DiagramMap_comm :=	            fun (k l : Graph.graph0 sequence_graph)	              (p : Graph.graph1 sequence_graph k l) 	              (a : shift_seq A 0 k) =>	            match	              p as p0 in (_ = y)	              return	                ((A _f p0) (coe (ap A (nat_add_n_O k)^) a) =	                 coe (ap A (nat_add_n_O y)^) (((shift_seq A 0) _f p0) a))	            with	            | 1 =>	                K S (fun (n : nat) (a0 : A n) => (a0) ^+) (nat_add_n_O k)^ @	                ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_O k)))) (a) ^+	            end	        |};	      diag_equiv_isequiv :=	        fun k : Graph.graph0 sequence_graph =>	        isequiv_path (ap A (nat_add_n_O k)^)	    |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A) ==	  colim_shift_seq_to_colim_seq A 0	2 goals (ID 864)	  	  H : Funext	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  colim_shift_seq_to_colim_seq A 0 o inj (shift_seq A 0) n ==	  equiv_functor_colimit	    {|	      diag_equiv_map :=	        {|	          DiagramMap_obj :=	            fun k : Graph.graph0 sequence_graph =>	            coe (ap A (nat_add_n_O k)^);	          DiagramMap_comm :=	            fun (k l : Graph.graph0 sequence_graph)	              (p : Graph.graph1 sequence_graph k l) 	              (a : shift_seq A 0 k) =>	            match	              p as p0 in (_ = y)	              return	                ((A _f p0) (coe (ap A (nat_add_n_O k)^) a) =	                 coe (ap A (nat_add_n_O y)^) (((shift_seq A 0) _f p0) a))	            with	            | 1 =>	                K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+) (nat_add_n_O k)^ @	                ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_O k)))) (a) ^+	            end	        |};	      diag_equiv_isequiv :=	        fun k : Graph.graph0 sequence_graph =>	        isequiv_path (ap A (nat_add_n_O k)^)	    |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A)	  o inj (shift_seq A 0) n		goal 2 (ID 866) is:	 forall (n : Graph.graph0 sequence_graph) (a : shift_seq A 0 n),	 ap (colim_shift_seq_to_colim_seq A 0) (glue (shift_seq A 0) n a) @ ?h0 n a =	 ?h0 n.+1 (a) ^+ @	 ap	   (equiv_functor_colimit	      {|	        diag_equiv_map :=	          {|	            DiagramMap_obj :=	              fun k : Graph.graph0 sequence_graph =>	              coe (ap A (nat_add_n_O k)^);	            DiagramMap_comm :=	              fun (k l : Graph.graph0 sequence_graph)	                (p : Graph.graph1 sequence_graph k l) 	                (a0 : shift_seq A 0 k) =>	              match	                p as p0 in (_ = y)	                return	                  ((A _f p0) (coe (ap A (nat_add_n_O k)^) a0) =	                   coe (ap A (nat_add_n_O y)^) (((shift_seq A 0) _f p0) a0))	              with	              | 1 =>	                  K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                    (nat_add_n_O k)^ @	                  ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_O k)))) (a0) ^+	              end	          |};	        diag_equiv_isequiv :=	          fun k : Graph.graph0 sequence_graph =>	          isequiv_path (ap A (nat_add_n_O k)^)	      |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A))	   (glue (shift_seq A 0) n a)	";
            responses[i]=data;
          

            i = 204;
            data = "1 goal (ID 864)	  	  H : Funext	  A : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  colim_shift_seq_to_colim_seq A 0 o inj (shift_seq A 0) n ==	  equiv_functor_colimit	    {|	      diag_equiv_map :=	        {|	          DiagramMap_obj :=	            fun k : Graph.graph0 sequence_graph =>	            coe (ap A (nat_add_n_O k)^);	          DiagramMap_comm :=	            fun (k l : Graph.graph0 sequence_graph)	              (p : Graph.graph1 sequence_graph k l) 	              (a : shift_seq A 0 k) =>	            match	              p as p0 in (_ = y)	              return	                ((A _f p0) (coe (ap A (nat_add_n_O k)^) a) =	                 coe (ap A (nat_add_n_O y)^) (((shift_seq A 0) _f p0) a))	            with	            | 1 =>	                K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+) (nat_add_n_O k)^ @	                ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_O k)))) (a) ^+	            end	        |};	      diag_equiv_isequiv :=	        fun k : Graph.graph0 sequence_graph =>	        isequiv_path (ap A (nat_add_n_O k)^)	    |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A)	  o inj (shift_seq A 0) n	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 goals		goal 1 (ID 866) is:	 forall (n : Graph.graph0 sequence_graph) (a : shift_seq A 0 n),	 ap (colim_shift_seq_to_colim_seq A 0) (glue (shift_seq A 0) n a) @	 (fun k : Graph.graph0 sequence_graph =>	  (fun a0 : shift_seq A 0 k => J (nat_add_n_O k))	  :	  colim_shift_seq_to_colim_seq A 0 o inj (shift_seq A 0) k ==	  equiv_functor_colimit	    {|	      diag_equiv_map :=	        {|	          DiagramMap_obj :=	            fun k0 : Graph.graph0 sequence_graph =>	            coe (ap A (nat_add_n_O k0)^);	          DiagramMap_comm :=	            fun (k0 l : Graph.graph0 sequence_graph)	              (p : Graph.graph1 sequence_graph k0 l) 	              (a0 : shift_seq A 0 k0) =>	            match	              p as p0 in (_ = y)	              return	                ((A _f p0) (coe (ap A (nat_add_n_O k0)^) a0) =	                 coe (ap A (nat_add_n_O y)^) (((shift_seq A 0) _f p0) a0))	            with	            | 1 =>	                K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+) (nat_add_n_O k0)^ @	                ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_O k0)))) (a0) ^+	            end	        |};	      diag_equiv_isequiv :=	        fun k0 : Graph.graph0 sequence_graph =>	        isequiv_path (ap A (nat_add_n_O k0)^)	    |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A)	  o inj (shift_seq A 0) k) n a =	 (fun k : Graph.graph0 sequence_graph =>	  (fun a0 : shift_seq A 0 k => J (nat_add_n_O k))	  :	  colim_shift_seq_to_colim_seq A 0 o inj (shift_seq A 0) k ==	  equiv_functor_colimit	    {|	      diag_equiv_map :=	        {|	          DiagramMap_obj :=	            fun k0 : Graph.graph0 sequence_graph =>	            coe (ap A (nat_add_n_O k0)^);	          DiagramMap_comm :=	            fun (k0 l : Graph.graph0 sequence_graph)	              (p : Graph.graph1 sequence_graph k0 l) 	              (a0 : shift_seq A 0 k0) =>	            match	              p as p0 in (_ = y)	              return	                ((A _f p0) (coe (ap A (nat_add_n_O k0)^) a0) =	                 coe (ap A (nat_add_n_O y)^) (((shift_seq A 0) _f p0) a0))	            with	            | 1 =>	                K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+) (nat_add_n_O k0)^ @	                ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_O k0)))) (a0) ^+	            end	        |};	      diag_equiv_isequiv :=	        fun k0 : Graph.graph0 sequence_graph =>	        isequiv_path (ap A (nat_add_n_O k0)^)	    |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A)	  o inj (shift_seq A 0) k) n.+1 (a) ^+ @	 ap	   (equiv_functor_colimit	      {|	        diag_equiv_map :=	          {|	            DiagramMap_obj :=	              fun k : Graph.graph0 sequence_graph =>	              coe (ap A (nat_add_n_O k)^);	            DiagramMap_comm :=	              fun (k l : Graph.graph0 sequence_graph)	                (p : Graph.graph1 sequence_graph k l) 	                (a0 : shift_seq A 0 k) =>	              match	                p as p0 in (_ = y)	                return	                  ((A _f p0) (coe (ap A (nat_add_n_O k)^) a0) =	                   coe (ap A (nat_add_n_O y)^) (((shift_seq A 0) _f p0) a0))	              with	              | 1 =>	                  K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                    (nat_add_n_O k)^ @	                  ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_O k)))) (a0) ^+	              end	          |};	        diag_equiv_isequiv :=	          fun k : Graph.graph0 sequence_graph =>	          isequiv_path (ap A (nat_add_n_O k)^)	      |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A))	   (glue (shift_seq A 0) n a)	goal 2 (ID 571) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	goal 3 (ID 575) is:	 ?f == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 205;
            data = "1 goal (ID 866)	  	  H : Funext	  A : Sequence	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : shift_seq A 0 n),	  ap (colim_shift_seq_to_colim_seq A 0) (glue (shift_seq A 0) n a) @	  (fun k : Graph.graph0 sequence_graph =>	   (fun a0 : shift_seq A 0 k => J (nat_add_n_O k))	   :	   colim_shift_seq_to_colim_seq A 0 o inj (shift_seq A 0) k ==	   equiv_functor_colimit	     {|	       diag_equiv_map :=	         {|	           DiagramMap_obj :=	             fun k0 : Graph.graph0 sequence_graph =>	             coe (ap A (nat_add_n_O k0)^);	           DiagramMap_comm :=	             fun (k0 l : Graph.graph0 sequence_graph)	               (p : Graph.graph1 sequence_graph k0 l) 	               (a0 : shift_seq A 0 k0) =>	             match	               p as p0 in (_ = y)	               return	                 ((A _f p0) (coe (ap A (nat_add_n_O k0)^) a0) =	                  coe (ap A (nat_add_n_O y)^) (((shift_seq A 0) _f p0) a0))	             with	             | 1 =>	                 K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                   (nat_add_n_O k0)^ @	                 ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_O k0)))) (a0) ^+	             end	         |};	       diag_equiv_isequiv :=	         fun k0 : Graph.graph0 sequence_graph =>	         isequiv_path (ap A (nat_add_n_O k0)^)	     |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A)	   o inj (shift_seq A 0) k) n a =	  (fun k : Graph.graph0 sequence_graph =>	   (fun a0 : shift_seq A 0 k => J (nat_add_n_O k))	   :	   colim_shift_seq_to_colim_seq A 0 o inj (shift_seq A 0) k ==	   equiv_functor_colimit	     {|	       diag_equiv_map :=	         {|	           DiagramMap_obj :=	             fun k0 : Graph.graph0 sequence_graph =>	             coe (ap A (nat_add_n_O k0)^);	           DiagramMap_comm :=	             fun (k0 l : Graph.graph0 sequence_graph)	               (p : Graph.graph1 sequence_graph k0 l) 	               (a0 : shift_seq A 0 k0) =>	             match	               p as p0 in (_ = y)	               return	                 ((A _f p0) (coe (ap A (nat_add_n_O k0)^) a0) =	                  coe (ap A (nat_add_n_O y)^) (((shift_seq A 0) _f p0) a0))	             with	             | 1 =>	                 K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                   (nat_add_n_O k0)^ @	                 ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_O k0)))) (a0) ^+	             end	         |};	       diag_equiv_isequiv :=	         fun k0 : Graph.graph0 sequence_graph =>	         isequiv_path (ap A (nat_add_n_O k0)^)	     |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A)	   o inj (shift_seq A 0) k) n.+1 (a) ^+ @	  ap	    (equiv_functor_colimit	       {|	         diag_equiv_map :=	           {|	             DiagramMap_obj :=	               fun k : Graph.graph0 sequence_graph =>	               coe (ap A (nat_add_n_O k)^);	             DiagramMap_comm :=	               fun (k l : Graph.graph0 sequence_graph)	                 (p : Graph.graph1 sequence_graph k l) 	                 (a0 : shift_seq A 0 k) =>	               match	                 p as p0 in (_ = y)	                 return	                   ((A _f p0) (coe (ap A (nat_add_n_O k)^) a0) =	                    coe (ap A (nat_add_n_O y)^) (((shift_seq A 0) _f p0) a0))	               with	               | 1 =>	                   K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                     (nat_add_n_O k)^ @	                   ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_O k)))) (a0) ^+	               end	           |};	         diag_equiv_isequiv :=	           fun k : Graph.graph0 sequence_graph =>	           isequiv_path (ap A (nat_add_n_O k)^)	       |} (iscolimit_colimit (shift_seq A 0)) (iscolimit_colimit A))	    (glue (shift_seq A 0) n a)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 571) is:	 Colimit (shift_seq A n.+1) <~> Colimit A	goal 2 (ID 575) is:	 ?f == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 206;
            data = "1 goal (ID 571)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  Colimit (shift_seq A n.+1) <~> Colimit A	2 goals (ID 915)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  Colimit (shift_seq A n.+1) <~> Colimit (succ_seq (shift_seq A n))		goal 2 (ID 916) is:	 Colimit (succ_seq (shift_seq A n)) <~> Colimit A	";
            responses[i]=data;
          

            i = 207;
            data = "1 goal (ID 915)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  Colimit (shift_seq A n.+1) <~> Colimit (succ_seq (shift_seq A n))	2 goals (ID 1002)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  DiagramMap (shift_seq A n.+1) (succ_seq (shift_seq A n))		goal 2 (ID 1004) is:	 forall i : Graph.graph0 sequence_graph, IsEquiv (?m i)	";
            responses[i]=data;
          

            i = 208;
            data = "1 goal (ID 1002)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  DiagramMap (shift_seq A n.+1) (succ_seq (shift_seq A n))	2 goals (ID 1045)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall i : Graph.graph0 sequence_graph,	  shift_seq A n.+1 i -> succ_seq (shift_seq A n) i		goal 2 (ID 1047) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : shift_seq A n.+1 i),	 ((succ_seq (shift_seq A n)) _f g) (?DiagramMap_obj i x) =	 ?DiagramMap_obj j (((shift_seq A n.+1) _f g) x)	";
            responses[i]=data;
          

            i = 209;
            data = "1 goal (ID 1045)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall i : Graph.graph0 sequence_graph,	  shift_seq A n.+1 i -> succ_seq (shift_seq A n) i	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	4 goals		goal 1 (ID 1047) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : shift_seq A n.+1 i),	 ((succ_seq (shift_seq A n)) _f g)	   ((fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_Sm k n)^)) i	      x) =	 (fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_Sm k n)^)) j	   (((shift_seq A n.+1) _f g) x)	goal 2 (ID 1004) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_Sm k n)^);	      DiagramMap_comm := ?DiagramMap_comm	    |} i)	goal 3 (ID 916) is:	 Colimit (succ_seq (shift_seq A n)) <~> Colimit A	goal 4 (ID 575) is:	 (fun (x y z : Type) (f : x <~> y) (g : y <~> z) => equiv_compose g f)	   (Colimit (shift_seq A n.+1)) (Colimit (succ_seq (shift_seq A n)))	   (Colimit A)	   (equiv_functor_colimit	      {|	        diag_equiv_map :=	          {|	            DiagramMap_obj :=	              fun k : Graph.graph0 sequence_graph =>	              coe (ap A (nat_add_n_Sm k n)^);	            DiagramMap_comm := ?DiagramMap_comm	          |};	        diag_equiv_isequiv := ?H	      |} (iscolimit_colimit (shift_seq A n.+1))	      (iscolimit_colimit (succ_seq (shift_seq A n)))) 	   ?Goal == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 210;
            data = "1 goal (ID 1047)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : shift_seq A n.+1 i),	  ((succ_seq (shift_seq A n)) _f g)	    ((fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_Sm k n)^))	       i x) =	  (fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_Sm k n)^)) j	    (((shift_seq A n.+1) _f g) x)	1 goal (ID 1047)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : shift_seq A n.+1 i),	  ((succ_seq (shift_seq A n)) _f g)	    ((fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_Sm k n)^))	       i x) =	  (fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_Sm k n)^)) j	    (((shift_seq A n.+1) _f g) x)	1 goal (ID 1093)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  k : Graph.graph0 sequence_graph	  a : shift_seq A n.+1 k	  ============================	  coe (ap A (ap S (nat_add_n_Sm k n)^)) (a) ^+ =	  coe (ap A (nat_add_n_Sm k.+1 n)^) (a) ^+	";
            responses[i]=data;
          

            i = 211;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 goals		goal 1 (ID 1004) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_Sm k n)^);	      DiagramMap_comm :=	        fun (k l : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph k l) (a : shift_seq A n.+1 k) =>	        match	          p as p0 in (_ = y)	          return	            (((succ_seq (shift_seq A n)) _f p0)	               (coe (ap A (nat_add_n_Sm k n)^) a) =	             coe (ap A (nat_add_n_Sm y n)^) (((shift_seq A n.+1) _f p0) a))	        with	        | 1 =>	            K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+) (nat_add_n_Sm k n)^ @	            ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k n)))) (a) ^+	        end	    |} i)	goal 2 (ID 916) is:	 Colimit (succ_seq (shift_seq A n)) <~> Colimit A	goal 3 (ID 575) is:	 (fun (x y z : Type) (f : x <~> y) (g : y <~> z) => equiv_compose g f)	   (Colimit (shift_seq A n.+1)) (Colimit (succ_seq (shift_seq A n)))	   (Colimit A)	   (equiv_functor_colimit	      {|	        diag_equiv_map :=	          {|	            DiagramMap_obj :=	              fun k : Graph.graph0 sequence_graph =>	              coe (ap A (nat_add_n_Sm k n)^);	            DiagramMap_comm :=	              fun (k l : Graph.graph0 sequence_graph)	                (p : Graph.graph1 sequence_graph k l)	                (a : shift_seq A n.+1 k) =>	              match	                p as p0 in (_ = y)	                return	                  (((succ_seq (shift_seq A n)) _f p0)	                     (coe (ap A (nat_add_n_Sm k n)^) a) =	                   coe (ap A (nat_add_n_Sm y n)^)	                     (((shift_seq A n.+1) _f p0) a))	              with	              | 1 =>	                  K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+)	                    (nat_add_n_Sm k n)^ @	                  ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k n))))	                    (a) ^+	              end	          |};	        diag_equiv_isequiv := ?H	      |} (iscolimit_colimit (shift_seq A n.+1))	      (iscolimit_colimit (succ_seq (shift_seq A n)))) 	   ?Goal == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 212;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 goals		goal 1 (ID 1004) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun k : Graph.graph0 sequence_graph => coe (ap A (nat_add_n_Sm k n)^);	      DiagramMap_comm :=	        fun (k l : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph k l) (a : shift_seq A n.+1 k) =>	        match	          p as p0 in (_ = y)	          return	            (((succ_seq (shift_seq A n)) _f p0)	               (coe (ap A (nat_add_n_Sm k n)^) a) =	             coe (ap A (nat_add_n_Sm y n)^) (((shift_seq A n.+1) _f p0) a))	        with	        | 1 =>	            K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+) (nat_add_n_Sm k n)^ @	            ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k n)))) (a) ^+	        end	    |} i)	goal 2 (ID 916) is:	 Colimit (succ_seq (shift_seq A n)) <~> Colimit A	goal 3 (ID 575) is:	 (fun (x y z : Type) (f : x <~> y) (g : y <~> z) => equiv_compose g f)	   (Colimit (shift_seq A n.+1)) (Colimit (succ_seq (shift_seq A n)))	   (Colimit A)	   (equiv_functor_colimit	      {|	        diag_equiv_map :=	          {|	            DiagramMap_obj :=	              fun k : Graph.graph0 sequence_graph =>	              coe (ap A (nat_add_n_Sm k n)^);	            DiagramMap_comm :=	              fun (k l : Graph.graph0 sequence_graph)	                (p : Graph.graph1 sequence_graph k l)	                (a : shift_seq A n.+1 k) =>	              match	                p as p0 in (_ = y)	                return	                  (((succ_seq (shift_seq A n)) _f p0)	                     (coe (ap A (nat_add_n_Sm k n)^) a) =	                   coe (ap A (nat_add_n_Sm y n)^)	                     (((shift_seq A n.+1) _f p0) a))	              with	              | 1 =>	                  K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+)	                    (nat_add_n_Sm k n)^ @	                  ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k n))))	                    (a) ^+	              end	          |};	        diag_equiv_isequiv := ?H	      |} (iscolimit_colimit (shift_seq A n.+1))	      (iscolimit_colimit (succ_seq (shift_seq A n)))) 	   ?Goal == colim_shift_seq_to_colim_seq A n.+1	1 goal (ID 1004)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall i : Graph.graph0 sequence_graph,	  IsEquiv	    ({|	       DiagramMap_obj :=	         fun k : Graph.graph0 sequence_graph =>	         coe (ap A (nat_add_n_Sm k n)^);	       DiagramMap_comm :=	         fun (k l : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph k l) (a : shift_seq A n.+1 k) =>	         match	           p as p0 in (_ = y)	           return	             (((succ_seq (shift_seq A n)) _f p0)	                (coe (ap A (nat_add_n_Sm k n)^) a) =	              coe (ap A (nat_add_n_Sm y n)^) (((shift_seq A n.+1) _f p0) a))	         with	         | 1 =>	             K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+) (nat_add_n_Sm k n)^ @	             ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k n)))) (a) ^+	         end	     |} i)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 916) is:	 Colimit (succ_seq (shift_seq A n)) <~> Colimit A	goal 2 (ID 575) is:	 (fun (x y z : Type) (f : x <~> y) (g : y <~> z) => equiv_compose g f)	   (Colimit (shift_seq A n.+1)) (Colimit (succ_seq (shift_seq A n)))	   (Colimit A)	   (equiv_functor_colimit	      {|	        diag_equiv_map :=	          {|	            DiagramMap_obj :=	              fun k : Graph.graph0 sequence_graph =>	              coe (ap A (nat_add_n_Sm k n)^);	            DiagramMap_comm :=	              fun (k l : Graph.graph0 sequence_graph)	                (p : Graph.graph1 sequence_graph k l)	                (a : shift_seq A n.+1 k) =>	              match	                p as p0 in (_ = y)	                return	                  (((succ_seq (shift_seq A n)) _f p0)	                     (coe (ap A (nat_add_n_Sm k n)^) a) =	                   coe (ap A (nat_add_n_Sm y n)^)	                     (((shift_seq A n.+1) _f p0) a))	              with	              | 1 =>	                  K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+)	                    (nat_add_n_Sm k n)^ @	                  ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k n))))	                    (a) ^+	              end	          |};	        diag_equiv_isequiv :=	          fun k : Graph.graph0 sequence_graph =>	          isequiv_path (ap A (nat_add_n_Sm k n)^)	      |} (iscolimit_colimit (shift_seq A n.+1))	      (iscolimit_colimit (succ_seq (shift_seq A n)))) 	   ?Goal == colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 213;
            data = "1 goal (ID 916)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  Colimit (succ_seq (shift_seq A n)) <~> Colimit A	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 575) is:	 (fun (x y z : Type) (f : x <~> y) (g : y <~> z) => equiv_compose g f)	   (Colimit (shift_seq A n.+1)) (Colimit (succ_seq (shift_seq A n)))	   (Colimit A)	   (equiv_functor_colimit	      {|	        diag_equiv_map :=	          {|	            DiagramMap_obj :=	              fun k : Graph.graph0 sequence_graph =>	              coe (ap A (nat_add_n_Sm k n)^);	            DiagramMap_comm :=	              fun (k l : Graph.graph0 sequence_graph)	                (p : Graph.graph1 sequence_graph k l)	                (a : shift_seq A n.+1 k) =>	              match	                p as p0 in (_ = y)	                return	                  (((succ_seq (shift_seq A n)) _f p0)	                     (coe (ap A (nat_add_n_Sm k n)^) a) =	                   coe (ap A (nat_add_n_Sm y n)^)	                     (((shift_seq A n.+1) _f p0) a))	              with	              | 1 =>	                  K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+)	                    (nat_add_n_Sm k n)^ @	                  ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k n))))	                    (a) ^+	              end	          |};	        diag_equiv_isequiv :=	          fun k : Graph.graph0 sequence_graph =>	          isequiv_path (ap A (nat_add_n_Sm k n)^)	      |} (iscolimit_colimit (shift_seq A n.+1))	      (iscolimit_colimit (succ_seq (shift_seq A n))))	   (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	      {| equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e |}) ==	 colim_shift_seq_to_colim_seq A n.+1	";
            responses[i]=data;
          

            i = 214;
            data = "1 goal (ID 575)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  (fun (x y z : Type) (f : x <~> y) (g : y <~> z) => equiv_compose g f)	    (Colimit (shift_seq A n.+1)) (Colimit (succ_seq (shift_seq A n)))	    (Colimit A)	    (equiv_functor_colimit	       {|	         diag_equiv_map :=	           {|	             DiagramMap_obj :=	               fun k : Graph.graph0 sequence_graph =>	               coe (ap A (nat_add_n_Sm k n)^);	             DiagramMap_comm :=	               fun (k l : Graph.graph0 sequence_graph)	                 (p : Graph.graph1 sequence_graph k l)	                 (a : shift_seq A n.+1 k) =>	               match	                 p as p0 in (_ = y)	                 return	                   (((succ_seq (shift_seq A n)) _f p0)	                      (coe (ap A (nat_add_n_Sm k n)^) a) =	                    coe (ap A (nat_add_n_Sm y n)^)	                      (((shift_seq A n.+1) _f p0) a))	               with	               | 1 =>	                   K S (fun (n0 : nat) (a0 : A n0) => (a0) ^+)	                     (nat_add_n_Sm k n)^ @	                   ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k n))))	                     (a) ^+	               end	           |};	         diag_equiv_isequiv :=	           fun k : Graph.graph0 sequence_graph =>	           isequiv_path (ap A (nat_add_n_Sm k n)^)	       |} (iscolimit_colimit (shift_seq A n.+1))	       (iscolimit_colimit (succ_seq (shift_seq A n))))	    (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	       {|	         equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	       |}) == colim_shift_seq_to_colim_seq A n.+1	2 goals (ID 1222)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall n0 : Graph.graph0 sequence_graph,	  colim_shift_seq_to_colim_seq A n.+1 o inj (shift_seq A n.+1) n0 ==	  (fun (x y z : Type) (f : x <~> y) (g : y <~> z) => equiv_compose g f)	    (Colimit (shift_seq A n.+1)) (Colimit (succ_seq (shift_seq A n)))	    (Colimit A)	    (equiv_functor_colimit	       {|	         diag_equiv_map :=	           {|	             DiagramMap_obj :=	               fun k : Graph.graph0 sequence_graph =>	               coe (ap A (nat_add_n_Sm k n)^);	             DiagramMap_comm :=	               fun (k l : Graph.graph0 sequence_graph)	                 (p : Graph.graph1 sequence_graph k l)	                 (a : shift_seq A n.+1 k) =>	               match	                 p as p0 in (_ = y)	                 return	                   (((succ_seq (shift_seq A n)) _f p0)	                      (coe (ap A (nat_add_n_Sm k n)^) a) =	                    coe (ap A (nat_add_n_Sm y n)^)	                      (((shift_seq A n.+1) _f p0) a))	               with	               | 1 =>	                   K S (fun (n1 : nat) (a0 : A n1) => (a0) ^+)	                     (nat_add_n_Sm k n)^ @	                   ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k n))))	                     (a) ^+	               end	           |};	         diag_equiv_isequiv :=	           fun k : Graph.graph0 sequence_graph =>	           isequiv_path (ap A (nat_add_n_Sm k n)^)	       |} (iscolimit_colimit (shift_seq A n.+1))	       (iscolimit_colimit (succ_seq (shift_seq A n))))	    (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	       {|	         equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	       |}) o inj (shift_seq A n.+1) n0		goal 2 (ID 1224) is:	 forall (n0 : Graph.graph0 sequence_graph) (a : shift_seq A n.+1 n0),	 ap (colim_shift_seq_to_colim_seq A n.+1) (glue (shift_seq A n.+1) n0 a) @	 ?h n0 a =	 ?h n0.+1 (a) ^+ @	 ap	   ((fun (x y z : Type) (f : x <~> y) (g : y <~> z) => equiv_compose g f)	      (Colimit (shift_seq A n.+1)) (Colimit (succ_seq (shift_seq A n)))	      (Colimit A)	      (equiv_functor_colimit	         {|	           diag_equiv_map :=	             {|	               DiagramMap_obj :=	                 fun k : Graph.graph0 sequence_graph =>	                 coe (ap A (nat_add_n_Sm k n)^);	               DiagramMap_comm :=	                 fun (k l : Graph.graph0 sequence_graph)	                   (p : Graph.graph1 sequence_graph k l)	                   (a0 : shift_seq A n.+1 k) =>	                 match	                   p as p0 in (_ = y)	                   return	                     (((succ_seq (shift_seq A n)) _f p0)	                        (coe (ap A (nat_add_n_Sm k n)^) a0) =	                      coe (ap A (nat_add_n_Sm y n)^)	                        (((shift_seq A n.+1) _f p0) a0))	                 with	                 | 1 =>	                     K S (fun (n1 : nat) (a1 : A n1) => (a1) ^+)	                       (nat_add_n_Sm k n)^ @	                     ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k n))))	                       (a0) ^+	                 end	             |};	           diag_equiv_isequiv :=	             fun k : Graph.graph0 sequence_graph =>	             isequiv_path (ap A (nat_add_n_Sm k n)^)	         |} (iscolimit_colimit (shift_seq A n.+1))	         (iscolimit_colimit (succ_seq (shift_seq A n))))	      (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	         {|	           equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	         |})) (glue (shift_seq A n.+1) n0 a)	";
            responses[i]=data;
          

            i = 215;
            data = "1 goal (ID 1222)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall n0 : Graph.graph0 sequence_graph,	  colim_shift_seq_to_colim_seq A n.+1 o inj (shift_seq A n.+1) n0 ==	  (fun (x y z : Type) (f : x <~> y) (g : y <~> z) => equiv_compose g f)	    (Colimit (shift_seq A n.+1)) (Colimit (succ_seq (shift_seq A n)))	    (Colimit A)	    (equiv_functor_colimit	       {|	         diag_equiv_map :=	           {|	             DiagramMap_obj :=	               fun k : Graph.graph0 sequence_graph =>	               coe (ap A (nat_add_n_Sm k n)^);	             DiagramMap_comm :=	               fun (k l : Graph.graph0 sequence_graph)	                 (p : Graph.graph1 sequence_graph k l)	                 (a : shift_seq A n.+1 k) =>	               match	                 p as p0 in (_ = y)	                 return	                   (((succ_seq (shift_seq A n)) _f p0)	                      (coe (ap A (nat_add_n_Sm k n)^) a) =	                    coe (ap A (nat_add_n_Sm y n)^)	                      (((shift_seq A n.+1) _f p0) a))	               with	               | 1 =>	                   K S (fun (n1 : nat) (a0 : A n1) => (a0) ^+)	                     (nat_add_n_Sm k n)^ @	                   ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k n))))	                     (a) ^+	               end	           |};	         diag_equiv_isequiv :=	           fun k : Graph.graph0 sequence_graph =>	           isequiv_path (ap A (nat_add_n_Sm k n)^)	       |} (iscolimit_colimit (shift_seq A n.+1))	       (iscolimit_colimit (succ_seq (shift_seq A n))))	    (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	       {|	         equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	       |}) o inj (shift_seq A n.+1) n0	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 1224) is:	 forall (n0 : Graph.graph0 sequence_graph) (a : shift_seq A n.+1 n0),	 ap (colim_shift_seq_to_colim_seq A n.+1) (glue (shift_seq A n.+1) n0 a) @	 (fun k : Graph.graph0 sequence_graph =>	  (fun a0 : shift_seq A n.+1 k => J (nat_add_n_Sm k n))	  :	  colim_shift_seq_to_colim_seq A n.+1 o inj (shift_seq A n.+1) k ==	  (fun (x y z : Type) (f : x <~> y) (g : y <~> z) => equiv_compose g f)	    (Colimit (shift_seq A n.+1)) (Colimit (succ_seq (shift_seq A n)))	    (Colimit A)	    (equiv_functor_colimit	       {|	         diag_equiv_map :=	           {|	             DiagramMap_obj :=	               fun k0 : Graph.graph0 sequence_graph =>	               coe (ap A (nat_add_n_Sm k0 n)^);	             DiagramMap_comm :=	               fun (k0 l : Graph.graph0 sequence_graph)	                 (p : Graph.graph1 sequence_graph k0 l)	                 (a0 : shift_seq A n.+1 k0) =>	               match	                 p as p0 in (_ = y)	                 return	                   (((succ_seq (shift_seq A n)) _f p0)	                      (coe (ap A (nat_add_n_Sm k0 n)^) a0) =	                    coe (ap A (nat_add_n_Sm y n)^)	                      (((shift_seq A n.+1) _f p0) a0))	               with	               | 1 =>	                   K S (fun (n1 : nat) (a1 : A n1) => (a1) ^+)	                     (nat_add_n_Sm k0 n)^ @	                   ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k0 n))))	                     (a0) ^+	               end	           |};	         diag_equiv_isequiv :=	           fun k0 : Graph.graph0 sequence_graph =>	           isequiv_path (ap A (nat_add_n_Sm k0 n)^)	       |} (iscolimit_colimit (shift_seq A n.+1))	       (iscolimit_colimit (succ_seq (shift_seq A n))))	    (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	       {|	         equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	       |}) o inj (shift_seq A n.+1) k) n0 a =	 (fun k : Graph.graph0 sequence_graph =>	  (fun a0 : shift_seq A n.+1 k => J (nat_add_n_Sm k n))	  :	  colim_shift_seq_to_colim_seq A n.+1 o inj (shift_seq A n.+1) k ==	  (fun (x y z : Type) (f : x <~> y) (g : y <~> z) => equiv_compose g f)	    (Colimit (shift_seq A n.+1)) (Colimit (succ_seq (shift_seq A n)))	    (Colimit A)	    (equiv_functor_colimit	       {|	         diag_equiv_map :=	           {|	             DiagramMap_obj :=	               fun k0 : Graph.graph0 sequence_graph =>	               coe (ap A (nat_add_n_Sm k0 n)^);	             DiagramMap_comm :=	               fun (k0 l : Graph.graph0 sequence_graph)	                 (p : Graph.graph1 sequence_graph k0 l)	                 (a0 : shift_seq A n.+1 k0) =>	               match	                 p as p0 in (_ = y)	                 return	                   (((succ_seq (shift_seq A n)) _f p0)	                      (coe (ap A (nat_add_n_Sm k0 n)^) a0) =	                    coe (ap A (nat_add_n_Sm y n)^)	                      (((shift_seq A n.+1) _f p0) a0))	               with	               | 1 =>	                   K S (fun (n1 : nat) (a1 : A n1) => (a1) ^+)	                     (nat_add_n_Sm k0 n)^ @	                   ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k0 n))))	                     (a0) ^+	               end	           |};	         diag_equiv_isequiv :=	           fun k0 : Graph.graph0 sequence_graph =>	           isequiv_path (ap A (nat_add_n_Sm k0 n)^)	       |} (iscolimit_colimit (shift_seq A n.+1))	       (iscolimit_colimit (succ_seq (shift_seq A n))))	    (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	       {|	         equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	       |}) o inj (shift_seq A n.+1) k) n0.+1 (a) ^+ @	 ap	   ((fun (x y z : Type) (f : x <~> y) (g : y <~> z) => equiv_compose g f)	      (Colimit (shift_seq A n.+1)) (Colimit (succ_seq (shift_seq A n)))	      (Colimit A)	      (equiv_functor_colimit	         {|	           diag_equiv_map :=	             {|	               DiagramMap_obj :=	                 fun k : Graph.graph0 sequence_graph =>	                 coe (ap A (nat_add_n_Sm k n)^);	               DiagramMap_comm :=	                 fun (k l : Graph.graph0 sequence_graph)	                   (p : Graph.graph1 sequence_graph k l)	                   (a0 : shift_seq A n.+1 k) =>	                 match	                   p as p0 in (_ = y)	                   return	                     (((succ_seq (shift_seq A n)) _f p0)	                        (coe (ap A (nat_add_n_Sm k n)^) a0) =	                      coe (ap A (nat_add_n_Sm y n)^)	                        (((shift_seq A n.+1) _f p0) a0))	                 with	                 | 1 =>	                     K S (fun (n1 : nat) (a1 : A n1) => (a1) ^+)	                       (nat_add_n_Sm k n)^ @	                     ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k n))))	                       (a0) ^+	                 end	             |};	           diag_equiv_isequiv :=	             fun k : Graph.graph0 sequence_graph =>	             isequiv_path (ap A (nat_add_n_Sm k n)^)	         |} (iscolimit_colimit (shift_seq A n.+1))	         (iscolimit_colimit (succ_seq (shift_seq A n))))	      (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	         {|	           equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	         |})) (glue (shift_seq A n.+1) n0 a)	";
            responses[i]=data;
          

            i = 216;
            data = "1 goal (ID 1224)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  ============================	  forall (n0 : Graph.graph0 sequence_graph) (a : shift_seq A n.+1 n0),	  ap (colim_shift_seq_to_colim_seq A n.+1) (glue (shift_seq A n.+1) n0 a) @	  (fun k : Graph.graph0 sequence_graph =>	   (fun a0 : shift_seq A n.+1 k => J (nat_add_n_Sm k n))	   :	   colim_shift_seq_to_colim_seq A n.+1 o inj (shift_seq A n.+1) k ==	   (fun (x y z : Type) (f : x <~> y) (g : y <~> z) => equiv_compose g f)	     (Colimit (shift_seq A n.+1)) (Colimit (succ_seq (shift_seq A n)))	     (Colimit A)	     (equiv_functor_colimit	        {|	          diag_equiv_map :=	            {|	              DiagramMap_obj :=	                fun k0 : Graph.graph0 sequence_graph =>	                coe (ap A (nat_add_n_Sm k0 n)^);	              DiagramMap_comm :=	                fun (k0 l : Graph.graph0 sequence_graph)	                  (p : Graph.graph1 sequence_graph k0 l)	                  (a0 : shift_seq A n.+1 k0) =>	                match	                  p as p0 in (_ = y)	                  return	                    (((succ_seq (shift_seq A n)) _f p0)	                       (coe (ap A (nat_add_n_Sm k0 n)^) a0) =	                     coe (ap A (nat_add_n_Sm y n)^)	                       (((shift_seq A n.+1) _f p0) a0))	                with	                | 1 =>	                    K S (fun (n1 : nat) (a1 : A n1) => (a1) ^+)	                      (nat_add_n_Sm k0 n)^ @	                    ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k0 n))))	                      (a0) ^+	                end	            |};	          diag_equiv_isequiv :=	            fun k0 : Graph.graph0 sequence_graph =>	            isequiv_path (ap A (nat_add_n_Sm k0 n)^)	        |} (iscolimit_colimit (shift_seq A n.+1))	        (iscolimit_colimit (succ_seq (shift_seq A n))))	     (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	        {|	          equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	        |}) o inj (shift_seq A n.+1) k) n0 a =	  (fun k : Graph.graph0 sequence_graph =>	   (fun a0 : shift_seq A n.+1 k => J (nat_add_n_Sm k n))	   :	   colim_shift_seq_to_colim_seq A n.+1 o inj (shift_seq A n.+1) k ==	   (fun (x y z : Type) (f : x <~> y) (g : y <~> z) => equiv_compose g f)	     (Colimit (shift_seq A n.+1)) (Colimit (succ_seq (shift_seq A n)))	     (Colimit A)	     (equiv_functor_colimit	        {|	          diag_equiv_map :=	            {|	              DiagramMap_obj :=	                fun k0 : Graph.graph0 sequence_graph =>	                coe (ap A (nat_add_n_Sm k0 n)^);	              DiagramMap_comm :=	                fun (k0 l : Graph.graph0 sequence_graph)	                  (p : Graph.graph1 sequence_graph k0 l)	                  (a0 : shift_seq A n.+1 k0) =>	                match	                  p as p0 in (_ = y)	                  return	                    (((succ_seq (shift_seq A n)) _f p0)	                       (coe (ap A (nat_add_n_Sm k0 n)^) a0) =	                     coe (ap A (nat_add_n_Sm y n)^)	                       (((shift_seq A n.+1) _f p0) a0))	                with	                | 1 =>	                    K S (fun (n1 : nat) (a1 : A n1) => (a1) ^+)	                      (nat_add_n_Sm k0 n)^ @	                    ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k0 n))))	                      (a0) ^+	                end	            |};	          diag_equiv_isequiv :=	            fun k0 : Graph.graph0 sequence_graph =>	            isequiv_path (ap A (nat_add_n_Sm k0 n)^)	        |} (iscolimit_colimit (shift_seq A n.+1))	        (iscolimit_colimit (succ_seq (shift_seq A n))))	     (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	        {|	          equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	        |}) o inj (shift_seq A n.+1) k) n0.+1 (a) ^+ @	  ap	    ((fun (x y z : Type) (f : x <~> y) (g : y <~> z) => equiv_compose g f)	       (Colimit (shift_seq A n.+1)) (Colimit (succ_seq (shift_seq A n)))	       (Colimit A)	       (equiv_functor_colimit	          {|	            diag_equiv_map :=	              {|	                DiagramMap_obj :=	                  fun k : Graph.graph0 sequence_graph =>	                  coe (ap A (nat_add_n_Sm k n)^);	                DiagramMap_comm :=	                  fun (k l : Graph.graph0 sequence_graph)	                    (p : Graph.graph1 sequence_graph k l)	                    (a0 : shift_seq A n.+1 k) =>	                  match	                    p as p0 in (_ = y)	                    return	                      (((succ_seq (shift_seq A n)) _f p0)	                         (coe (ap A (nat_add_n_Sm k n)^) a0) =	                       coe (ap A (nat_add_n_Sm y n)^)	                         (((shift_seq A n.+1) _f p0) a0))	                  with	                  | 1 =>	                      K S (fun (n1 : nat) (a1 : A n1) => (a1) ^+)	                        (nat_add_n_Sm k n)^ @	                      ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k n))))	                        (a0) ^+	                  end	              |};	            diag_equiv_isequiv :=	              fun k : Graph.graph0 sequence_graph =>	              isequiv_path (ap A (nat_add_n_Sm k n)^)	          |} (iscolimit_colimit (shift_seq A n.+1))	          (iscolimit_colimit (succ_seq (shift_seq A n))))	       (transitivity (equiv_colim_succ_seq_to_colim_seq (shift_seq A n))	          {|	            equiv_fun := colim_shift_seq_to_colim_seq A n; equiv_isequiv := e	          |})) (glue (shift_seq A n.+1) n0 a)	1 goal (ID 1291)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  k : Graph.graph0 sequence_graph	  a : shift_seq A n.+1 k	  ============================	  colimp (k + n.+1) (k + n.+1).+1 1 a @ J (nat_add_n_Sm k n) =	  J (ap S (nat_add_n_Sm k n)) @	  ap	    (fun x : Colimit (shift_seq A n.+1) =>	     colim_shift_seq_to_colim_seq A n	       (colim_succ_seq_to_colim_seq (shift_seq A n)	          (functor_colimit	             {|	               DiagramMap_obj :=	                 fun k0 : nat => coe (ap A (nat_add_n_Sm k0 n)^);	               DiagramMap_comm :=	                 fun (k0 l : nat) (p : k0.+1 = l) (a0 : A (k0 + n.+1)) =>	                 match	                   p as p0 in (_ = y)	                   return	                     (match	                        p0 in (_ = y0)	                        return (A (k0 + n).+1 -> A (y0 + n).+1)	                      with	                      | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                      end (coe (ap A (nat_add_n_Sm k0 n)^) a0) =	                      coe (ap A (nat_add_n_Sm y n)^)	                        (match	                           p0 in (_ = y0)	                           return (A (k0 + n.+1) -> A (y0 + n.+1))	                         with	                         | 1 => fun a1 : A (k0 + n.+1) => (a1) ^+	                         end a0))	                 with	                 | 1 =>	                     K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                       (nat_add_n_Sm k0 n)^ @	                     ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k0 n))))	                       (a0) ^+	                 end	             |} (iscolimit_colimit (shift_seq A n.+1))	             (iscolimit_colimit (succ_seq (shift_seq A n))) x)))	    (colimp k k.+1 1 a)	";
            responses[i]=data;
          

            i = 217;
            data = "";
            responses[i]=data;
          

            i = 218;
            data = "";
            responses[i]=data;
          

            i = 219;
            data = "1 goal (ID 1346)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  k : Graph.graph0 sequence_graph	  a : shift_seq A n.+1 k	  ============================	  colimp (k + n.+1) (k + n.+1).+1 1 a @ J (nat_add_n_Sm k n) =	  J (ap S (nat_add_n_Sm k n)) @	  (ap (colim_shift_seq_to_colim_seq A n)	     (ap (colim_succ_seq_to_colim_seq (shift_seq A n))	        (ap (iscolimit_colimit (succ_seq (shift_seq A n)) k.+1)	           (DiagramMap_comm	              {|	                DiagramMap_obj :=	                  fun k0 : nat => coe (ap A (nat_add_n_Sm k0 n)^);	                DiagramMap_comm :=	                  fun (k0 l : nat) (p : k0.+1 = l) (a0 : A (k0 + n.+1)) =>	                  match	                    p as p0 in (_ = y)	                    return	                      (match	                         p0 in (_ = y0)	                         return (A (k0 + n).+1 -> A (y0 + n).+1)	                       with	                       | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                       end (coe (ap A (nat_add_n_Sm k0 n)^) a0) =	                       coe (ap A (nat_add_n_Sm y n)^)	                         (match	                            p0 in (_ = y0)	                            return (A (k0 + n.+1) -> A (y0 + n.+1))	                          with	                          | 1 => fun a1 : A (k0 + n.+1) => (a1) ^+	                          end a0))	                  with	                  | 1 =>	                      K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                        (nat_add_n_Sm k0 n)^ @	                      ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k0 n))))	                        (a0) ^+	                  end	              |} 1 a)^)) @	   ap (colim_shift_seq_to_colim_seq A n)	     (ap (colim_succ_seq_to_colim_seq (shift_seq A n))	        (legs_comm (iscolimit_colimit (succ_seq (shift_seq A n))) k k.+1 1	           ({|	              DiagramMap_obj :=	                fun k0 : nat => coe (ap A (nat_add_n_Sm k0 n)^);	              DiagramMap_comm :=	                fun (k0 l : nat) (p : k0.+1 = l) (a0 : A (k0 + n.+1)) =>	                match	                  p as p0 in (_ = y)	                  return	                    (match	                       p0 in (_ = y0) return (A (k0 + n).+1 -> A (y0 + n).+1)	                     with	                     | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                     end (coe (ap A (nat_add_n_Sm k0 n)^) a0) =	                     coe (ap A (nat_add_n_Sm y n)^)	                       (match	                          p0 in (_ = y0)	                          return (A (k0 + n.+1) -> A (y0 + n.+1))	                        with	                        | 1 => fun a1 : A (k0 + n.+1) => (a1) ^+	                        end a0))	                with	                | 1 =>	                    K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                      (nat_add_n_Sm k0 n)^ @	                    ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k0 n))))	                      (a0) ^+	                end	            |} k a))))	";
            responses[i]=data;
          

            i = 220;
            data = "1 goal (ID 1350)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  k : Graph.graph0 sequence_graph	  a : shift_seq A n.+1 k	  ============================	  colimp (k + n.+1) (k + n.+1).+1 1 a @ J (nat_add_n_Sm k n) =	  J (ap S (nat_add_n_Sm k n)) @	  (ap (inj A (k.+2 + n))	     (DiagramMap_comm	        {|	          DiagramMap_obj := fun k0 : nat => coe (ap A (nat_add_n_Sm k0 n)^);	          DiagramMap_comm :=	            fun (k0 l : nat) (p : k0.+1 = l) (a0 : A (k0 + n.+1)) =>	            match	              p as p0 in (_ = y)	              return	                (match	                   p0 in (_ = y0) return (A (k0 + n).+1 -> A (y0 + n).+1)	                 with	                 | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                 end (coe (ap A (nat_add_n_Sm k0 n)^) a0) =	                 coe (ap A (nat_add_n_Sm y n)^)	                   (match	                      p0 in (_ = y0) return (A (k0 + n.+1) -> A (y0 + n.+1))	                    with	                    | 1 => fun a1 : A (k0 + n.+1) => (a1) ^+	                    end a0))	            with	            | 1 =>	                K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                  (nat_add_n_Sm k0 n)^ @	                ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k0 n))))	                  (a0) ^+	            end	        |} 1 a)^ @	   ap (colim_shift_seq_to_colim_seq A n)	     (ap (colim_succ_seq_to_colim_seq (shift_seq A n))	        (legs_comm (iscolimit_colimit (succ_seq (shift_seq A n))) k k.+1 1	           ({|	              DiagramMap_obj :=	                fun k0 : nat => coe (ap A (nat_add_n_Sm k0 n)^);	              DiagramMap_comm :=	                fun (k0 l : nat) (p : k0.+1 = l) (a0 : A (k0 + n.+1)) =>	                match	                  p as p0 in (_ = y)	                  return	                    (match	                       p0 in (_ = y0) return (A (k0 + n).+1 -> A (y0 + n).+1)	                     with	                     | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                     end (coe (ap A (nat_add_n_Sm k0 n)^) a0) =	                     coe (ap A (nat_add_n_Sm y n)^)	                       (match	                          p0 in (_ = y0)	                          return (A (k0 + n.+1) -> A (y0 + n.+1))	                        with	                        | 1 => fun a1 : A (k0 + n.+1) => (a1) ^+	                        end a0))	                with	                | 1 =>	                    K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                      (nat_add_n_Sm k0 n)^ @	                    ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k0 n))))	                      (a0) ^+	                end	            |} k a))))	1 goal (ID 1351)	  	  H : Funext	  A : Sequence	  n : nat	  e : IsEquiv (colim_shift_seq_to_colim_seq A n)	  k : Graph.graph0 sequence_graph	  a : shift_seq A n.+1 k	  ============================	  colimp (k + n.+1) (k + n.+1).+1 1 a @ J (nat_add_n_Sm k n) =	  J (ap S (nat_add_n_Sm k n)) @	  (ap (inj A (k.+2 + n))	     (DiagramMap_comm	        {|	          DiagramMap_obj := fun k0 : nat => coe (ap A (nat_add_n_Sm k0 n)^);	          DiagramMap_comm :=	            fun (k0 l : nat) (p : k0.+1 = l) (a0 : A (k0 + n.+1)) =>	            match	              p as p0 in (_ = y)	              return	                (match	                   p0 in (_ = y0) return (A (k0 + n).+1 -> A (y0 + n).+1)	                 with	                 | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                 end (coe (ap A (nat_add_n_Sm k0 n)^) a0) =	                 coe (ap A (nat_add_n_Sm y n)^)	                   (match	                      p0 in (_ = y0) return (A (k0 + n.+1) -> A (y0 + n.+1))	                    with	                    | 1 => fun a1 : A (k0 + n.+1) => (a1) ^+	                    end a0))	            with	            | 1 =>	                K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                  (nat_add_n_Sm k0 n)^ @	                ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k0 n))))	                  (a0) ^+	            end	        |} 1 a)^ @	   ap (colim_shift_seq_to_colim_seq A n)	     (colimp k.+1 k.+2 1	        ({|	           DiagramMap_obj := fun k0 : nat => coe (ap A (nat_add_n_Sm k0 n)^);	           DiagramMap_comm :=	             fun (k0 l : nat) (p : k0.+1 = l) (a0 : A (k0 + n.+1)) =>	             match	               p as p0 in (_ = y)	               return	                 (match	                    p0 in (_ = y0) return (A (k0 + n).+1 -> A (y0 + n).+1)	                  with	                  | 1 => fun a1 : A (k0 + n).+1 => (a1) ^+	                  end (coe (ap A (nat_add_n_Sm k0 n)^) a0) =	                  coe (ap A (nat_add_n_Sm y n)^)	                    (match	                       p0 in (_ = y0) return (A (k0 + n.+1) -> A (y0 + n.+1))	                     with	                     | 1 => fun a1 : A (k0 + n.+1) => (a1) ^+	                     end a0))	             with	             | 1 =>	                 K S (fun (n0 : nat) (a1 : A n0) => (a1) ^+)	                   (nat_add_n_Sm k0 n)^ @	                 ap10 (ap coe (ap (ap A) (ap_V S (nat_add_n_Sm k0 n))))	                   (a0) ^+	             end	         |} k a)))	No more goals.	";
            responses[i]=data;
          

            i = 221;
            data = "";
            responses[i]=data;
          

            i = 222;
            data = "";
            responses[i]=data;
          

            i = 223;
            data = "";
            responses[i]=data;
          

            i = 224;
            data = "";
            responses[i]=data;
          

            i = 225;
            data = "";
            responses[i]=data;
          

            i = 226;
            data = "";
            responses[i]=data;
          

            i = 227;
            data = "";
            responses[i]=data;
          

            i = 228;
            data = "";
            responses[i]=data;
          

            i = 229;
            data = "";
            responses[i]=data;
          

            i = 230;
            data = "";
            responses[i]=data;
          

            i = 231;
            data = "";
            responses[i]=data;
          

            i = 232;
            data = "";
            responses[i]=data;
          

            i = 233;
            data = "<infomsg>equiv_colim_shift_seq_to_colim_seq is defined</infomsg>	1 goal (ID 548)	  	  H : Funext	  A : Sequence	  ============================	  (forall k : Graph.graph0 sequence_graph, Contr (A k)) -> Contr (Colimit A)	1 goal (ID 553)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  Contr (Colimit A)	2 goals (ID 567)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  Colimit unit_seq <~> Colimit A		goal 2 (ID 569) is:	 Contr (Colimit unit_seq)	1 goal (ID 567)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  Colimit unit_seq <~> Colimit A	1 goal (ID 657)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  A ~d~ unit_seq	2 goals (ID 730)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> unit_seq i		goal 2 (ID 732) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 (unit_seq _f g) (?DiagramMap_obj i x) = ?DiagramMap_obj j ((A _f g) x)	1 goal (ID 730)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> unit_seq i	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 732) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 (unit_seq _f g)	   ((fun (i0 : Graph.graph0 sequence_graph) (_ : A i0) => tt) i x) =	 (fun (i0 : Graph.graph0 sequence_graph) (_ : A i0) => tt) j ((A _f g) x)	goal 2 (ID 569) is:	 Contr (Colimit unit_seq)	";
            responses[i]=data;
          

            i = 234;
            data = "1 goal (ID 732)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : A i),	  (unit_seq _f g)	    ((fun (i0 : Graph.graph0 sequence_graph) (_ : A i0) => tt) i x) =	  (fun (i0 : Graph.graph0 sequence_graph) (_ : A i0) => tt) j ((A _f g) x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 569) is:	 Contr (Colimit unit_seq)	";
            responses[i]=data;
          

            i = 235;
            data = "1 goal (ID 569)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  Contr (Colimit unit_seq)	1 goal (ID 764)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall y : Colimit unit_seq, y = inj unit_seq 0 tt	";
            responses[i]=data;
          

            i = 236;
            data = "2 goals (ID 798)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  idmap o inj unit_seq n ==	  (fun _ : Colimit unit_seq => inj unit_seq 0 tt) o inj unit_seq n		goal 2 (ID 800) is:	 forall (n : Graph.graph0 sequence_graph) (a : unit_seq n),	 ap idmap (glue unit_seq n a) @ ?h n a =	 ?h n.+1 (a) ^+ @	 ap (fun _ : Colimit unit_seq => inj unit_seq 0 tt) (glue unit_seq n a)	";
            responses[i]=data;
          

            i = 237;
            data = "1 goal (ID 798)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall n : Graph.graph0 sequence_graph,	  idmap o inj unit_seq n ==	  (fun _ : Colimit unit_seq => inj unit_seq 0 tt) o inj unit_seq n	2 goals (ID 810)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  inj unit_seq 0 tt = inj unit_seq 0 tt		goal 2 (ID 813) is:	 inj unit_seq n.+1 tt = inj unit_seq 0 tt	";
            responses[i]=data;
          

            i = 238;
            data = "1 goal (ID 810)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  inj unit_seq 0 tt = inj unit_seq 0 tt	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 813) is:	 inj unit_seq n.+1 tt = inj unit_seq 0 tt	goal 2 (ID 800) is:	 forall (n : Graph.graph0 sequence_graph) (a : unit_seq n),	 ap idmap (glue unit_seq n a) @	 (fun n0 : Graph.graph0 sequence_graph =>	  (fun a0 : unit_seq n0 =>	   match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	   | tt =>	       Overture.nat_rect	         (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	         (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	          ?Goal@{n:=n1}) n0	   end)	  :	  idmap o inj unit_seq n0 ==	  (fun _ : Colimit unit_seq => inj unit_seq 0 tt) o inj unit_seq n0) n a =	 (fun n0 : Graph.graph0 sequence_graph =>	  (fun a0 : unit_seq n0 =>	   match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	   | tt =>	       Overture.nat_rect	         (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	         (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	          ?Goal@{n:=n1}) n0	   end)	  :	  idmap o inj unit_seq n0 ==	  (fun _ : Colimit unit_seq => inj unit_seq 0 tt) o inj unit_seq n0) n.+1	   (a) ^+ @	 ap (fun _ : Colimit unit_seq => inj unit_seq 0 tt) (glue unit_seq n a)	";
            responses[i]=data;
          

            i = 239;
            data = "1 goal (ID 813)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  n : nat	  r : inj unit_seq n tt = inj unit_seq 0 tt	  ============================	  inj unit_seq n.+1 tt = inj unit_seq 0 tt	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 goal		goal 1 (ID 800) is:	 forall (n : Graph.graph0 sequence_graph) (a : unit_seq n),	 ap idmap (glue unit_seq n a) @	 (fun n0 : Graph.graph0 sequence_graph =>	  (fun a0 : unit_seq n0 =>	   match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	   | tt =>	       Overture.nat_rect	         (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	         (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	          glue unit_seq n1 tt @ r) n0	   end)	  :	  idmap o inj unit_seq n0 ==	  (fun _ : Colimit unit_seq => inj unit_seq 0 tt) o inj unit_seq n0) n a =	 (fun n0 : Graph.graph0 sequence_graph =>	  (fun a0 : unit_seq n0 =>	   match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	   | tt =>	       Overture.nat_rect	         (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	         (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	          glue unit_seq n1 tt @ r) n0	   end)	  :	  idmap o inj unit_seq n0 ==	  (fun _ : Colimit unit_seq => inj unit_seq 0 tt) o inj unit_seq n0) n.+1	   (a) ^+ @	 ap (fun _ : Colimit unit_seq => inj unit_seq 0 tt) (glue unit_seq n a)	";
            responses[i]=data;
          

            i = 240;
            data = "1 goal (ID 800)	  	  H : Funext	  A : Sequence	  h_seqcontr : forall k : Graph.graph0 sequence_graph, Contr (A k)	  unit_seq := Build_Sequence (fun _ : nat => Unit)	                (fun (n : nat) (_ : (fun _ : nat => Unit) n) => tt)	   : Sequence	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : unit_seq n),	  ap idmap (glue unit_seq n a) @	  (fun n0 : Graph.graph0 sequence_graph =>	   (fun a0 : unit_seq n0 =>	    match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	    | tt =>	        Overture.nat_rect	          (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	          (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	           glue unit_seq n1 tt @ r) n0	    end)	   :	   idmap o inj unit_seq n0 ==	   (fun _ : Colimit unit_seq => inj unit_seq 0 tt) o inj unit_seq n0) n a =	  (fun n0 : Graph.graph0 sequence_graph =>	   (fun a0 : unit_seq n0 =>	    match a0 as u return (inj unit_seq n0 u = inj unit_seq 0 tt) with	    | tt =>	        Overture.nat_rect	          (fun n1 : nat => inj unit_seq n1 tt = inj unit_seq 0 tt) 1	          (fun (n1 : nat) (r : inj unit_seq n1 tt = inj unit_seq 0 tt) =>	           glue unit_seq n1 tt @ r) n0	    end)	   :	   idmap o inj unit_seq n0 ==	   (fun _ : Colimit unit_seq => inj unit_seq 0 tt) o inj unit_seq n0) n.+1	    (a) ^+ @	  ap (fun _ : Colimit unit_seq => inj unit_seq 0 tt) (glue unit_seq n a)	No more goals.	";
            responses[i]=data;
          

            i = 241;
            data = "";
            responses[i]=data;
          

            i = 242;
            data = "";
            responses[i]=data;
          

            i = 243;
            data = "";
            responses[i]=data;
          

            i = 244;
            data = "";
            responses[i]=data;
          

            i = 245;
            data = "";
            responses[i]=data;
          

            i = 246;
            data = "<infomsg>FibSequence is defined</infomsg>	<infomsg>FibSequence_rect is defined</infomsg>	<infomsg>FibSequence_ind is defined</infomsg>	<infomsg>FibSequence_rec is defined</infomsg>	<infomsg>FibSequence_sind is defined</infomsg>	<infomsg>fibSequence is defined</infomsg>	<infomsg>fibSequenceArr is defined</infomsg>	";
            responses[i]=data;
          

            i = 247;
            data = "<infomsg>fibSequence is now a coercion</infomsg>	";
            responses[i]=data;
          

            i = 248;
            data = "";
            responses[i]=data;
          

            i = 249;
            data = "";
            responses[i]=data;
          

            i = 250;
            data = "";
            responses[i]=data;
          

            i = 251;
            data = "";
            responses[i]=data;
          

            i = 252;
            data = "";
            responses[i]=data;
          

            i = 253;
            data = "";
            responses[i]=data;
          

            i = 254;
            data = "";
            responses[i]=data;
          

            i = 255;
            data = "1 goal (ID 552)	  	  A : Sequence	  B : FibSequence A	  ============================	  Sequence	";
            responses[i]=data;
          

            i = 256;
            data = "";
            responses[i]=data;
          

            i = 257;
            data = "2 goals (ID 556)	  	  A : Sequence	  B : FibSequence A	  ============================	  nat -> Type		goal 2 (ID 558) is:	 forall n : nat, ?X n -> ?X n.+1	";
            responses[i]=data;
          

            i = 258;
            data = "1 goal (ID 556)	  	  A : Sequence	  B : FibSequence A	  ============================	  nat -> Type	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 558) is:	 forall n : nat,	 (fun n0 : nat => {a : A n0 & B (n0; a)}) n ->	 (fun n0 : nat => {a : A n0 & B (n0; a)}) n.+1	";
            responses[i]=data;
          

            i = 259;
            data = "1 goal (ID 558)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall n : nat,	  (fun n0 : nat => {a : A n0 & B (n0; a)}) n ->	  (fun n0 : nat => {a : A n0 & B (n0; a)}) n.+1	No more goals.	";
            responses[i]=data;
          

            i = 260;
            data = "";
            responses[i]=data;
          

            i = 261;
            data = "";
            responses[i]=data;
          

            i = 262;
            data = "";
            responses[i]=data;
          

            i = 263;
            data = "";
            responses[i]=data;
          

            i = 264;
            data = "";
            responses[i]=data;
          

            i = 265;
            data = "1 goal (ID 559)	  	  A : Sequence	  B : FibSequence A	  ============================	  Colimit (sig_seq B) -> Colimit A	";
            responses[i]=data;
          

            i = 266;
            data = "";
            responses[i]=data;
          

            i = 267;
            data = "2 goals (ID 589)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph, sig_seq B i -> Colimit A		goal 2 (ID 591) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j), ?legs j o (sig_seq B) _f g == ?legs i	";
            responses[i]=data;
          

            i = 268;
            data = "1 goal (ID 589)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph, sig_seq B i -> Colimit A	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 591) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	  (fun (a : A n) (_ : B (n; a)) => inj A n a) X.1 X.2) j o 	 (sig_seq B) _f g ==	 (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	  (fun (a : A n) (_ : B (n; a)) => inj A n a) X.1 X.2) i	";
            responses[i]=data;
          

            i = 269;
            data = "1 goal (ID 591)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	   (fun (a : A n) (_ : B (n; a)) => inj A n a) X.1 X.2) j o 	  (sig_seq B) _f g ==	  (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	   (fun (a : A n) (_ : B (n; a)) => inj A n a) X.1 X.2) i	No more goals.	";
            responses[i]=data;
          

            i = 270;
            data = "";
            responses[i]=data;
          

            i = 271;
            data = "";
            responses[i]=data;
          

            i = 272;
            data = "";
            responses[i]=data;
          

            i = 273;
            data = "";
            responses[i]=data;
          

            i = 274;
            data = "";
            responses[i]=data;
          

            i = 275;
            data = "1 goal (ID 565)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  Sequence	";
            responses[i]=data;
          

            i = 276;
            data = "";
            responses[i]=data;
          

            i = 277;
            data = "4 goals (ID 581)	  	  A : Sequence	  B : FibSequence A	  ============================	  {x : _ & A x} -> Type		goal 2 (ID 584) is:	 {x : _ & A x} -> Type	goal 3 (ID 588) is:	 forall x : {x : _ & A x},	 Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type) 	   ?Goal (fun (k : nat) (h : {x : _ & A x} -> Type) => ?Goal0) 0 x ->	 Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type) 	   ?Goal (fun (k : nat) (h : {x : _ & A x} -> Type) => ?Goal0) 1 x	goal 4 (ID 591) is:	 forall x : {x : _ & A x},	 Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type) 	   ?Goal	   (fun (k0 : nat) (h0 : {x : _ & A x} -> Type) => ?Goal0@{k:=k0; h:=h0})	   k.+1 x ->	 Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type) 	   ?Goal	   (fun (k0 : nat) (h0 : {x : _ & A x} -> Type) => ?Goal0@{k:=k0; h:=h0})	   k.+2 x	";
            responses[i]=data;
          

            i = 278;
            data = "1 goal (ID 581)	  	  A : Sequence	  B : FibSequence A	  ============================	  {x : _ & A x} -> Type	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 goals		goal 1 (ID 584) is:	 {x : _ & A x} -> Type	goal 2 (ID 588) is:	 forall x : {x : _ & A x},	 Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (k : nat) (h : {x : _ & A x} -> Type) => ?Goal) 0 x ->	 Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (k : nat) (h : {x : _ & A x} -> Type) => ?Goal) 1 x	goal 3 (ID 591) is:	 forall x : {x : _ & A x},	 Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (k0 : nat) (h0 : {x : _ & A x} -> Type) => ?Goal@{k:=k0; h:=h0}) k.+1	   x ->	 Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (k0 : nat) (h0 : {x : _ & A x} -> Type) => ?Goal@{k:=k0; h:=h0}) k.+2	   x	";
            responses[i]=data;
          

            i = 279;
            data = "1 goal (ID 584)	  	  A : Sequence	  B : FibSequence A	  k : nat	  h : {x : _ & A x} -> Type	  ============================	  {x : _ & A x} -> Type	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 588) is:	 forall x : {x : _ & A x},	 Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h (x0) ^++) 0 x ->	 Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h (x0) ^++) 1 x	goal 2 (ID 591) is:	 forall x : {x : _ & A x},	 Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h0 (x0) ^++) k.+1 x ->	 Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h0 (x0) ^++) k.+2 x	";
            responses[i]=data;
          

            i = 280;
            data = "1 goal (ID 588)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall x : {x : _ & A x},	  Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	    (fun x0 : {x : _ & A x} => B x0)	    (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	     h (x0) ^++) 0 x ->	  Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	    (fun x0 : {x : _ & A x} => B x0)	    (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	     h (x0) ^++) 1 x	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 goal		goal 1 (ID 591) is:	 forall x : {x : _ & A x},	 Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h0 (x0) ^++) k.+1 x ->	 Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	   (fun x0 : {x : _ & A x} => B x0)	   (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	    h0 (x0) ^++) k.+2 x	";
            responses[i]=data;
          

            i = 281;
            data = "1 goal (ID 591)	  	  A : Sequence	  B : FibSequence A	  k : nat	  h : forall x : {x : _ & A x},	      Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	        (fun x0 : {x : _ & A x} => B x0)	        (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	         h (x0) ^++) k x ->	      Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	        (fun x0 : {x : _ & A x} => B x0)	        (fun (_ : nat) (h : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	         h (x0) ^++) k.+1 x	  ============================	  forall x : {x : _ & A x},	  Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	    (fun x0 : {x : _ & A x} => B x0)	    (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	     h0 (x0) ^++) k.+1 x ->	  Overture.nat_rect (fun _ : nat => {x : _ & A x} -> Type)	    (fun x0 : {x : _ & A x} => B x0)	    (fun (_ : nat) (h0 : {x : _ & A x} -> Type) (x0 : {x : _ & A x}) =>	     h0 (x0) ^++) k.+2 x	No more goals.	";
            responses[i]=data;
          

            i = 282;
            data = "";
            responses[i]=data;
          

            i = 283;
            data = "";
            responses[i]=data;
          

            i = 284;
            data = "";
            responses[i]=data;
          

            i = 285;
            data = "";
            responses[i]=data;
          

            i = 286;
            data = "";
            responses[i]=data;
          

            i = 287;
            data = "<infomsg>fib_seq_to_seq' is defined</infomsg>	";
            responses[i]=data;
          

            i = 288;
            data = "1 goal (ID 587)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  fib_seq_to_seq B x ~d~ fib_seq_to_seq' B x	";
            responses[i]=data;
          

            i = 289;
            data = "";
            responses[i]=data;
          

            i = 290;
            data = "2 goals (ID 610)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  DiagramMap (fib_seq_to_seq B x) (fib_seq_to_seq' B x)		goal 2 (ID 612) is:	 forall i : Graph.graph0 sequence_graph, IsEquiv (?m i)	";
            responses[i]=data;
          

            i = 291;
            data = "1 goal (ID 610)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  DiagramMap (fib_seq_to_seq B x) (fib_seq_to_seq' B x)	2 goals (ID 653)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  forall i : Graph.graph0 sequence_graph,	  fib_seq_to_seq B x i -> fib_seq_to_seq' B x i		goal 2 (ID 655) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x0 : fib_seq_to_seq B x i),	 ((fib_seq_to_seq' B x) _f g) (?DiagramMap_obj i x0) =	 ?DiagramMap_obj j (((fib_seq_to_seq B x) _f g) x0)	";
            responses[i]=data;
          

            i = 292;
            data = "1 goal (ID 653)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  forall i : Graph.graph0 sequence_graph,	  fib_seq_to_seq B x i -> fib_seq_to_seq' B x i	2 goals (ID 662)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall x : {x : _ & A x}, fib_seq_to_seq B x 0 -> fib_seq_to_seq' B x 0		goal 2 (ID 665) is:	 forall x : {x : _ & A x},	 fib_seq_to_seq B x n.+1 -> fib_seq_to_seq' B x n.+1	";
            responses[i]=data;
          

            i = 293;
            data = "1 goal (ID 662)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall x : {x : _ & A x}, fib_seq_to_seq B x 0 -> fib_seq_to_seq' B x 0	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	3 goals		goal 1 (ID 665) is:	 forall x : {x : _ & A x},	 fib_seq_to_seq B x n.+1 -> fib_seq_to_seq' B x n.+1	goal 2 (ID 655) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x0 : fib_seq_to_seq B x i),	 ((fib_seq_to_seq' B x) _f g)	   ((fun n : Graph.graph0 sequence_graph =>	     Overture.nat_rect	       (fun n0 : nat =>	        forall x1 : {x : _ & A x},	        fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (fun x1 : {x : _ & A x} => idmap)	       (fun (n0 : nat)	          (e : forall x1 : {x : _ & A x},	               fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0) =>	        ?Goal@{n:=n0}) n x) i x0) =	 (fun n : Graph.graph0 sequence_graph =>	  Overture.nat_rect	    (fun n0 : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n0 : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0) =>	     ?Goal@{n:=n0}) n x) j (((fib_seq_to_seq B x) _f g) x0)	goal 3 (ID 612) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n : Graph.graph0 sequence_graph =>	        Overture.nat_rect	          (fun n0 : nat =>	           forall x0 : {x : _ & A x},	           fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	          (fun x0 : {x : _ & A x} => idmap)	          (fun (n0 : nat)	             (e : forall x0 : {x : _ & A x},	                  fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0) =>	           ?Goal@{n:=n0}) n x;	      DiagramMap_comm := ?DiagramMap_comm	    |} i)	";
            responses[i]=data;
          

            i = 294;
            data = "1 goal (ID 665)	  	  A : Sequence	  B : FibSequence A	  n : nat	  e : forall x : {x : _ & A x}, fib_seq_to_seq B x n -> fib_seq_to_seq' B x n	  ============================	  forall x : {x : _ & A x},	  fib_seq_to_seq B x n.+1 -> fib_seq_to_seq' B x n.+1	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 655) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x0 : fib_seq_to_seq B x i),	 ((fib_seq_to_seq' B x) _f g)	   ((fun n : Graph.graph0 sequence_graph =>	     Overture.nat_rect	       (fun n0 : nat =>	        forall x1 : {x : _ & A x},	        fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (fun x1 : {x : _ & A x} => idmap)	       (fun (n0 : nat)	          (e : forall x1 : {x : _ & A x},	               fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	          (x1 : {x : _ & A x}) =>	        coe (ap B (seq_pair_shift_assoc x1 n0)) o e (x1) ^++) n x) i x0) =	 (fun n : Graph.graph0 sequence_graph =>	  Overture.nat_rect	    (fun n0 : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n0 : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (x1 : {x : _ & A x}) =>	     coe (ap B (seq_pair_shift_assoc x1 n0)) o e (x1) ^++) n x) j	   (((fib_seq_to_seq B x) _f g) x0)	goal 2 (ID 612) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n : Graph.graph0 sequence_graph =>	        Overture.nat_rect	          (fun n0 : nat =>	           forall x0 : {x : _ & A x},	           fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	          (fun x0 : {x : _ & A x} => idmap)	          (fun (n0 : nat)	             (e : forall x0 : {x : _ & A x},	                  fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	             (x0 : {x : _ & A x}) =>	           coe (ap B (seq_pair_shift_assoc x0 n0)) o e (x0) ^++) n x;	      DiagramMap_comm := ?DiagramMap_comm	    |} i)	";
            responses[i]=data;
          

            i = 295;
            data = "1 goal (ID 655)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x0 : fib_seq_to_seq B x i),	  ((fib_seq_to_seq' B x) _f g)	    ((fun n : Graph.graph0 sequence_graph =>	      Overture.nat_rect	        (fun n0 : nat =>	         forall x1 : {x : _ & A x},	         fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	        (fun x1 : {x : _ & A x} => idmap)	        (fun (n0 : nat)	           (e : forall x1 : {x : _ & A x},	                fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	           (x1 : {x : _ & A x}) =>	         coe (ap B (seq_pair_shift_assoc x1 n0)) o e (x1) ^++) n x) i x0) =	  (fun n : Graph.graph0 sequence_graph =>	   Overture.nat_rect	     (fun n0 : nat =>	      forall x1 : {x : _ & A x},	      fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	     (fun x1 : {x : _ & A x} => idmap)	     (fun (n0 : nat)	        (e : forall x1 : {x : _ & A x},	             fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	        (x1 : {x : _ & A x}) =>	      coe (ap B (seq_pair_shift_assoc x1 n0)) o e (x1) ^++) n x) j	    (((fib_seq_to_seq B x) _f g) x0)	2 goals (ID 700)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x 0),	  (Overture.nat_rect	     (fun n : nat =>	      forall x1 : {x : _ & A x},	      fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	     (fun x1 : {x : _ & A x} => idmap)	     (fun (n : nat)	        (e : forall x1 : {x : _ & A x},	             fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	        (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	      coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) 0 x x0) ^+ =	  Overture.nat_rect	    (fun n : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	       (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	     coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) 1 x 	    (x0) ^+		goal 2 (ID 703) is:	 forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x n.+1),	 (Overture.nat_rect	    (fun n0 : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n0 : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	     coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+1 x x0) ^+ =	 Overture.nat_rect	   (fun n0 : nat =>	    forall x1 : {x : _ & A x},	    fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	   (fun x1 : {x : _ & A x} => idmap)	   (fun (n0 : nat)	      (e : forall x1 : {x : _ & A x},	           fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	      (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	    coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+2 x 	   (x0) ^+	";
            responses[i]=data;
          

            i = 296;
            data = "1 goal (ID 700)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x 0),	  (Overture.nat_rect	     (fun n : nat =>	      forall x1 : {x : _ & A x},	      fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	     (fun x1 : {x : _ & A x} => idmap)	     (fun (n : nat)	        (e : forall x1 : {x : _ & A x},	             fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	        (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	      coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) 0 x x0) ^+ =	  Overture.nat_rect	    (fun n : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	       (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	     coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) 1 x 	    (x0) ^+	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 703) is:	 forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x n.+1),	 (Overture.nat_rect	    (fun n0 : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n0 : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	     coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+1 x x0) ^+ =	 Overture.nat_rect	   (fun n0 : nat =>	    forall x1 : {x : _ & A x},	    fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	   (fun x1 : {x : _ & A x} => idmap)	   (fun (n0 : nat)	      (e : forall x1 : {x : _ & A x},	           fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	      (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	    coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+2 x 	   (x0) ^+	goal 2 (ID 612) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n : Graph.graph0 sequence_graph =>	        Overture.nat_rect	          (fun n0 : nat =>	           forall x0 : {x : _ & A x},	           fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	          (fun x0 : {x : _ & A x} => idmap)	          (fun (n0 : nat)	             (e : forall x0 : {x : _ & A x},	                  fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	             (x0 : {x : _ & A x}) =>	           coe (ap B (seq_pair_shift_assoc x0 n0)) o e (x0) ^++) n x;	      DiagramMap_comm :=	        fun (n m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n m) =>	        match	          p as p0 in (_ = y)	          return	            (forall x0 : fib_seq_to_seq B x n,	             ((fib_seq_to_seq' B x) _f p0)	               (Overture.nat_rect	                  (fun n0 : nat =>	                   forall x1 : {x : _ & A x},	                   fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                  (fun x1 : {x : _ & A x} => idmap)	                  (fun (n0 : nat)	                     (e : forall x1 : {x : _ & A x},	                          fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                     (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0)	                   => coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                  n x x0) =	             Overture.nat_rect	               (fun n0 : nat =>	                forall x1 : {x : _ & A x},	                fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	               (fun x1 : {x : _ & A x} => idmap)	               (fun (n0 : nat)	                  (e : forall x1 : {x : _ & A x},	                       fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                  (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) y x	               (((fib_seq_to_seq B x) _f p0) x0))	        with	        | 1 =>	            Overture.nat_rect	              (fun n0 : nat =>	               forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n0),	               (Overture.nat_rect	                  (fun n1 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n1 : nat)	                     (e : forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n1)	                   => coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                  n0 x0 x1) ^+ =	               Overture.nat_rect	                 (fun n1 : nat =>	                  forall x2 : {x : _ & A x},	                  fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                 (fun x2 : {x : _ & A x} => idmap)	                 (fun (n1 : nat)	                    (e : forall x2 : {x : _ & A x},	                         fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                    (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n1)	                  => coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                 n0.+1 x0 (x1) ^+)	              (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	              (fun (n0 : nat)	                 (p0 : forall (x0 : {x : _ & A x})	                       (x1 : fib_seq_to_seq B x0 n0),	                       (Overture.nat_rect	                          (fun n1 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n1 : nat)	                             (e : forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n1 ->	                                  fib_seq_to_seq' B x2 n1)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                           coe (ap B (seq_pair_shift_assoc x2 n1))	                             (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                       Overture.nat_rect	                         (fun n1 : nat =>	                          forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                         (fun x2 : {x : _ & A x} => idmap)	                         (fun (n1 : nat)	                            (e : forall x2 : {x : _ & A x},	                                 fib_seq_to_seq B x2 n1 ->	                                 fib_seq_to_seq' B x2 n1)	                            (x2 : {x : _ & A x})	                            (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                          coe (ap B (seq_pair_shift_assoc x2 n1))	                            (e (x2) ^++ x3)) n0.+1 x0 	                         (x1) ^+) => ?Goal@{n:=n0; p:=p0}) n x	        end	    |} i)	";
            responses[i]=data;
          

            i = 297;
            data = "1 goal (ID 703)	  	  A : Sequence	  B : FibSequence A	  n : nat	  p : forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x n),	      (Overture.nat_rect	         (fun n : nat =>	          forall x1 : {x : _ & A x},	          fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	         (fun x1 : {x : _ & A x} => idmap)	         (fun (n : nat)	            (e : forall x1 : {x : _ & A x},	                 fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	            (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	          coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) n x x0) ^+ =	      Overture.nat_rect	        (fun n : nat =>	         forall x1 : {x : _ & A x},	         fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	        (fun x1 : {x : _ & A x} => idmap)	        (fun (n : nat)	           (e : forall x1 : {x : _ & A x},	                fib_seq_to_seq B x1 n -> fib_seq_to_seq' B x1 n)	           (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n) =>	         coe (ap B (seq_pair_shift_assoc x1 n)) (e (x1) ^++ x2)) n.+1 x	        (x0) ^+	  ============================	  forall (x : {x : _ & A x}) (x0 : fib_seq_to_seq B x n.+1),	  (Overture.nat_rect	     (fun n0 : nat =>	      forall x1 : {x : _ & A x},	      fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	     (fun x1 : {x : _ & A x} => idmap)	     (fun (n0 : nat)	        (e : forall x1 : {x : _ & A x},	             fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	        (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	      coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+1 x x0) ^+ =	  Overture.nat_rect	    (fun n0 : nat =>	     forall x1 : {x : _ & A x},	     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	    (fun x1 : {x : _ & A x} => idmap)	    (fun (n0 : nat)	       (e : forall x1 : {x : _ & A x},	            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	       (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	     coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) n.+2 x 	    (x0) ^+	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 612) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n : Graph.graph0 sequence_graph =>	        Overture.nat_rect	          (fun n0 : nat =>	           forall x0 : {x : _ & A x},	           fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	          (fun x0 : {x : _ & A x} => idmap)	          (fun (n0 : nat)	             (e : forall x0 : {x : _ & A x},	                  fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	             (x0 : {x : _ & A x}) =>	           coe (ap B (seq_pair_shift_assoc x0 n0)) o e (x0) ^++) n x;	      DiagramMap_comm :=	        fun (n m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n m) =>	        match	          p as p0 in (_ = y)	          return	            (forall x0 : fib_seq_to_seq B x n,	             ((fib_seq_to_seq' B x) _f p0)	               (Overture.nat_rect	                  (fun n0 : nat =>	                   forall x1 : {x : _ & A x},	                   fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                  (fun x1 : {x : _ & A x} => idmap)	                  (fun (n0 : nat)	                     (e : forall x1 : {x : _ & A x},	                          fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                     (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0)	                   => coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                  n x x0) =	             Overture.nat_rect	               (fun n0 : nat =>	                forall x1 : {x : _ & A x},	                fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	               (fun x1 : {x : _ & A x} => idmap)	               (fun (n0 : nat)	                  (e : forall x1 : {x : _ & A x},	                       fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                  (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2)) y x	               (((fib_seq_to_seq B x) _f p0) x0))	        with	        | 1 =>	            Overture.nat_rect	              (fun n0 : nat =>	               forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n0),	               (Overture.nat_rect	                  (fun n1 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n1 : nat)	                     (e : forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n1)	                   => coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                  n0 x0 x1) ^+ =	               Overture.nat_rect	                 (fun n1 : nat =>	                  forall x2 : {x : _ & A x},	                  fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                 (fun x2 : {x : _ & A x} => idmap)	                 (fun (n1 : nat)	                    (e : forall x2 : {x : _ & A x},	                         fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                    (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n1)	                  => coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                 n0.+1 x0 (x1) ^+)	              (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	              (fun (n0 : nat)	                 (p0 : forall (x0 : {x : _ & A x})	                       (x1 : fib_seq_to_seq B x0 n0),	                       (Overture.nat_rect	                          (fun n1 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n1 : nat)	                             (e : forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n1 ->	                                  fib_seq_to_seq' B x2 n1)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                           coe (ap B (seq_pair_shift_assoc x2 n1))	                             (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                       Overture.nat_rect	                         (fun n1 : nat =>	                          forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                         (fun x2 : {x : _ & A x} => idmap)	                         (fun (n1 : nat)	                            (e : forall x2 : {x : _ & A x},	                                 fib_seq_to_seq B x2 n1 ->	                                 fib_seq_to_seq' B x2 n1)	                            (x2 : {x : _ & A x})	                            (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                          coe (ap B (seq_pair_shift_assoc x2 n1))	                            (e (x2) ^++ x3)) n0.+1 x0 	                         (x1) ^+) (x0 : {x : _ & A x})	                 (b : fib_seq_to_seq B x0 n0.+1) =>	               K seq_pair_shift (fibSequenceArr B)	                 (seq_pair_shift_assoc x0 n0) @	               ap	                 (coe (ap B (ap seq_pair_shift (seq_pair_shift_assoc x0 n0))))	                 (p0 (x0) ^++ b)) n x	        end	    |} i)	";
            responses[i]=data;
          

            i = 298;
            data = "1 goal (ID 612)	  	  A : Sequence	  B : FibSequence A	  x : {x : _ & A x}	  ============================	  forall i : Graph.graph0 sequence_graph,	  IsEquiv	    ({|	       DiagramMap_obj :=	         fun n : Graph.graph0 sequence_graph =>	         Overture.nat_rect	           (fun n0 : nat =>	            forall x0 : {x : _ & A x},	            fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	           (fun x0 : {x : _ & A x} => idmap)	           (fun (n0 : nat)	              (e : forall x0 : {x : _ & A x},	                   fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	              (x0 : {x : _ & A x}) =>	            coe (ap B (seq_pair_shift_assoc x0 n0)) o e (x0) ^++) n x;	       DiagramMap_comm :=	         fun (n m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n m) =>	         match	           p as p0 in (_ = y)	           return	             (forall x0 : fib_seq_to_seq B x n,	              ((fib_seq_to_seq' B x) _f p0)	                (Overture.nat_rect	                   (fun n0 : nat =>	                    forall x1 : {x : _ & A x},	                    fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                   (fun x1 : {x : _ & A x} => idmap)	                   (fun (n0 : nat)	                      (e : forall x1 : {x : _ & A x},	                           fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                      (x1 : {x : _ & A x})	                      (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                    coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                   n x x0) =	              Overture.nat_rect	                (fun n0 : nat =>	                 forall x1 : {x : _ & A x},	                 fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                (fun x1 : {x : _ & A x} => idmap)	                (fun (n0 : nat)	                   (e : forall x1 : {x : _ & A x},	                        fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                   (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0)	                 => coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                y x (((fib_seq_to_seq B x) _f p0) x0))	         with	         | 1 =>	             Overture.nat_rect	               (fun n0 : nat =>	                forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n0),	                (Overture.nat_rect	                   (fun n1 : nat =>	                    forall x2 : {x : _ & A x},	                    fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                   (fun x2 : {x : _ & A x} => idmap)	                   (fun (n1 : nat)	                      (e : forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                      (x2 : {x : _ & A x})	                      (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                    coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                   n0 x0 x1) ^+ =	                Overture.nat_rect	                  (fun n1 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n1 : nat)	                     (e : forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n1)	                   => coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                  n0.+1 x0 (x1) ^+)	               (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	               (fun (n0 : nat)	                  (p0 : forall (x0 : {x : _ & A x})	                        (x1 : fib_seq_to_seq B x0 n0),	                        (Overture.nat_rect	                           (fun n1 : nat =>	                            forall x2 : {x : _ & A x},	                            fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                           (fun x2 : {x : _ & A x} => idmap)	                           (fun (n1 : nat)	                              (e : forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n1 ->	                                   fib_seq_to_seq' B x2 n1)	                              (x2 : {x : _ & A x})	                              (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                            coe (ap B (seq_pair_shift_assoc x2 n1))	                              (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                        Overture.nat_rect	                          (fun n1 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n1 : nat)	                             (e : forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n1 ->	                                  fib_seq_to_seq' B x2 n1)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                           coe (ap B (seq_pair_shift_assoc x2 n1))	                             (e (x2) ^++ x3)) n0.+1 x0 	                          (x1) ^+) (x0 : {x : _ & A x})	                  (b : fib_seq_to_seq B x0 n0.+1) =>	                K seq_pair_shift (fibSequenceArr B)	                  (seq_pair_shift_assoc x0 n0) @	                ap	                  (coe	                     (ap B (ap seq_pair_shift (seq_pair_shift_assoc x0 n0))))	                  (p0 (x0) ^++ b)) n x	         end	     |} i)	2 goals (ID 738)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall x : {x : _ & A x},	  IsEquiv	    ({|	       DiagramMap_obj :=	         fun n : Graph.graph0 sequence_graph =>	         Overture.nat_rect	           (fun n0 : nat =>	            forall x0 : {x : _ & A x},	            fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	           (fun x0 : {x : _ & A x} => idmap)	           (fun (n0 : nat)	              (e : forall x0 : {x : _ & A x},	                   fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	              (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B (x0) ^++ n0) =>	            coe (ap B (seq_pair_shift_assoc x0 n0)) (e (x0) ^++ x1)) n x;	       DiagramMap_comm :=	         fun (n m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n m) =>	         match	           p as p0 in (_ = y)	           return	             (forall x0 : fib_seq_to_seq B x n,	              ((fib_seq_to_seq' B x) _f p0)	                (Overture.nat_rect	                   (fun n0 : nat =>	                    forall x1 : {x : _ & A x},	                    fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                   (fun x1 : {x : _ & A x} => idmap)	                   (fun (n0 : nat)	                      (e : forall x1 : {x : _ & A x},	                           fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                      (x1 : {x : _ & A x})	                      (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                    coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                   n x x0) =	              Overture.nat_rect	                (fun n0 : nat =>	                 forall x1 : {x : _ & A x},	                 fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                (fun x1 : {x : _ & A x} => idmap)	                (fun (n0 : nat)	                   (e : forall x1 : {x : _ & A x},	                        fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                   (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0)	                 => coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                y x (((fib_seq_to_seq B x) _f p0) x0))	         with	         | 1 =>	             Overture.nat_rect	               (fun n0 : nat =>	                forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n0),	                (Overture.nat_rect	                   (fun n1 : nat =>	                    forall x2 : {x : _ & A x},	                    fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                   (fun x2 : {x : _ & A x} => idmap)	                   (fun (n1 : nat)	                      (e : forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                      (x2 : {x : _ & A x})	                      (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                    coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                   n0 x0 x1) ^+ =	                Overture.nat_rect	                  (fun n1 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n1 : nat)	                     (e : forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n1)	                   => coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                  n0.+1 x0 (x1) ^+)	               (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	               (fun (n0 : nat)	                  (p0 : forall (x0 : {x : _ & A x})	                        (x1 : fib_seq_to_seq B x0 n0),	                        (Overture.nat_rect	                           (fun n1 : nat =>	                            forall x2 : {x : _ & A x},	                            fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                           (fun x2 : {x : _ & A x} => idmap)	                           (fun (n1 : nat)	                              (e : forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n1 ->	                                   fib_seq_to_seq' B x2 n1)	                              (x2 : {x : _ & A x})	                              (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                            coe (ap B (seq_pair_shift_assoc x2 n1))	                              (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                        Overture.nat_rect	                          (fun n1 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n1 : nat)	                             (e : forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n1 ->	                                  fib_seq_to_seq' B x2 n1)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                           coe (ap B (seq_pair_shift_assoc x2 n1))	                             (e (x2) ^++ x3)) n0.+1 x0 	                          (x1) ^+) (x0 : {x : _ & A x})	                  (b : fib_seq_to_seq B x0 n0.+1) =>	                K seq_pair_shift (fibSequenceArr B)	                  (seq_pair_shift_assoc x0 n0) @	                ap	                  (coe	                     (ap B (ap seq_pair_shift (seq_pair_shift_assoc x0 n0))))	                  (p0 (x0) ^++ b)) n x	         end	     |} 0)		goal 2 (ID 741) is:	 forall x : {x : _ & A x},	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n0 : Graph.graph0 sequence_graph =>	        Overture.nat_rect	          (fun n1 : nat =>	           forall x0 : {x : _ & A x},	           fib_seq_to_seq B x0 n1 -> fib_seq_to_seq' B x0 n1)	          (fun x0 : {x : _ & A x} => idmap)	          (fun (n1 : nat)	             (e0 : forall x0 : {x : _ & A x},	                   fib_seq_to_seq B x0 n1 -> fib_seq_to_seq' B x0 n1)	             (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B (x0) ^++ n1) =>	           coe (ap B (seq_pair_shift_assoc x0 n1)) (e0 (x0) ^++ x1)) n0 x;	      DiagramMap_comm :=	        fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) =>	        match	          p as p0 in (_ = y)	          return	            (forall x0 : fib_seq_to_seq B x n0,	             ((fib_seq_to_seq' B x) _f p0)	               (Overture.nat_rect	                  (fun n1 : nat =>	                   forall x1 : {x : _ & A x},	                   fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                  (fun x1 : {x : _ & A x} => idmap)	                  (fun (n1 : nat)	                     (e0 : forall x1 : {x : _ & A x},	                           fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                     (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n1)	                   =>	                   coe (ap B (seq_pair_shift_assoc x1 n1)) (e0 (x1) ^++ x2))	                  n0 x x0) =	             Overture.nat_rect	               (fun n1 : nat =>	                forall x1 : {x : _ & A x},	                fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	               (fun x1 : {x : _ & A x} => idmap)	               (fun (n1 : nat)	                  (e0 : forall x1 : {x : _ & A x},	                        fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                  (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n1) =>	                coe (ap B (seq_pair_shift_assoc x1 n1)) (e0 (x1) ^++ x2)) y x	               (((fib_seq_to_seq B x) _f p0) x0))	        with	        | 1 =>	            Overture.nat_rect	              (fun n1 : nat =>	               forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n1),	               (Overture.nat_rect	                  (fun n2 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n2 : nat)	                     (e0 : forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n2)	                   =>	                   coe (ap B (seq_pair_shift_assoc x2 n2)) (e0 (x2) ^++ x3))	                  n1 x0 x1) ^+ =	               Overture.nat_rect	                 (fun n2 : nat =>	                  forall x2 : {x : _ & A x},	                  fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                 (fun x2 : {x : _ & A x} => idmap)	                 (fun (n2 : nat)	                    (e0 : forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                    (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n2)	                  => coe (ap B (seq_pair_shift_assoc x2 n2)) (e0 (x2) ^++ x3))	                 n1.+1 x0 (x1) ^+)	              (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	              (fun (n1 : nat)	                 (p0 : forall (x0 : {x : _ & A x})	                       (x1 : fib_seq_to_seq B x0 n1),	                       (Overture.nat_rect	                          (fun n2 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n2 : nat)	                             (e0 : forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n2 ->	                                   fib_seq_to_seq' B x2 n2)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                           coe (ap B (seq_pair_shift_assoc x2 n2))	                             (e0 (x2) ^++ x3)) n1 x0 x1) ^+ =	                       Overture.nat_rect	                         (fun n2 : nat =>	                          forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                         (fun x2 : {x : _ & A x} => idmap)	                         (fun (n2 : nat)	                            (e0 : forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n2 ->	                                  fib_seq_to_seq' B x2 n2)	                            (x2 : {x : _ & A x})	                            (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                          coe (ap B (seq_pair_shift_assoc x2 n2))	                            (e0 (x2) ^++ x3)) n1.+1 x0 	                         (x1) ^+) (x0 : {x : _ & A x})	                 (b : fib_seq_to_seq B x0 n1.+1) =>	               K seq_pair_shift (fibSequenceArr B)	                 (seq_pair_shift_assoc x0 n1) @	               ap	                 (coe (ap B (ap seq_pair_shift (seq_pair_shift_assoc x0 n1))))	                 (p0 (x0) ^++ b)) n0 x	        end	    |} n.+1)	";
            responses[i]=data;
          

            i = 299;
            data = "1 goal (ID 738)	  	  A : Sequence	  B : FibSequence A	  ============================	  forall x : {x : _ & A x},	  IsEquiv	    ({|	       DiagramMap_obj :=	         fun n : Graph.graph0 sequence_graph =>	         Overture.nat_rect	           (fun n0 : nat =>	            forall x0 : {x : _ & A x},	            fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	           (fun x0 : {x : _ & A x} => idmap)	           (fun (n0 : nat)	              (e : forall x0 : {x : _ & A x},	                   fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	              (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B (x0) ^++ n0) =>	            coe (ap B (seq_pair_shift_assoc x0 n0)) (e (x0) ^++ x1)) n x;	       DiagramMap_comm :=	         fun (n m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n m) =>	         match	           p as p0 in (_ = y)	           return	             (forall x0 : fib_seq_to_seq B x n,	              ((fib_seq_to_seq' B x) _f p0)	                (Overture.nat_rect	                   (fun n0 : nat =>	                    forall x1 : {x : _ & A x},	                    fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                   (fun x1 : {x : _ & A x} => idmap)	                   (fun (n0 : nat)	                      (e : forall x1 : {x : _ & A x},	                           fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                      (x1 : {x : _ & A x})	                      (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                    coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                   n x x0) =	              Overture.nat_rect	                (fun n0 : nat =>	                 forall x1 : {x : _ & A x},	                 fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                (fun x1 : {x : _ & A x} => idmap)	                (fun (n0 : nat)	                   (e : forall x1 : {x : _ & A x},	                        fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                   (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n0)	                 => coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                y x (((fib_seq_to_seq B x) _f p0) x0))	         with	         | 1 =>	             Overture.nat_rect	               (fun n0 : nat =>	                forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n0),	                (Overture.nat_rect	                   (fun n1 : nat =>	                    forall x2 : {x : _ & A x},	                    fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                   (fun x2 : {x : _ & A x} => idmap)	                   (fun (n1 : nat)	                      (e : forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                      (x2 : {x : _ & A x})	                      (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                    coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                   n0 x0 x1) ^+ =	                Overture.nat_rect	                  (fun n1 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n1 : nat)	                     (e : forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n1)	                   => coe (ap B (seq_pair_shift_assoc x2 n1)) (e (x2) ^++ x3))	                  n0.+1 x0 (x1) ^+)	               (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	               (fun (n0 : nat)	                  (p0 : forall (x0 : {x : _ & A x})	                        (x1 : fib_seq_to_seq B x0 n0),	                        (Overture.nat_rect	                           (fun n1 : nat =>	                            forall x2 : {x : _ & A x},	                            fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                           (fun x2 : {x : _ & A x} => idmap)	                           (fun (n1 : nat)	                              (e : forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n1 ->	                                   fib_seq_to_seq' B x2 n1)	                              (x2 : {x : _ & A x})	                              (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                            coe (ap B (seq_pair_shift_assoc x2 n1))	                              (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                        Overture.nat_rect	                          (fun n1 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n1 : nat)	                             (e : forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n1 ->	                                  fib_seq_to_seq' B x2 n1)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                           coe (ap B (seq_pair_shift_assoc x2 n1))	                             (e (x2) ^++ x3)) n0.+1 x0 	                          (x1) ^+) (x0 : {x : _ & A x})	                  (b : fib_seq_to_seq B x0 n0.+1) =>	                K seq_pair_shift (fibSequenceArr B)	                  (seq_pair_shift_assoc x0 n0) @	                ap	                  (coe	                     (ap B (ap seq_pair_shift (seq_pair_shift_assoc x0 n0))))	                  (p0 (x0) ^++ b)) n x	         end	     |} 0)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 goal		goal 1 (ID 741) is:	 forall x : {x : _ & A x},	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n0 : Graph.graph0 sequence_graph =>	        Overture.nat_rect	          (fun n1 : nat =>	           forall x0 : {x : _ & A x},	           fib_seq_to_seq B x0 n1 -> fib_seq_to_seq' B x0 n1)	          (fun x0 : {x : _ & A x} => idmap)	          (fun (n1 : nat)	             (e0 : forall x0 : {x : _ & A x},	                   fib_seq_to_seq B x0 n1 -> fib_seq_to_seq' B x0 n1)	             (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B (x0) ^++ n1) =>	           coe (ap B (seq_pair_shift_assoc x0 n1)) (e0 (x0) ^++ x1)) n0 x;	      DiagramMap_comm :=	        fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) =>	        match	          p as p0 in (_ = y)	          return	            (forall x0 : fib_seq_to_seq B x n0,	             ((fib_seq_to_seq' B x) _f p0)	               (Overture.nat_rect	                  (fun n1 : nat =>	                   forall x1 : {x : _ & A x},	                   fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                  (fun x1 : {x : _ & A x} => idmap)	                  (fun (n1 : nat)	                     (e0 : forall x1 : {x : _ & A x},	                           fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                     (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n1)	                   =>	                   coe (ap B (seq_pair_shift_assoc x1 n1)) (e0 (x1) ^++ x2))	                  n0 x x0) =	             Overture.nat_rect	               (fun n1 : nat =>	                forall x1 : {x : _ & A x},	                fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	               (fun x1 : {x : _ & A x} => idmap)	               (fun (n1 : nat)	                  (e0 : forall x1 : {x : _ & A x},	                        fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                  (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n1) =>	                coe (ap B (seq_pair_shift_assoc x1 n1)) (e0 (x1) ^++ x2)) y x	               (((fib_seq_to_seq B x) _f p0) x0))	        with	        | 1 =>	            Overture.nat_rect	              (fun n1 : nat =>	               forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n1),	               (Overture.nat_rect	                  (fun n2 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n2 : nat)	                     (e0 : forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n2)	                   =>	                   coe (ap B (seq_pair_shift_assoc x2 n2)) (e0 (x2) ^++ x3))	                  n1 x0 x1) ^+ =	               Overture.nat_rect	                 (fun n2 : nat =>	                  forall x2 : {x : _ & A x},	                  fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                 (fun x2 : {x : _ & A x} => idmap)	                 (fun (n2 : nat)	                    (e0 : forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                    (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n2)	                  => coe (ap B (seq_pair_shift_assoc x2 n2)) (e0 (x2) ^++ x3))	                 n1.+1 x0 (x1) ^+)	              (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	              (fun (n1 : nat)	                 (p0 : forall (x0 : {x : _ & A x})	                       (x1 : fib_seq_to_seq B x0 n1),	                       (Overture.nat_rect	                          (fun n2 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n2 : nat)	                             (e0 : forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n2 ->	                                   fib_seq_to_seq' B x2 n2)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                           coe (ap B (seq_pair_shift_assoc x2 n2))	                             (e0 (x2) ^++ x3)) n1 x0 x1) ^+ =	                       Overture.nat_rect	                         (fun n2 : nat =>	                          forall x2 : {x : _ & A x},	                          fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                         (fun x2 : {x : _ & A x} => idmap)	                         (fun (n2 : nat)	                            (e0 : forall x2 : {x : _ & A x},	                                  fib_seq_to_seq B x2 n2 ->	                                  fib_seq_to_seq' B x2 n2)	                            (x2 : {x : _ & A x})	                            (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                          coe (ap B (seq_pair_shift_assoc x2 n2))	                            (e0 (x2) ^++ x3)) n1.+1 x0 	                         (x1) ^+) (x0 : {x : _ & A x})	                 (b : fib_seq_to_seq B x0 n1.+1) =>	               K seq_pair_shift (fibSequenceArr B)	                 (seq_pair_shift_assoc x0 n1) @	               ap	                 (coe (ap B (ap seq_pair_shift (seq_pair_shift_assoc x0 n1))))	                 (p0 (x0) ^++ b)) n0 x	        end	    |} n.+1)	";
            responses[i]=data;
          

            i = 300;
            data = "1 goal (ID 741)	  	  A : Sequence	  B : FibSequence A	  n : nat	  e : forall x : {x : _ & A x},	      IsEquiv	        ({|	           DiagramMap_obj :=	             fun n : Graph.graph0 sequence_graph =>	             Overture.nat_rect	               (fun n0 : nat =>	                forall x0 : {x : _ & A x},	                fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	               (fun x0 : {x : _ & A x} => idmap)	               (fun (n0 : nat)	                  (e : forall x0 : {x : _ & A x},	                       fib_seq_to_seq B x0 n0 -> fib_seq_to_seq' B x0 n0)	                  (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B (x0) ^++ n0) =>	                coe (ap B (seq_pair_shift_assoc x0 n0)) (e (x0) ^++ x1)) n x;	           DiagramMap_comm :=	             fun (n m : Graph.graph0 sequence_graph)	               (p : Graph.graph1 sequence_graph n m) =>	             match	               p as p0 in (_ = y)	               return	                 (forall x0 : fib_seq_to_seq B x n,	                  ((fib_seq_to_seq' B x) _f p0)	                    (Overture.nat_rect	                       (fun n0 : nat =>	                        forall x1 : {x : _ & A x},	                        fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                       (fun x1 : {x : _ & A x} => idmap)	                       (fun (n0 : nat)	                          (e : forall x1 : {x : _ & A x},	                               fib_seq_to_seq B x1 n0 ->	                               fib_seq_to_seq' B x1 n0) 	                          (x1 : {x : _ & A x})	                          (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                        coe (ap B (seq_pair_shift_assoc x1 n0))	                          (e (x1) ^++ x2)) n x x0) =	                  Overture.nat_rect	                    (fun n0 : nat =>	                     forall x1 : {x : _ & A x},	                     fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                    (fun x1 : {x : _ & A x} => idmap)	                    (fun (n0 : nat)	                       (e : forall x1 : {x : _ & A x},	                            fib_seq_to_seq B x1 n0 -> fib_seq_to_seq' B x1 n0)	                       (x1 : {x : _ & A x})	                       (x2 : fib_seq_to_seq B (x1) ^++ n0) =>	                     coe (ap B (seq_pair_shift_assoc x1 n0)) (e (x1) ^++ x2))	                    y x (((fib_seq_to_seq B x) _f p0) x0))	             with	             | 1 =>	                 Overture.nat_rect	                   (fun n0 : nat =>	                    forall (x0 : {x : _ & A x})	                    (x1 : fib_seq_to_seq B x0 n0),	                    (Overture.nat_rect	                       (fun n1 : nat =>	                        forall x2 : {x : _ & A x},	                        fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                       (fun x2 : {x : _ & A x} => idmap)	                       (fun (n1 : nat)	                          (e : forall x2 : {x : _ & A x},	                               fib_seq_to_seq B x2 n1 ->	                               fib_seq_to_seq' B x2 n1) 	                          (x2 : {x : _ & A x})	                          (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                        coe (ap B (seq_pair_shift_assoc x2 n1))	                          (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                    Overture.nat_rect	                      (fun n1 : nat =>	                       forall x2 : {x : _ & A x},	                       fib_seq_to_seq B x2 n1 -> fib_seq_to_seq' B x2 n1)	                      (fun x2 : {x : _ & A x} => idmap)	                      (fun (n1 : nat)	                         (e : forall x2 : {x : _ & A x},	                              fib_seq_to_seq B x2 n1 ->	                              fib_seq_to_seq' B x2 n1) 	                         (x2 : {x : _ & A x})	                         (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                       coe (ap B (seq_pair_shift_assoc x2 n1))	                         (e (x2) ^++ x3)) n0.+1 x0 	                      (x1) ^+)	                   (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) =>	                    1)	                   (fun (n0 : nat)	                      (p0 : forall (x0 : {x : _ & A x})	                            (x1 : fib_seq_to_seq B x0 n0),	                            (Overture.nat_rect	                               (fun n1 : nat =>	                                forall x2 : {x : _ & A x},	                                fib_seq_to_seq B x2 n1 ->	                                fib_seq_to_seq' B x2 n1)	                               (fun x2 : {x : _ & A x} => idmap)	                               (fun (n1 : nat)	                                  (e : forall x2 : {x : _ & A x},	                                       fib_seq_to_seq B x2 n1 ->	                                       fib_seq_to_seq' B x2 n1)	                                  (x2 : {x : _ & A x})	                                  (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                                coe (ap B (seq_pair_shift_assoc x2 n1))	                                  (e (x2) ^++ x3)) n0 x0 x1) ^+ =	                            Overture.nat_rect	                              (fun n1 : nat =>	                               forall x2 : {x : _ & A x},	                               fib_seq_to_seq B x2 n1 ->	                               fib_seq_to_seq' B x2 n1)	                              (fun x2 : {x : _ & A x} => idmap)	                              (fun (n1 : nat)	                                 (e : forall x2 : {x : _ & A x},	                                      fib_seq_to_seq B x2 n1 ->	                                      fib_seq_to_seq' B x2 n1)	                                 (x2 : {x : _ & A x})	                                 (x3 : fib_seq_to_seq B (x2) ^++ n1) =>	                               coe (ap B (seq_pair_shift_assoc x2 n1))	                                 (e (x2) ^++ x3)) n0.+1 x0 	                              (x1) ^+) (x0 : {x : _ & A x})	                      (b : fib_seq_to_seq B x0 n0.+1) =>	                    K seq_pair_shift (fibSequenceArr B)	                      (seq_pair_shift_assoc x0 n0) @	                    ap	                      (coe	                         (ap B	                            (ap seq_pair_shift (seq_pair_shift_assoc x0 n0))))	                      (p0 (x0) ^++ b)) n x	             end	         |} n)	  ============================	  forall x : {x : _ & A x},	  IsEquiv	    ({|	       DiagramMap_obj :=	         fun n0 : Graph.graph0 sequence_graph =>	         Overture.nat_rect	           (fun n1 : nat =>	            forall x0 : {x : _ & A x},	            fib_seq_to_seq B x0 n1 -> fib_seq_to_seq' B x0 n1)	           (fun x0 : {x : _ & A x} => idmap)	           (fun (n1 : nat)	              (e0 : forall x0 : {x : _ & A x},	                    fib_seq_to_seq B x0 n1 -> fib_seq_to_seq' B x0 n1)	              (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B (x0) ^++ n1) =>	            coe (ap B (seq_pair_shift_assoc x0 n1)) (e0 (x0) ^++ x1)) n0 x;	       DiagramMap_comm :=	         fun (n0 m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n0 m) =>	         match	           p as p0 in (_ = y)	           return	             (forall x0 : fib_seq_to_seq B x n0,	              ((fib_seq_to_seq' B x) _f p0)	                (Overture.nat_rect	                   (fun n1 : nat =>	                    forall x1 : {x : _ & A x},	                    fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                   (fun x1 : {x : _ & A x} => idmap)	                   (fun (n1 : nat)	                      (e0 : forall x1 : {x : _ & A x},	                            fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                      (x1 : {x : _ & A x})	                      (x2 : fib_seq_to_seq B (x1) ^++ n1) =>	                    coe (ap B (seq_pair_shift_assoc x1 n1)) (e0 (x1) ^++ x2))	                   n0 x x0) =	              Overture.nat_rect	                (fun n1 : nat =>	                 forall x1 : {x : _ & A x},	                 fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                (fun x1 : {x : _ & A x} => idmap)	                (fun (n1 : nat)	                   (e0 : forall x1 : {x : _ & A x},	                         fib_seq_to_seq B x1 n1 -> fib_seq_to_seq' B x1 n1)	                   (x1 : {x : _ & A x}) (x2 : fib_seq_to_seq B (x1) ^++ n1)	                 => coe (ap B (seq_pair_shift_assoc x1 n1)) (e0 (x1) ^++ x2))	                y x (((fib_seq_to_seq B x) _f p0) x0))	         with	         | 1 =>	             Overture.nat_rect	               (fun n1 : nat =>	                forall (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 n1),	                (Overture.nat_rect	                   (fun n2 : nat =>	                    forall x2 : {x : _ & A x},	                    fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                   (fun x2 : {x : _ & A x} => idmap)	                   (fun (n2 : nat)	                      (e0 : forall x2 : {x : _ & A x},	                            fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                      (x2 : {x : _ & A x})	                      (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                    coe (ap B (seq_pair_shift_assoc x2 n2)) (e0 (x2) ^++ x3))	                   n1 x0 x1) ^+ =	                Overture.nat_rect	                  (fun n2 : nat =>	                   forall x2 : {x : _ & A x},	                   fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                  (fun x2 : {x : _ & A x} => idmap)	                  (fun (n2 : nat)	                     (e0 : forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                     (x2 : {x : _ & A x}) (x3 : fib_seq_to_seq B (x2) ^++ n2)	                   =>	                   coe (ap B (seq_pair_shift_assoc x2 n2)) (e0 (x2) ^++ x3))	                  n1.+1 x0 (x1) ^+)	               (fun (x0 : {x : _ & A x}) (x1 : fib_seq_to_seq B x0 0) => 1)	               (fun (n1 : nat)	                  (p0 : forall (x0 : {x : _ & A x})	                        (x1 : fib_seq_to_seq B x0 n1),	                        (Overture.nat_rect	                           (fun n2 : nat =>	                            forall x2 : {x : _ & A x},	                            fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                           (fun x2 : {x : _ & A x} => idmap)	                           (fun (n2 : nat)	                              (e0 : forall x2 : {x : _ & A x},	                                    fib_seq_to_seq B x2 n2 ->	                                    fib_seq_to_seq' B x2 n2)	                              (x2 : {x : _ & A x})	                              (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                            coe (ap B (seq_pair_shift_assoc x2 n2))	                              (e0 (x2) ^++ x3)) n1 x0 x1) ^+ =	                        Overture.nat_rect	                          (fun n2 : nat =>	                           forall x2 : {x : _ & A x},	                           fib_seq_to_seq B x2 n2 -> fib_seq_to_seq' B x2 n2)	                          (fun x2 : {x : _ & A x} => idmap)	                          (fun (n2 : nat)	                             (e0 : forall x2 : {x : _ & A x},	                                   fib_seq_to_seq B x2 n2 ->	                                   fib_seq_to_seq' B x2 n2)	                             (x2 : {x : _ & A x})	                             (x3 : fib_seq_to_seq B (x2) ^++ n2) =>	                           coe (ap B (seq_pair_shift_assoc x2 n2))	                             (e0 (x2) ^++ x3)) n1.+1 x0 	                          (x1) ^+) (x0 : {x : _ & A x})	                  (b : fib_seq_to_seq B x0 n1.+1) =>	                K seq_pair_shift (fibSequenceArr B)	                  (seq_pair_shift_assoc x0 n1) @	                ap	                  (coe	                     (ap B (ap seq_pair_shift (seq_pair_shift_assoc x0 n1))))	                  (p0 (x0) ^++ b)) n0 x	         end	     |} n.+1)	No more goals.	";
            responses[i]=data;
          

            i = 301;
            data = "";
            responses[i]=data;
          

            i = 302;
            data = "";
            responses[i]=data;
          

            i = 303;
            data = "";
            responses[i]=data;
          

            i = 304;
            data = "";
            responses[i]=data;
          

            i = 305;
            data = "";
            responses[i]=data;
          

            i = 306;
            data = "1 goal (ID 593)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  Colimit A -> Type	";
            responses[i]=data;
          

            i = 307;
            data = "";
            responses[i]=data;
          

            i = 308;
            data = "2 goals (ID 623)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> Type		goal 2 (ID 625) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j), ?legs j o A _f g == ?legs i	";
            responses[i]=data;
          

            i = 309;
            data = "1 goal (ID 623)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph, A i -> Type	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 625) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	  Colimit (fib_seq_to_seq B (n; a))) j o A _f g ==	 (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	  Colimit (fib_seq_to_seq B (n; a))) i	";
            responses[i]=data;
          

            i = 310;
            data = "1 goal (ID 625)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	   Colimit (fib_seq_to_seq B (n; a))) j o A _f g ==	  (fun (n : Graph.graph0 sequence_graph) (a : A n) =>	   Colimit (fib_seq_to_seq B (n; a))) i	1 goal (ID 645)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) <~>	  Colimit (fib_seq_to_seq B (n; a))	";
            responses[i]=data;
          

            i = 311;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 312;
            data = "";
            responses[i]=data;
          

            i = 313;
            data = "1 goal (ID 623)	  	  H : Univalence	  A : Diagram sequence_graph	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  coe (ap (fib_seq_to_type_fam B) (glue A n a)) =	  colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a))	";
            responses[i]=data;
          

            i = 314;
            data = "";
            responses[i]=data;
          

            i = 315;
            data = "1 goal (ID 649)	  	  H : Univalence	  A : Diagram sequence_graph	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  coe	    (legs_comm	       {|	         legs :=	           fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) =>	           Colimit (fib_seq_to_seq B (n0; a0));	         legs_comm :=	           fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) =>	           (fun a0 : A n0 =>	            match	              p as p0 in (_ = y)	              return	                (Colimit (fib_seq_to_seq B (y; (A _f p0) a0)) =	                 Colimit (fib_seq_to_seq B (n0; a0)))	            with	            | 1 =>	                path_universe_uncurried	                  (equiv_colim_succ_seq_to_colim_seq	                     (fib_seq_to_seq B (n0; a0)))	            end)	           :	           (fun (n1 : Graph.graph0 sequence_graph) (a0 : A n1) =>	            Colimit (fib_seq_to_seq B (n1; a0))) m o 	           A _f p ==	           (fun (n1 : Graph.graph0 sequence_graph) (a0 : A n1) =>	            Colimit (fib_seq_to_seq B (n1; a0))) n0	       |} n n.+1 1 a) = colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a))	";
            responses[i]=data;
          

            i = 316;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 317;
            data = "";
            responses[i]=data;
          

            i = 318;
            data = "1 goal (ID 659)	  	  X : Type	  Y : X -> Type	  x1, x2 : X	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  psi : coe (ap Y p) = F	  y : Y x1	  ============================	  (x1; y) = (x2; F y)	";
            responses[i]=data;
          

            i = 319;
            data = "";
            responses[i]=data;
          

            i = 320;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 321;
            data = "";
            responses[i]=data;
          

            i = 322;
            data = "1 goal (ID 699)	  	  X : Type	  Y : X -> Type	  x1, x2 : X	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  psi : coe (ap Y p) = F	  y : Y x1	  ============================	  ap pr1 (Delta p psi y) = p	";
            responses[i]=data;
          

            i = 323;
            data = "";
            responses[i]=data;
          

            i = 324;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 325;
            data = "";
            responses[i]=data;
          

            i = 326;
            data = "";
            responses[i]=data;
          

            i = 327;
            data = "";
            responses[i]=data;
          

            i = 328;
            data = "";
            responses[i]=data;
          

            i = 329;
            data = "";
            responses[i]=data;
          

            i = 330;
            data = "1 goal (ID 709)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  Colimit (sig_seq B) -> {x : _ & fib_seq_to_type_fam B x}	";
            responses[i]=data;
          

            i = 331;
            data = "";
            responses[i]=data;
          

            i = 332;
            data = "2 goals (ID 739)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph,	  sig_seq B i -> {x : _ & fib_seq_to_type_fam B x}		goal 2 (ID 741) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j), ?legs j o (sig_seq B) _f g == ?legs i	";
            responses[i]=data;
          

            i = 333;
            data = "1 goal (ID 739)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph,	  sig_seq B i -> {x : _ & fib_seq_to_type_fam B x}	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 741) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j),	 (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	  (fun (a : A n) (b : B (n; a)) =>	   (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)) X.1 X.2) j	 o (sig_seq B) _f g ==	 (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	  (fun (a : A n) (b : B (n; a)) =>	   (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)) X.1 X.2) i	";
            responses[i]=data;
          

            i = 334;
            data = "1 goal (ID 741)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j),	  (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	   (fun (a : A n) (b : B (n; a)) =>	    (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)) X.1 X.2) j	  o (sig_seq B) _f g ==	  (fun (n : Graph.graph0 sequence_graph) (X : sig_seq B n) =>	   (fun (a : A n) (b : B (n; a)) =>	    (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)) X.1 X.2) i	1 goal (ID 774)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  ============================	  (inj A n.+1 ((a; b)) ^+.1;	  inj (fib_seq_to_seq B (n.+1; ((a; b)) ^+.1)) 0 ((a; b)) ^+.2) =	  (inj A n a; inj (fib_seq_to_seq B (n; a)) 1 (b) ^+)	";
            responses[i]=data;
          

            i = 335;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 336;
            data = "";
            responses[i]=data;
          

            i = 337;
            data = "1 goal (ID 775)	  	  H : Univalence	  A : Diagram sequence_graph	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  b : (fun a : A n => B (n; a)) a	  ============================	  ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)) =	  Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a)	    (inj (fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2)) 0 (b) ^+) @	  ap (exist (fib_seq_to_type_fam B) (inj A n a))	    (glue (fib_seq_to_seq B (n; a)) 0 b)	";
            responses[i]=data;
          

            i = 338;
            data = "";
            responses[i]=data;
          

            i = 339;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 340;
            data = "";
            responses[i]=data;
          

            i = 341;
            data = "";
            responses[i]=data;
          

            i = 342;
            data = "";
            responses[i]=data;
          

            i = 343;
            data = "";
            responses[i]=data;
          

            i = 344;
            data = "";
            responses[i]=data;
          

            i = 345;
            data = "";
            responses[i]=data;
          

            i = 346;
            data = "<infomsg>H is declared</infomsg>	<infomsg>A is declared</infomsg>	<infomsg>B is declared</infomsg>	";
            responses[i]=data;
          

            i = 347;
            data = "<infomsg>E is declared</infomsg>	";
            responses[i]=data;
          

            i = 348;
            data = "<infomsg>e is declared</infomsg>	";
            responses[i]=data;
          

            i = 349;
            data = "<infomsg>t is declared</infomsg>	";
            responses[i]=data;
          

            i = 350;
            data = "";
            responses[i]=data;
          

            i = 351;
            data = "";
            responses[i]=data;
          

            i = 352;
            data = "";
            responses[i]=data;
          

            i = 353;
            data = "";
            responses[i]=data;
          

            i = 354;
            data = "1 goal (ID 843)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  k : Graph.graph0 sequence_graph	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B ((n; a).1; (n; a).2) k),	  E (inj A n a; inj (fib_seq_to_seq B ((n; a).1; (n; a).2)) k b)	";
            responses[i]=data;
          

            i = 355;
            data = "";
            responses[i]=data;
          

            i = 356;
            data = "2 goals (ID 847)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) 0),	  E (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)		goal 2 (ID 850) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n)	 (b : fib_seq_to_seq B (n; a) k.+1),	 E (inj A n a; inj (fib_seq_to_seq B (n; a)) k.+1 b)	";
            responses[i]=data;
          

            i = 357;
            data = "1 goal (ID 847)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) 0),	  E (inj A n a; inj (fib_seq_to_seq B (n; a)) 0 b)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 850) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n)	 (b : fib_seq_to_seq B (n; a) k.+1),	 E (inj A n a; inj (fib_seq_to_seq B (n; a)) k.+1 b)	";
            responses[i]=data;
          

            i = 358;
            data = "1 goal (ID 850)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  k : nat	  h : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : fib_seq_to_seq B (n; a) k),	      E (inj A n a; inj (fib_seq_to_seq B (n; a)) k b)	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) k.+1),	  E (inj A n a; inj (fib_seq_to_seq B (n; a)) k.+1 b)	No more goals.	";
            responses[i]=data;
          

            i = 359;
            data = "";
            responses[i]=data;
          

            i = 360;
            data = "";
            responses[i]=data;
          

            i = 361;
            data = "";
            responses[i]=data;
          

            i = 362;
            data = "";
            responses[i]=data;
          

            i = 363;
            data = "";
            responses[i]=data;
          

            i = 364;
            data = "1 goal (ID 918)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x : X	  y1, y2 : Y x	  z : {x : _ & Y x}	  p : y1 = y2	  q1 : z = (x; y1)	  q2 : z = (x; y2)	  theta : q2 = q1 @ ap (exist Y x) p	  ============================	  transport (Z o exist Y x) p o transport Z q1 == transport Z q2	";
            responses[i]=data;
          

            i = 365;
            data = "";
            responses[i]=data;
          

            i = 366;
            data = "1 goal (ID 943)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x : X	  y1 : Y x	  z : {x : _ & Y x}	  ============================	  (fun x0 : Z z => transport Z 1 x0) == transport Z (1 @ 1)	";
            responses[i]=data;
          

            i = 367;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 368;
            data = "";
            responses[i]=data;
          

            i = 369;
            data = "1 goal (ID 1029)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x1, x2 : X	  y1, y2 : Y x1	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  q : y1 = y2	  psi : coe (ap Y p) = F	  r : F y1 = F y2	  theta : ap F q = r	  ============================	  transport (Z o exist Y x2) r o transport Z (Delta p psi y1) ==	  transport Z (Delta p psi y2) o transport (Z o exist Y x1) q	";
            responses[i]=data;
          

            i = 370;
            data = "";
            responses[i]=data;
          

            i = 371;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 372;
            data = "";
            responses[i]=data;
          

            i = 373;
            data = "";
            responses[i]=data;
          

            i = 374;
            data = "";
            responses[i]=data;
          

            i = 375;
            data = "";
            responses[i]=data;
          

            i = 376;
            data = "";
            responses[i]=data;
          

            i = 377;
            data = "1 goal (ID 1068)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  k : Graph.graph0 sequence_graph	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B ((n; a).1; (n; a).2) k),	  transport (E o exist (fib_seq_to_type_fam B) (inj A n a))	    (glue (fib_seq_to_seq B ((n; a).1; (n; a).2)) k b) 	    (Q k.+1 n a (b) ^+) = Q k n a b	";
            responses[i]=data;
          

            i = 378;
            data = "";
            responses[i]=data;
          

            i = 379;
            data = "2 goals (ID 1072)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) 0),	  transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	    (colimp 0 1 1 b) (Q 1 n a (b) ^+) = Q 0 n a b		goal 2 (ID 1075) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n)	 (b : fib_seq_to_seq B (n; a) k.+1),	 transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	   (colimp k.+1 k.+2 1 b) (Q k.+2 n a (b) ^+) = Q k.+1 n a b	";
            responses[i]=data;
          

            i = 380;
            data = "1 goal (ID 1072)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) 0),	  transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	    (colimp 0 1 1 b) (Q 1 n a (b) ^+) = Q 0 n a b	1 goal (ID 1084)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : fib_seq_to_seq B (n; a) 0	  ============================	  transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	    (colimp 0 1 1 b) (Q 1 n a (b) ^+) =	  transport E	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	    (e n.+1 (a) ^+ (b) ^+f)	";
            responses[i]=data;
          

            i = 381;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 1075) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n)	 (b : fib_seq_to_seq B (n; a) k.+1),	 transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	   (colimp k.+1 k.+2 1 b) (Q k.+2 n a (b) ^+) = Q k.+1 n a b	";
            responses[i]=data;
          

            i = 382;
            data = "1 goal (ID 1075)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  k : nat	  h : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : fib_seq_to_seq B (n; a) k),	      transport	        (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	        (colimp k k.+1 1 b) (Q k.+1 n a (b) ^+) = 	      Q k n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : fib_seq_to_seq B (n; a) k.+1),	  transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	    (colimp k.+1 k.+2 1 b) (Q k.+2 n a (b) ^+) = Q k.+1 n a b	1 goal (ID 1119)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  k : nat	  h : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : fib_seq_to_seq B (n; a) k),	      transport	        (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	        (colimp k k.+1 1 b) (Q k.+1 n a (b) ^+) = 	      Q k n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : fib_seq_to_seq B (n; a) k.+1	  ============================	  transport (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	    (colimp k.+1 k.+2 1 b) (Q k.+2 n a (b) ^+) =	  transport E	    (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a)	       (inj (fib_seq_to_seq B (n.+1; (a) ^+)) k b))	    (transport	       (fun x : fib_seq_to_type_fam B (inj A n.+1 (a) ^+) =>	        E (inj A n.+1 (a) ^+; x)) (colimp k k.+1 1 b)	       (Q k.+1 n.+1 (a) ^+ (b) ^+))	";
            responses[i]=data;
          

            i = 383;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 384;
            data = "";
            responses[i]=data;
          

            i = 385;
            data = "";
            responses[i]=data;
          

            i = 386;
            data = "";
            responses[i]=data;
          

            i = 387;
            data = "";
            responses[i]=data;
          

            i = 388;
            data = "";
            responses[i]=data;
          

            i = 389;
            data = "1 goal (ID 1081)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall x : fib_seq_to_type_fam B (inj A n a), E (inj A n a; x)	";
            responses[i]=data;
          

            i = 390;
            data = "";
            responses[i]=data;
          

            i = 391;
            data = "2 goals (ID 1099)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i : Graph.graph0 sequence_graph)	  (x : fib_seq_to_seq B ((n; a).1; (n; a).2) i),	  (fun w : Colimit (fib_seq_to_seq B ((n; a).1; (n; a).2)) =>	   E (inj A n a; w)) (inj (fib_seq_to_seq B ((n; a).1; (n; a).2)) i x)		goal 2 (ID 1101) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j)	 (x : fib_seq_to_seq B ((n; a).1; (n; a).2) i),	 transport	   (fun w : Colimit (fib_seq_to_seq B ((n; a).1; (n; a).2)) =>	    E (inj A n a; w)) (colimp i j g x)	   (?q j (((fib_seq_to_seq B ((n; a).1; (n; a).2)) _f g) x)) = 	 ?q i x	";
            responses[i]=data;
          

            i = 392;
            data = "1 goal (ID 1099)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i : Graph.graph0 sequence_graph)	  (x : fib_seq_to_seq B ((n; a).1; (n; a).2) i),	  (fun w : Colimit (fib_seq_to_seq B ((n; a).1; (n; a).2)) =>	   E (inj A n a; w)) (inj (fib_seq_to_seq B ((n; a).1; (n; a).2)) i x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 1101) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j)	 (x : fib_seq_to_seq B ((n; a).1; (n; a).2) i),	 transport	   (fun w : Colimit (fib_seq_to_seq B ((n; a).1; (n; a).2)) =>	    E (inj A n a; w)) (colimp i j g x)	   ((fun k : Graph.graph0 sequence_graph => Q k n a) j	      (((fib_seq_to_seq B ((n; a).1; (n; a).2)) _f g) x)) =	 (fun k : Graph.graph0 sequence_graph => Q k n a) i x	";
            responses[i]=data;
          

            i = 393;
            data = "1 goal (ID 1101)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j)	  (x : fib_seq_to_seq B ((n; a).1; (n; a).2) i),	  transport	    (fun w : Colimit (fib_seq_to_seq B ((n; a).1; (n; a).2)) =>	     E (inj A n a; w)) (colimp i j g x)	    ((fun k : Graph.graph0 sequence_graph => Q k n a) j	       (((fib_seq_to_seq B ((n; a).1; (n; a).2)) _f g) x)) =	  (fun k : Graph.graph0 sequence_graph => Q k n a) i x	No more goals.	";
            responses[i]=data;
          

            i = 394;
            data = "";
            responses[i]=data;
          

            i = 395;
            data = "1 goal (ID 1100)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : fib_seq_to_seq B ((n; a).1; (n; a).2) 0	  ============================	  apD (F n a) (glue (fib_seq_to_seq B ((n; a).1; (n; a).2)) 0 b) = R 0 n a b	";
            responses[i]=data;
          

            i = 396;
            data = "";
            responses[i]=data;
          

            i = 397;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 398;
            data = "";
            responses[i]=data;
          

            i = 399;
            data = "1 goal (ID 1240)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x1, x2 : X	  y1, y2 : Y x1	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  q : y1 = y2	  psi : coe (ap Y p) = F	  G1 : forall y : Y x1, Z (x1; y)	  G2 : forall y : Y x2, Z (x2; y)	  r : F y1 = F y2	  theta : ap F q = r	  ============================	  forall (u1 : G2 (F y1) = transport Z (Delta p psi y1) (G1 y1))	  (u2 : G2 (F y2) = transport Z (Delta p psi y2) (G1 y2)),	  apD G2 r @ u2 =	  (ap (transport (fun x : Y x2 => Z (x2; x)) r) u1 @ Epsilon p theta (G1 y1)) @	  ap (transport Z (Delta p psi y2)) (apD G1 q) ->	  transport (fun y : Y x1 => G2 (F y) = transport Z (Delta p psi y) (G1 y)) q	    u1 = u2	";
            responses[i]=data;
          

            i = 400;
            data = "";
            responses[i]=data;
          

            i = 401;
            data = "1 goal (ID 1265)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x1, x2 : X	  y1 : Y x1	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  psi : coe (ap Y p) = F	  G1 : forall y : Y x1, Z (x1; y)	  G2 : forall y : Y x2, Z (x2; y)	  u1, u2 : G2 (F y1) = transport Z (Delta p psi y1) (G1 y1)	  ============================	  apD G2 (ap F 1) @ u2 = u1 ->	  transport (fun y : Y x1 => G2 (F y) = transport Z (Delta p psi y) (G1 y)) 1	    u1 = u2	";
            responses[i]=data;
          

            i = 402;
            data = "1 goal (ID 1272)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  x1, x2 : X	  y1 : Y x1	  F : idmap (Y x1) -> idmap (Y x2)	  p : x1 = x2	  psi : coe (ap Y p) = F	  G1 : forall y : Y x1, Z (x1; y)	  G2 : forall y : Y x2, Z (x2; y)	  u1, u2 : G2 (F y1) = transport Z (Delta p psi y1) (G1 y1)	  ============================	  1 @ u2 = u1 -> u1 = u2	";
            responses[i]=data;
          

            i = 403;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 404;
            data = "";
            responses[i]=data;
          

            i = 405;
            data = "";
            responses[i]=data;
          

            i = 406;
            data = "";
            responses[i]=data;
          

            i = 407;
            data = "";
            responses[i]=data;
          

            i = 408;
            data = "";
            responses[i]=data;
          

            i = 409;
            data = "1 goal (ID 1273)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall y : fib_seq_to_type_fam B (inj A n.+1 (a) ^+),	  F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) y) =	  transport E	    (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) y)	    (F n.+1 (a) ^+ y)	";
            responses[i]=data;
          

            i = 410;
            data = "";
            responses[i]=data;
          

            i = 411;
            data = "2 goals (ID 1291)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i : Graph.graph0 sequence_graph)	  (x : fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2) i),	  (fun w : Colimit (fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2)) =>	   F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	   transport E	     (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	     (F n.+1 (a) ^+ w))	    (inj (fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2)) i x)		goal 2 (ID 1293) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j)	 (x : fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2) i),	 transport	   (fun w : Colimit (fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2))	    =>	    F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	    transport E	      (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	      (F n.+1 (a) ^+ w)) (colimp i j g x)	   (?q j (((fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2)) _f g) x)) =	 ?q i x	";
            responses[i]=data;
          

            i = 412;
            data = "1 goal (ID 1291)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i : Graph.graph0 sequence_graph)	  (x : fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2) i),	  (fun w : Colimit (fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2)) =>	   F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	   transport E	     (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	     (F n.+1 (a) ^+ w))	    (inj (fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2)) i x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 1293) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j)	 (x : fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2) i),	 transport	   (fun w : Colimit (fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2))	    =>	    F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	    transport E	      (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	      (F n.+1 (a) ^+ w)) (colimp i j g x)	   ((fun (k : Graph.graph0 sequence_graph)	       (b : fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2) k) => 1) j	      (((fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2)) _f g) x)) =	 (fun (k : Graph.graph0 sequence_graph)	    (b : fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2) k) => 1) i x	";
            responses[i]=data;
          

            i = 413;
            data = "1 goal (ID 1293)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j)	  (x : fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2) i),	  transport	    (fun w : Colimit (fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2))	     =>	     F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	     transport E	       (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	       (F n.+1 (a) ^+ w)) (colimp i j g x)	    ((fun (k : Graph.graph0 sequence_graph)	        (b : fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2) k) => 1) j	       (((fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2)) _f g) x)) =	  (fun (k : Graph.graph0 sequence_graph)	     (b : fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2) k) => 1) i x	1 goal (ID 1305)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  k : Graph.graph0 sequence_graph	  b : fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2) k	  ============================	  transport	    (fun w : Colimit (fib_seq_to_seq B (n.+1; (a) ^+)) =>	     F n a (colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a)) w) =	     transport E	       (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a) w)	       (F n.+1 (a) ^+ w)) (colimp k k.+1 1 b) 1 = 1	";
            responses[i]=data;
          

            i = 414;
            data = "1 goal (ID 1404)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  k : Graph.graph0 sequence_graph	  b : fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2) k	  ============================	  apD (F n a) (colimp k.+1 k.+2 1 b) @ 1 =	  (ap	     (transport	        (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	        (colimp k.+1 k.+2 1 b)) 1 @	   Epsilon (glue A n a)	     (colim_succ_seq_to_colim_seq_beta_glue (fib_seq_to_seq B (n; a)) k b)	     (F n.+1 (a) ^+ (inj (succ_seq (fib_seq_to_seq B (n; a))) k.+1 (b) ^+))) @	  ap	    (transport E	       (Delta (glue A n a) (fib_seq_to_type_fam_beta_glue B n a)	          (inj (succ_seq (fib_seq_to_seq B (n; a))) k b)))	    (apD (F n.+1 (a) ^+) (colimp k k.+1 1 b))	";
            responses[i]=data;
          

            i = 415;
            data = "1 goal (ID 1423)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  k : Graph.graph0 sequence_graph	  b : fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2) k	  ============================	  R k.+1 n a b @ 1 =	  (ap	     (transport	        (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	        (colimp k.+1 k.+2 1 b)) 1 @	   Epsilon (colimp n n.+1 1 a)	     (colim_succ_seq_to_colim_seq_beta_glue (fib_seq_to_seq B (n; a)) k b)	     (F n.+1 (a) ^+ (inj (succ_seq (fib_seq_to_seq B (n; a))) k.+1 (b) ^+))) @	  ap	    (transport E	       (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a)	          (inj (succ_seq (fib_seq_to_seq B (n; a))) k b)))	    (apD (F n.+1 (a) ^+) (colimp k k.+1 1 b))	";
            responses[i]=data;
          

            i = 416;
            data = "1 goal (ID 1458)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  k : Graph.graph0 sequence_graph	  b : fib_seq_to_seq B ((n.+1; (a) ^+).1; (n.+1; (a) ^+).2) k	  ============================	  R k.+1 n a b @ 1 =	  (ap	     (transport	        (fun x : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x))	        (colimp k.+1 k.+2 1 b)) 1 @	   Epsilon (colimp n n.+1 1 a)	     (colim_succ_seq_to_colim_seq_beta_glue (fib_seq_to_seq B (n; a)) k b)	     (F n.+1 (a) ^+ (inj (succ_seq (fib_seq_to_seq B (n; a))) k.+1 (b) ^+))) @	  ap	    (transport E	       (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a)	          (inj (succ_seq (fib_seq_to_seq B (n; a))) k b)))	    (R k n.+1 (a) ^+ b)	";
            responses[i]=data;
          

            i = 417;
            data = "";
            responses[i]=data;
          

            i = 418;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 419;
            data = "";
            responses[i]=data;
          

            i = 420;
            data = "1 goal (ID 1334)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x2 : X & idmap (Y x2)} -> Type	  x1, x2 : X	  p : x1 = x2	  F : idmap (Y x1) -> idmap (Y x2)	  psi : coe (ap Y p) = F	  G1 : forall y : (fun x2 : X => idmap (Y x2)) x1, Z (x1; y)	  G2 : forall y : (fun x2 : X => idmap (Y x2)) x2, Z (x2; y)	  ============================	  transport	    (fun x : X => forall y : (fun x3 : X => idmap (Y x3)) x, Z (x; y)) p G1 =	  G2 <~> (forall y : Y x1, G2 (F y) = transport Z (Delta p psi y) (G1 y))	";
            responses[i]=data;
          

            i = 421;
            data = "1 goal (ID 1351)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x2 : X & idmap (Y x2)} -> Type	  x1 : X	  G1 : forall y : (fun x2 : X => idmap (Y x2)) x1, Z (x1; y)	  G2 : forall y : Y x1, Z (x1; y)	  ============================	  transport (fun x : X => forall y : Y x, Z (x; y)) 1 G1 = G2 <~>	  (forall y : Y x1, G2 (coe (ap Y 1) y) = transport Z (Delta 1 1 y) (G1 y))	";
            responses[i]=data;
          

            i = 422;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 423;
            data = "";
            responses[i]=data;
          

            i = 424;
            data = "";
            responses[i]=data;
          

            i = 425;
            data = "";
            responses[i]=data;
          

            i = 426;
            data = "";
            responses[i]=data;
          

            i = 427;
            data = "";
            responses[i]=data;
          

            i = 428;
            data = "1 goal (ID 1342)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (x : Colimit A) (y : fib_seq_to_type_fam B x), E (x; y)	";
            responses[i]=data;
          

            i = 429;
            data = "";
            responses[i]=data;
          

            i = 430;
            data = "1 goal (ID 1360)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  transport	    (fun w : Colimit A => forall y : fib_seq_to_type_fam B w, E (w; y))	    (colimp n n.+1 1 a) (F n.+1 (a) ^+) = F n a	";
            responses[i]=data;
          

            i = 431;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 432;
            data = "";
            responses[i]=data;
          

            i = 433;
            data = "";
            responses[i]=data;
          

            i = 434;
            data = "";
            responses[i]=data;
          

            i = 435;
            data = "";
            responses[i]=data;
          

            i = 436;
            data = "";
            responses[i]=data;
          

            i = 437;
            data = "1 goal (ID 1371)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  ============================	  I (fib_seq_to_type_fam_beta_glue B n a)	    (apD seq_colim_sum_ind_cur (glue A n a)) = G n a	";
            responses[i]=data;
          

            i = 438;
            data = "";
            responses[i]=data;
          

            i = 439;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 440;
            data = "";
            responses[i]=data;
          

            i = 441;
            data = "";
            responses[i]=data;
          

            i = 442;
            data = "";
            responses[i]=data;
          

            i = 443;
            data = "";
            responses[i]=data;
          

            i = 444;
            data = "";
            responses[i]=data;
          

            i = 445;
            data = "1 goal (ID 1373)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall x : {x : _ & fib_seq_to_type_fam B x}, E x	";
            responses[i]=data;
          

            i = 446;
            data = "";
            responses[i]=data;
          

            i = 447;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 448;
            data = "";
            responses[i]=data;
          

            i = 449;
            data = "1 goal (ID 1489)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  G : forall x0 : {x : _ & Y x}, Z x0	  x : X	  y1, y2 : Y x	  z : {x : _ & Y x}	  p : y1 = y2	  q1 : z = (x; y1)	  q2 : z = (x; y2)	  theta : q2 = q1 @ ap (exist Y x) p	  ============================	  apD (G o exist Y x) p =	  (ap (transport (Z o exist Y x) p) (apD G q1)^ @ Eta theta (G z)) @ apD G q2	";
            responses[i]=data;
          

            i = 450;
            data = "";
            responses[i]=data;
          

            i = 451;
            data = "1 goal (ID 1520)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  G : forall x0 : {x : _ & Y x}, Z x0	  x : X	  y1, y2 : Y x	  z : {x : _ & Y x}	  p : y1 = y2	  q1 : z = (x; y1)	  q2 : z = (x; y2)	  ============================	  forall x0 : q1 @ ap (exist Y x) p = q2,	  (fun y : q2 = q1 @ ap (exist Y x) p =>	   apD (G o exist Y x) p =	   (ap (transport (Z o exist Y x) p) (apD G q1)^ @ Eta y (G z)) @ apD G q2)	    (equiv_path_inverse (q1 @ ap (exist Y x) p) q2 x0)	";
            responses[i]=data;
          

            i = 452;
            data = "1 goal (ID 1525)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  G : forall x0 : {x : _ & Y x}, Z x0	  x : X	  y1, y2 : Y x	  z : {x : _ & Y x}	  p : y1 = y2	  q1 : z = (x; y1)	  ============================	  apD (fun x0 : Y x => G (x; x0)) p =	  (ap (transport (fun x0 : Y x => Z (x; x0)) p) (apD G q1)^ @	   Eta (equiv_path_inverse (q1 @ ap (exist Y x) p) (q1 @ ap (exist Y x) p) 1)	     (G z)) @ apD G (q1 @ ap (exist Y x) p)	";
            responses[i]=data;
          

            i = 453;
            data = "1 goal (ID 1561)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x : _ & Y x} -> Type	  G : forall x0 : {x : _ & Y x}, Z x0	  x : X	  y1, y2 : Y x	  p : y1 = y2	  ============================	  apD (fun x0 : Y x => G (x; x0)) p =	  (ap (transport (fun x0 : Y x => Z (x; x0)) p)	     (apD G (equiv_path_inverse (x; y1) (x; y1) 1))^ @	   Eta	     (equiv_path_inverse	        (equiv_path_inverse (x; y1) (x; y1) 1 @ ap (exist Y x) p)	        (equiv_path_inverse (x; y1) (x; y1) 1 @ ap (exist Y x) p) 1)	     (G (x; y1))) @	  apD G (equiv_path_inverse (x; y1) (x; y1) 1 @ ap (exist Y x) p)	";
            responses[i]=data;
          

            i = 454;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 455;
            data = "";
            responses[i]=data;
          

            i = 456;
            data = "1 goal (ID 1569)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  X : Type	  Y : X -> Type	  Z : {x2 : X & idmap (Y x2)} -> Type	  x1, x2 : X	  p : x1 = x2	  F : idmap (Y x1) -> idmap (Y x2)	  G : forall z : {x2 : X & idmap (Y x2)}, Z z	  psi : coe (ap Y p) = F	  q : forall y : Y x1,	      (fun y0 : (fun x2 : X => idmap (Y x2)) x2 => G (x2; y0)) (F y) =	      transport Z (Delta p psi y)	        ((fun y0 : (fun x2 : X => idmap (Y x2)) x1 => G (x1; y0)) y)	  theta : I psi	            (apD	               (fun (x : X) (y : (fun x2 : X => idmap (Y x2)) x) => G (x; y))	               p) = q	  y : Y x1	  ============================	  apD G (Delta p psi y) = (q y)^	";
            responses[i]=data;
          

            i = 457;
            data = "";
            responses[i]=data;
          

            i = 458;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 459;
            data = "";
            responses[i]=data;
          

            i = 460;
            data = "";
            responses[i]=data;
          

            i = 461;
            data = "";
            responses[i]=data;
          

            i = 462;
            data = "";
            responses[i]=data;
          

            i = 463;
            data = "";
            responses[i]=data;
          

            i = 464;
            data = "1 goal (ID 1591)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n) 	  (b : B (n; a)),	  apD seq_colim_sum_ind	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  t n a b	";
            responses[i]=data;
          

            i = 465;
            data = "";
            responses[i]=data;
          

            i = 466;
            data = "1 goal (ID 1595)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  h := F_beta_glue n a b	   : apD (F n a) (glue (fib_seq_to_seq B ((n; a).1; (n; a).2)) 0 b) =	     R 0 n a b	  ============================	  apD seq_colim_sum_ind	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  t n a b	";
            responses[i]=data;
          

            i = 467;
            data = "1 goal (ID 1609)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  h : (ap	         (transport	            (fun x0 : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x0))	            (colimp 0 1 1 b))	         (apD seq_colim_sum_ind	            (Delta (colimp n n.+1 1 a) (fib_seq_to_type_fam_beta_glue B n a)	               (inj (fib_seq_to_seq B (n.+1; (a) ^+)) 0 (b) ^+)))^ @	       Eta (seq_colim_sum_to_sum_seq_colim_beta_glue B n a b)	         (seq_colim_sum_ind	            (seq_colim_sum_to_sum_seq_colim B	               (inj (sig_seq B) n.+1 ((a; b)) ^+)))) @	      apD seq_colim_sum_ind	        (ap (seq_colim_sum_to_sum_seq_colim B) (colimp n n.+1 1 (a; b))) =	      R 0 n a b	  ============================	  apD seq_colim_sum_ind	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  t n a b	";
            responses[i]=data;
          

            i = 468;
            data = "1 goal (ID 1636)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : {x : _ & fib_seq_to_type_fam B x} -> Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a; b)))	  t : forall (n : Graph.graph0 sequence_graph) (a : A n)	      (b : (fun a0 : A n => B (n; a0)) a),	      transport E	        (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	        (e n.+1 (a) ^+ (b) ^+f) = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  h : (ap	         (transport	            (fun x0 : fib_seq_to_type_fam B (inj A n a) => E (inj A n a; x0))	            (colimp 0 1 1 b))	         ((G n a (inj (fib_seq_to_seq B (n.+1; (a) ^+)) 0 (b) ^+))^)^ @	       Eta (seq_colim_sum_to_sum_seq_colim_beta_glue B n a b)	         (seq_colim_sum_ind	            (seq_colim_sum_to_sum_seq_colim B	               (inj (sig_seq B) n.+1 ((a; b)) ^+)))) @	      apD seq_colim_sum_ind	        (ap (seq_colim_sum_to_sum_seq_colim B) (colimp n n.+1 1 (a; b))) =	      R 0 n a b	  ============================	  apD seq_colim_sum_ind	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  t n a b	";
            responses[i]=data;
          

            i = 469;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 470;
            data = "";
            responses[i]=data;
          

            i = 471;
            data = "";
            responses[i]=data;
          

            i = 472;
            data = "";
            responses[i]=data;
          

            i = 473;
            data = "";
            responses[i]=data;
          

            i = 474;
            data = "";
            responses[i]=data;
          

            i = 475;
            data = "";
            responses[i]=data;
          

            i = 476;
            data = "";
            responses[i]=data;
          

            i = 477;
            data = "<infomsg>H is declared</infomsg>	<infomsg>A is declared</infomsg>	<infomsg>B is declared</infomsg>	";
            responses[i]=data;
          

            i = 478;
            data = "<infomsg>E is declared</infomsg>	<infomsg>e is declared</infomsg>	";
            responses[i]=data;
          

            i = 479;
            data = "<infomsg>t is declared</infomsg>	";
            responses[i]=data;
          

            i = 480;
            data = "1 goal (ID 814)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n), B (n; a) -> E	  t : forall (n : Graph.graph0 sequence_graph) (a : A n) 	      (b : B (n; a)), e n.+1 (a) ^+ (b) ^+f = e n a b	  ============================	  {x : _ & fib_seq_to_type_fam B x} -> E	";
            responses[i]=data;
          

            i = 481;
            data = "";
            responses[i]=data;
          

            i = 482;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 483;
            data = "";
            responses[i]=data;
          

            i = 484;
            data = "1 goal (ID 839)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n), B (n; a) -> E	  t : forall (n : Graph.graph0 sequence_graph) (a : A n) 	      (b : B (n; a)), e n.+1 (a) ^+ (b) ^+f = e n a b	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n)	  (b : (fun a0 : A n => B (n; a0)) a),	  ap seq_colim_sum_rec	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  t n a b	";
            responses[i]=data;
          

            i = 485;
            data = "";
            responses[i]=data;
          

            i = 486;
            data = "1 goal (ID 869)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : Type	  e : forall (n : Graph.graph0 sequence_graph) (a : A n), B (n; a) -> E	  t : forall (n : Graph.graph0 sequence_graph) (a : A n) 	      (b : B (n; a)), e n.+1 (a) ^+ (b) ^+f = e n a b	  n : Graph.graph0 sequence_graph	  a : A n	  b : (fun a : A n => B (n; a)) a	  ============================	  apD seq_colim_sum_rec	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b))) =	  transport_const	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	    (seq_colim_sum_rec	       (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n.+1 ((a; b)) ^+))) @	  t n a b	";
            responses[i]=data;
          

            i = 487;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 488;
            data = "";
            responses[i]=data;
          

            i = 489;
            data = "";
            responses[i]=data;
          

            i = 490;
            data = "";
            responses[i]=data;
          

            i = 491;
            data = "";
            responses[i]=data;
          

            i = 492;
            data = "";
            responses[i]=data;
          

            i = 493;
            data = "";
            responses[i]=data;
          

            i = 494;
            data = "1 goal (ID 816)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : Type	  F, G : {x : _ & fib_seq_to_type_fam B x} -> E	  ============================	  F o seq_colim_sum_to_sum_seq_colim B ==	  G o seq_colim_sum_to_sum_seq_colim B -> F == G	";
            responses[i]=data;
          

            i = 495;
            data = "";
            responses[i]=data;
          

            i = 496;
            data = "1 goal (ID 840)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  E : Type	  F, G : {x : _ & fib_seq_to_type_fam B x} -> E	  h : F o seq_colim_sum_to_sum_seq_colim B ==	      G o seq_colim_sum_to_sum_seq_colim B	  n : Graph.graph0 sequence_graph	  a : A n	  b : (fun a : A n => B (n; a)) a	  ============================	  transport (fun x : {x : _ & fib_seq_to_type_fam B x} => F x = G x)	    (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a; b)))	    ((fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0)	        (b0 : (fun a1 : A n0 => B (n0; a1)) a0) =>	      h (inj (sig_seq B) n0 (a0; b0))) n.+1 (a) ^+ 	       (b) ^+f) =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0)	     (b0 : (fun a1 : A n0 => B (n0; a1)) a0) =>	   h (inj (sig_seq B) n0 (a0; b0))) n a b	";
            responses[i]=data;
          

            i = 497;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 498;
            data = "";
            responses[i]=data;
          

            i = 499;
            data = "";
            responses[i]=data;
          

            i = 500;
            data = "";
            responses[i]=data;
          

            i = 501;
            data = "";
            responses[i]=data;
          

            i = 502;
            data = "";
            responses[i]=data;
          

            i = 503;
            data = "1 goal (ID 825)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 504;
            data = "";
            responses[i]=data;
          

            i = 505;
            data = "2 goals (ID 849)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  {G0	  : {x : _ & fib_seq_to_type_fam B x} ->	    GraphQuotient.GraphQuotient.GraphQuotient	      (fun a b : {x : _ & sig_seq B x} =>	       {x0	       : {x0 : {x : _ & sig_seq B x} &	         {j : Graph.graph0 sequence_graph &	         Graph.graph1 sequence_graph x0.1 j}} &	       ((x0.1 = a) * (((x0.2).1; ((sig_seq B) _f (x0.2).2) (x0.1).2) = b))%type})	  &	  (fun x : Colimit (sig_seq B) => G0 (seq_colim_sum_to_sum_seq_colim B x)) ==	  idmap}		goal 2 (ID 850) is:	 IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 506;
            data = "1 goal (ID 849)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  {G0	  : {x : _ & fib_seq_to_type_fam B x} ->	    GraphQuotient.GraphQuotient.GraphQuotient	      (fun a b : {x : _ & sig_seq B x} =>	       {x0	       : {x0 : {x : _ & sig_seq B x} &	         {j : Graph.graph0 sequence_graph &	         Graph.graph1 sequence_graph x0.1 j}} &	       ((x0.1 = a) * (((x0.2).1; ((sig_seq B) _f (x0.2).2) (x0.1).2) = b))%type})	  &	  (fun x : Colimit (sig_seq B) => G0 (seq_colim_sum_to_sum_seq_colim B x)) ==	  idmap}	2 goals (ID 855)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  {x : _ & fib_seq_to_type_fam B x} ->	  GraphQuotient.GraphQuotient.GraphQuotient	    (fun a b : {x : _ & sig_seq B x} =>	     {x0	     : {x0 : {x : _ & sig_seq B x} &	       {j : Graph.graph0 sequence_graph & Graph.graph1 sequence_graph x0.1 j}}	     &	     ((x0.1 = a) * (((x0.2).1; ((sig_seq B) _f (x0.2).2) (x0.1).2) = b))%type})		goal 2 (ID 857) is:	 (fun	    G0 : {x : _ & fib_seq_to_type_fam B x} ->	         GraphQuotient.GraphQuotient.GraphQuotient	           (fun a b : {x : _ & sig_seq B x} =>	            {x0	            : {x0 : {x : _ & sig_seq B x} &	              {j : Graph.graph0 sequence_graph &	              Graph.graph1 sequence_graph x0.1 j}} &	            ((x0.1 = a) *	             (((x0.2).1; ((sig_seq B) _f (x0.2).2) (x0.1).2) = b))%type}) =>	  (fun x : Colimit (sig_seq B) => G0 (seq_colim_sum_to_sum_seq_colim B x)) ==	  idmap) ?proj1	";
            responses[i]=data;
          

            i = 507;
            data = "1 goal (ID 855)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  {x : _ & fib_seq_to_type_fam B x} ->	  GraphQuotient.GraphQuotient.GraphQuotient	    (fun a b : {x : _ & sig_seq B x} =>	     {x0	     : {x0 : {x : _ & sig_seq B x} &	       {j : Graph.graph0 sequence_graph & Graph.graph1 sequence_graph x0.1 j}}	     &	     ((x0.1 = a) * (((x0.2).1; ((sig_seq B) _f (x0.2).2) (x0.1).2) = b))%type})	2 goals (ID 885)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n),	  B (n; a) ->	  GraphQuotient.GraphQuotient.GraphQuotient	    (fun a0 b : {x : _ & sig_seq B x} =>	     {x	     : {x : {x : _ & sig_seq B x} &	       {j : Graph.graph0 sequence_graph & Graph.graph1 sequence_graph x.1 j}}	     & ((x.1 = a0) * (((x.2).1; ((sig_seq B) _f (x.2).2) (x.1).2) = b))%type})		goal 2 (ID 887) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n) 	 (b : B (n; a)), ?e n.+1 (a) ^+ (b) ^+f = ?e n a b	";
            responses[i]=data;
          

            i = 508;
            data = "1 goal (ID 885)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n),	  B (n; a) ->	  GraphQuotient.GraphQuotient.GraphQuotient	    (fun a0 b : {x : _ & sig_seq B x} =>	     {x	     : {x : {x : _ & sig_seq B x} &	       {j : Graph.graph0 sequence_graph & Graph.graph1 sequence_graph x.1 j}}	     & ((x.1 = a0) * (((x.2).1; ((sig_seq B) _f (x.2).2) (x.1).2) = b))%type})	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	3 goals		goal 1 (ID 887) is:	 forall (n : Graph.graph0 sequence_graph) (a : A n) 	 (b : B (n; a)),	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b0 : B (n0; a0)) =>	  inj (sig_seq B) n0 (a0; b0)) n.+1 (a) ^+ (b) ^+f =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b0 : B (n0; a0)) =>	  inj (sig_seq B) n0 (a0; b0)) n a b	goal 2 (ID 857) is:	 (fun	    G0 : {x : _ & fib_seq_to_type_fam B x} ->	         GraphQuotient.GraphQuotient.GraphQuotient	           (fun a b : {x : _ & sig_seq B x} =>	            {x0	            : {x0 : {x : _ & sig_seq B x} &	              {j : Graph.graph0 sequence_graph &	              Graph.graph1 sequence_graph x0.1 j}} &	            ((x0.1 = a) *	             (((x0.2).1; ((sig_seq B) _f (x0.2).2) (x0.1).2) = b))%type}) =>	  (fun x : Colimit (sig_seq B) => G0 (seq_colim_sum_to_sum_seq_colim B x)) ==	  idmap)	   (seq_colim_sum_rec B	      (GraphQuotient.GraphQuotient.GraphQuotient	         (fun a b : {x : _ & sig_seq B x} =>	          {x	          : {x : {x : _ & sig_seq B x} &	            {j : Graph.graph0 sequence_graph &	            Graph.graph1 sequence_graph x.1 j}} &	          ((x.1 = a) * (((x.2).1; ((sig_seq B) _f (x.2).2) (x.1).2) = b))%type}))	      (fun (n : Graph.graph0 sequence_graph) (a : A n) (b : B (n; a)) =>	       inj (sig_seq B) n (a; b)) ?t)	goal 3 (ID 850) is:	 IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 509;
            data = "1 goal (ID 887)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : A n) 	  (b : B (n; a)),	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b0 : B (n0; a0)) =>	   inj (sig_seq B) n0 (a0; b0)) n.+1 (a) ^+ (b) ^+f =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b0 : B (n0; a0)) =>	   inj (sig_seq B) n0 (a0; b0)) n a b	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 857) is:	 (fun	    G0 : {x : _ & fib_seq_to_type_fam B x} ->	         GraphQuotient.GraphQuotient.GraphQuotient	           (fun a b : {x : _ & sig_seq B x} =>	            {x0	            : {x0 : {x : _ & sig_seq B x} &	              {j : Graph.graph0 sequence_graph &	              Graph.graph1 sequence_graph x0.1 j}} &	            ((x0.1 = a) *	             (((x0.2).1; ((sig_seq B) _f (x0.2).2) (x0.1).2) = b))%type}) =>	  (fun x : Colimit (sig_seq B) => G0 (seq_colim_sum_to_sum_seq_colim B x)) ==	  idmap)	   (seq_colim_sum_rec B	      (GraphQuotient.GraphQuotient.GraphQuotient	         (fun a b : {x : _ & sig_seq B x} =>	          {x	          : {x : {x : _ & sig_seq B x} &	            {j : Graph.graph0 sequence_graph &	            Graph.graph1 sequence_graph x.1 j}} &	          ((x.1 = a) * (((x.2).1; ((sig_seq B) _f (x.2).2) (x.1).2) = b))%type}))	      (fun (n : Graph.graph0 sequence_graph) (a : A n) (b : B (n; a)) =>	       inj (sig_seq B) n (a; b))	      (fun (n : Graph.graph0 sequence_graph) (a : A n) (b : B (n; a)) =>	       glue (sig_seq B) n (a; b)))	goal 2 (ID 850) is:	 IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 510;
            data = "1 goal (ID 857)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  (fun	     G0 : {x : _ & fib_seq_to_type_fam B x} ->	          GraphQuotient.GraphQuotient.GraphQuotient	            (fun a b : {x : _ & sig_seq B x} =>	             {x0	             : {x0 : {x : _ & sig_seq B x} &	               {j : Graph.graph0 sequence_graph &	               Graph.graph1 sequence_graph x0.1 j}} &	             ((x0.1 = a) *	              (((x0.2).1; ((sig_seq B) _f (x0.2).2) (x0.1).2) = b))%type}) =>	   (fun x : Colimit (sig_seq B) => G0 (seq_colim_sum_to_sum_seq_colim B x)) ==	   idmap)	    (seq_colim_sum_rec B	       (GraphQuotient.GraphQuotient.GraphQuotient	          (fun a b : {x : _ & sig_seq B x} =>	           {x	           : {x : {x : _ & sig_seq B x} &	             {j : Graph.graph0 sequence_graph &	             Graph.graph1 sequence_graph x.1 j}} &	           ((x.1 = a) * (((x.2).1; ((sig_seq B) _f (x.2).2) (x.1).2) = b))%type}))	       (fun (n : Graph.graph0 sequence_graph) (a : A n) (b : B (n; a)) =>	        inj (sig_seq B) n (a; b))	       (fun (n : Graph.graph0 sequence_graph) (a : A n) (b : B (n; a)) =>	        glue (sig_seq B) n (a; b)))	2 goals (ID 938)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (sig_seq B) =>	   seq_colim_sum_rec B	     (GraphQuotient.GraphQuotient.GraphQuotient	        (fun a b : {x : _ & sig_seq B x} =>	         {x0	         : {x0 : {x : _ & sig_seq B x} &	           {j : Graph.graph0 sequence_graph &	           Graph.graph1 sequence_graph x0.1 j}} &	         ((x0.1 = a) * (((x0.2).1; ((sig_seq B) _f (x0.2).2) (x0.1).2) = b))%type}))	     (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) (b : B (n0; a)) =>	      inj (sig_seq B) n0 (a; b))	     (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) (b : B (n0; a)) =>	      glue (sig_seq B) n0 (a; b)) (seq_colim_sum_to_sum_seq_colim B x))	  o inj (sig_seq B) n == idmap o inj (sig_seq B) n		goal 2 (ID 940) is:	 forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	 ap	   (fun x : Colimit (sig_seq B) =>	    seq_colim_sum_rec B	      (GraphQuotient.GraphQuotient.GraphQuotient	         (fun a0 b : {x : _ & sig_seq B x} =>	          {x0	          : {x0 : {x : _ & sig_seq B x} &	            {j : Graph.graph0 sequence_graph &	            Graph.graph1 sequence_graph x0.1 j}} &	          ((x0.1 = a0) * (((x0.2).1; ((sig_seq B) _f (x0.2).2) (x0.1).2) = b))%type}))	      (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0)) =>	       inj (sig_seq B) n0 (a0; b))	      (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0)) =>	       glue (sig_seq B) n0 (a0; b)) (seq_colim_sum_to_sum_seq_colim B x))	   (glue (sig_seq B) n a) @ ?h n a =	 ?h n.+1 (a) ^+ @ ap idmap (glue (sig_seq B) n a)	";
            responses[i]=data;
          

            i = 511;
            data = "1 goal (ID 938)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (sig_seq B) =>	   seq_colim_sum_rec B	     (GraphQuotient.GraphQuotient.GraphQuotient	        (fun a b : {x : _ & sig_seq B x} =>	         {x0	         : {x0 : {x : _ & sig_seq B x} &	           {j : Graph.graph0 sequence_graph &	           Graph.graph1 sequence_graph x0.1 j}} &	         ((x0.1 = a) * (((x0.2).1; ((sig_seq B) _f (x0.2).2) (x0.1).2) = b))%type}))	     (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) (b : B (n0; a)) =>	      inj (sig_seq B) n0 (a; b))	     (fun (n0 : Graph.graph0 sequence_graph) (a : A n0) (b : B (n0; a)) =>	      glue (sig_seq B) n0 (a; b)) (seq_colim_sum_to_sum_seq_colim B x))	  o inj (sig_seq B) n == idmap o inj (sig_seq B) n	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 940) is:	 forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	 ap	   (fun x : Colimit (sig_seq B) =>	    seq_colim_sum_rec B	      (GraphQuotient.GraphQuotient.GraphQuotient	         (fun a0 b : {x : _ & sig_seq B x} =>	          {x0	          : {x0 : {x : _ & sig_seq B x} &	            {j : Graph.graph0 sequence_graph &	            Graph.graph1 sequence_graph x0.1 j}} &	          ((x0.1 = a0) * (((x0.2).1; ((sig_seq B) _f (x0.2).2) (x0.1).2) = b))%type}))	      (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0)) =>	       inj (sig_seq B) n0 (a0; b))	      (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0)) =>	       glue (sig_seq B) n0 (a0; b)) (seq_colim_sum_to_sum_seq_colim B x))	   (glue (sig_seq B) n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n.+1	   (a) ^+ @ ap idmap (glue (sig_seq B) n a)	goal 2 (ID 850) is:	 IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 512;
            data = "1 goal (ID 940)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	  ap	    (fun x : Colimit (sig_seq B) =>	     seq_colim_sum_rec B	       (GraphQuotient.GraphQuotient.GraphQuotient	          (fun a0 b : {x : _ & sig_seq B x} =>	           {x0	           : {x0 : {x : _ & sig_seq B x} &	             {j : Graph.graph0 sequence_graph &	             Graph.graph1 sequence_graph x0.1 j}} &	           ((x0.1 = a0) *	            (((x0.2).1; ((sig_seq B) _f (x0.2).2) (x0.1).2) = b))%type}))	       (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0))	        => inj (sig_seq B) n0 (a0; b))	       (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0))	        => glue (sig_seq B) n0 (a0; b)) (seq_colim_sum_to_sum_seq_colim B x))	    (glue (sig_seq B) n a) @	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n a =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n.+1	    (a) ^+ @ ap idmap (glue (sig_seq B) n a)	1 goal (ID 971)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : sig_seq B n	  ============================	  ap	    (seq_colim_sum_rec B	       (GraphQuotient.GraphQuotient.GraphQuotient	          (fun a0 b : {x : _ & sig_seq B x} =>	           {x	           : {x : {x : _ & sig_seq B x} &	             {j : Graph.graph0 sequence_graph &	             Graph.graph1 sequence_graph x.1 j}} &	           ((x.1 = a0) * (((x.2).1; ((sig_seq B) _f (x.2).2) (x.1).2) = b))%type}))	       (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0))	        => inj (sig_seq B) n0 (a0; b))	       (fun (n0 : Graph.graph0 sequence_graph) (a0 : A n0) (b : B (n0; a0))	        => colimp n0 n0.+1 1 (a0; b)))	    (ap (seq_colim_sum_to_sum_seq_colim B) (colimp n n.+1 1 a)) =	  colimp n n.+1 1 a	";
            responses[i]=data;
          

            i = 513;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 850) is:	 IsEquiv (seq_colim_sum_to_sum_seq_colim B)	";
            responses[i]=data;
          

            i = 514;
            data = "1 goal (ID 850)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  L : {G	      : {x : _ & fib_seq_to_type_fam B x} ->	        GraphQuotient.GraphQuotient.GraphQuotient	          (fun a b : {x : _ & sig_seq B x} =>	           {x0	           : {x0 : {x : _ & sig_seq B x} &	             {j : Graph.graph0 sequence_graph &	             Graph.graph1 sequence_graph x0.1 j}} &	           (((fun	                t : {x1 : {x : _ & sig_seq B x} &	                    {j : Graph.graph0 sequence_graph &	                    Graph.graph1 sequence_graph x1.1 j}} => t.1) x0 = a) *	            ((fun	                t : {x1 : {x : _ & sig_seq B x} &	                    {j : Graph.graph0 sequence_graph &	                    Graph.graph1 sequence_graph x1.1 j}} =>	              ((t.2).1; ((sig_seq B) _f (t.2).2) (t.1).2)) x0 = b))%type}) &	      G o seq_colim_sum_to_sum_seq_colim B == idmap}	  ============================	  IsEquiv (seq_colim_sum_to_sum_seq_colim B)	1 goal (ID 1031)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  L : {G	      : {x : _ & fib_seq_to_type_fam B x} ->	        GraphQuotient.GraphQuotient.GraphQuotient	          (fun a b : {x : _ & sig_seq B x} =>	           {x0	           : {x0 : {x : _ & sig_seq B x} &	             {j : Graph.graph0 sequence_graph &	             Graph.graph1 sequence_graph x0.1 j}} &	           (((fun	                t : {x1 : {x : _ & sig_seq B x} &	                    {j : Graph.graph0 sequence_graph &	                    Graph.graph1 sequence_graph x1.1 j}} => t.1) x0 = a) *	            ((fun	                t : {x1 : {x : _ & sig_seq B x} &	                    {j : Graph.graph0 sequence_graph &	                    Graph.graph1 sequence_graph x1.1 j}} =>	              ((t.2).1; ((sig_seq B) _f (t.2).2) (t.1).2)) x0 = b))%type}) &	      G o seq_colim_sum_to_sum_seq_colim B == idmap}	  ============================	  (fun x : {x : _ & fib_seq_to_type_fam B x} =>	   seq_colim_sum_to_sum_seq_colim B (L.1 x))	  o seq_colim_sum_to_sum_seq_colim B ==	  idmap o seq_colim_sum_to_sum_seq_colim B	";
            responses[i]=data;
          

            i = 515;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 516;
            data = "";
            responses[i]=data;
          

            i = 517;
            data = "<infomsg>equiv_seq_colim_sum_to_sum_seq_colim is defined</infomsg>	";
            responses[i]=data;
          

            i = 518;
            data = "";
            responses[i]=data;
          

            i = 519;
            data = "";
            responses[i]=data;
          

            i = 520;
            data = "";
            responses[i]=data;
          

            i = 521;
            data = "";
            responses[i]=data;
          

            i = 522;
            data = "1 goal (ID 861)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  pr1 o seq_colim_sum_to_sum_seq_colim B == seq_colim_sum_to_seq_colim_fst B	";
            responses[i]=data;
          

            i = 523;
            data = "";
            responses[i]=data;
          

            i = 524;
            data = "2 goals (ID 895)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (sig_seq B) => (seq_colim_sum_to_sum_seq_colim B x).1)	  o inj (sig_seq B) n == seq_colim_sum_to_seq_colim_fst B o inj (sig_seq B) n		goal 2 (ID 897) is:	 forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	 ap (fun x : Colimit (sig_seq B) => (seq_colim_sum_to_sum_seq_colim B x).1)	   (glue (sig_seq B) n a) @ ?h n a =	 ?h n.+1 (a) ^+ @	 ap (seq_colim_sum_to_seq_colim_fst B) (glue (sig_seq B) n a)	";
            responses[i]=data;
          

            i = 525;
            data = "1 goal (ID 895)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall n : Graph.graph0 sequence_graph,	  (fun x : Colimit (sig_seq B) => (seq_colim_sum_to_sum_seq_colim B x).1)	  o inj (sig_seq B) n == seq_colim_sum_to_seq_colim_fst B o inj (sig_seq B) n	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 897) is:	 forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	 ap (fun x : Colimit (sig_seq B) => (seq_colim_sum_to_sum_seq_colim B x).1)	   (glue (sig_seq B) n a) @	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n a =	 (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n.+1	   (a) ^+ @ ap (seq_colim_sum_to_seq_colim_fst B) (glue (sig_seq B) n a)	";
            responses[i]=data;
          

            i = 526;
            data = "1 goal (ID 897)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  ============================	  forall (n : Graph.graph0 sequence_graph) (a : sig_seq B n),	  ap (fun x : Colimit (sig_seq B) => (seq_colim_sum_to_sum_seq_colim B x).1)	    (glue (sig_seq B) n a) @	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n a =	  (fun (n0 : Graph.graph0 sequence_graph) (a0 : sig_seq B n0) => 1) n.+1	    (a) ^+ @ ap (seq_colim_sum_to_seq_colim_fst B) (glue (sig_seq B) n a)	1 goal (ID 934)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  ============================	  ap pr1	    (legs_comm	       {|	         legs :=	           fun (n0 : Graph.graph0 sequence_graph) (X : sig_seq B n0) =>	           (inj A n0 X.1; inj (fib_seq_to_seq B (n0; X.1)) 0 X.2);	         legs_comm :=	           fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (x : sig_seq B n0) =>	           match	             p as p0 in (_ = y)	             return	               ((inj A y (((sig_seq B) _f p0) (x.1; x.2)).1;	                inj	                  (fib_seq_to_seq B (y; (((sig_seq B) _f p0) (x.1; x.2)).1))	                  0 (((sig_seq B) _f p0) (x.1; x.2)).2) =	                (inj A n0 x.1; inj (fib_seq_to_seq B (n0; x.1)) 0 x.2))	           with	           | 1 =>	               Delta (colimp n0 n0.+1 1 x.1)	                 (fib_seq_to_type_fam_beta_glue B n0 x.1)	                 (inj (fib_seq_to_seq B (n0.+1; ((x.1; x.2)) ^+.1)) 0	                    ((x.1; x.2)) ^+.2) @	               ap (exist (fib_seq_to_type_fam B) (inj A n0 x.1))	                 (colimp 0 1 1 x.2)	           end	       |} n n.+1 1 (a; b)) =	  legs_comm	    {|	      legs :=	        fun (n0 : Graph.graph0 sequence_graph) (X : sig_seq B n0) =>	        inj A n0 X.1;	      legs_comm :=	        fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) (x : sig_seq B n0) =>	        match	          p as p0 in (_ = y)	          return (inj A y (((sig_seq B) _f p0) (x.1; x.2)).1 = inj A n0 x.1)	        with	        | 1 => colimp n0 n0.+1 1 x.1	        end	    |} n n.+1 1 (a; b)	";
            responses[i]=data;
          

            i = 527;
            data = "1 goal (ID 953)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  ============================	  colimp n n.+1 1 a @	  ap pr1 (ap (exist (fib_seq_to_type_fam B) (inj A n a)) (colimp 0 1 1 b)) =	  legs_comm	    {|	      legs :=	        fun (n0 : Graph.graph0 sequence_graph) (X : sig_seq B n0) =>	        inj A n0 X.1;	      legs_comm :=	        fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) (x : sig_seq B n0) =>	        match	          p as p0 in (_ = y)	          return (inj A y (((sig_seq B) _f p0) (x.1; x.2)).1 = inj A n0 x.1)	        with	        | 1 => colimp n0 n0.+1 1 x.1	        end	    |} n n.+1 1 (a; b)	";
            responses[i]=data;
          

            i = 528;
            data = "1 goal (ID 1012)	  	  H : Univalence	  A : Sequence	  B : FibSequence A	  n : Graph.graph0 sequence_graph	  a : A n	  b : B (n; a)	  ============================	  ap (fun _ : Colimit (fib_seq_to_seq B (n; a)) => inj A n a)	    (colimp 0 1 1 b) = 1	";
            responses[i]=data;
          

            i = 529;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 530;
            data = "";
            responses[i]=data;
          

            i = 531;
            data = "";
            responses[i]=data;
          

            i = 532;
            data = "";
            responses[i]=data;
          

            i = 533;
            data = "";
            responses[i]=data;
          

            i = 534;
            data = "";
            responses[i]=data;
          

            i = 535;
            data = "<infomsg>path_seq is defined</infomsg>	";
            responses[i]=data;
          

            i = 536;
            data = "1 goal (ID 899)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  ============================	  inj A 0 a1 = inj A 0 a2 <~> Colimit (path_seq A a1 a2)	";
            responses[i]=data;
          

            i = 537;
            data = "";
            responses[i]=data;
          

            i = 538;
            data = "1 goal (ID 924)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  inj A 0 a1 = inj A 0 a2 <~> Colimit (path_seq A a1 a2)	";
            responses[i]=data;
          

            i = 539;
            data = "2 goals (ID 939)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  inj A 0 a1 = inj A 0 a2 <~> fib_seq_to_type_fam B (inj A 0 a2)		goal 2 (ID 940) is:	 fib_seq_to_type_fam B (inj A 0 a2) <~> Colimit (path_seq A a1 a2)	";
            responses[i]=data;
          

            i = 540;
            data = "1 goal (ID 939)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  inj A 0 a1 = inj A 0 a2 <~> fib_seq_to_type_fam B (inj A 0 a2)	2 goals (ID 997)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  fib_seq_to_type_fam B (inj A 0 a1)		goal 2 (ID 999) is:	 Contr {y : Colimit A & fib_seq_to_type_fam B y}	";
            responses[i]=data;
          

            i = 541;
            data = "1 goal (ID 997)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  fib_seq_to_type_fam B (inj A 0 a1)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 999) is:	 Contr {y : Colimit A & fib_seq_to_type_fam B y}	goal 2 (ID 940) is:	 fib_seq_to_type_fam B (inj A 0 a2) <~> Colimit (path_seq A a1 a2)	";
            responses[i]=data;
          

            i = 542;
            data = "1 goal (ID 999)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  Contr {y : Colimit A & fib_seq_to_type_fam B y}	1 goal (ID 1056)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  Contr (Colimit (sig_seq B))	";
            responses[i]=data;
          

            i = 543;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 940) is:	 fib_seq_to_type_fam B (inj A 0 a2) <~> Colimit (path_seq A a1 a2)	";
            responses[i]=data;
          

            i = 544;
            data = "1 goal (ID 940)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  fib_seq_to_type_fam B (inj A 0 a2) <~> Colimit (path_seq A a1 a2)	1 goal (ID 1241)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  fib_seq_to_seq' B (0; a2) ~d~ path_seq A a1 a2	";
            responses[i]=data;
          

            i = 545;
            data = "2 goals (ID 1266)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  DiagramMap (fib_seq_to_seq' B (0; a2)) (path_seq A a1 a2)		goal 2 (ID 1268) is:	 forall i : Graph.graph0 sequence_graph, IsEquiv (?m i)	";
            responses[i]=data;
          

            i = 546;
            data = "1 goal (ID 1266)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  DiagramMap (fib_seq_to_seq' B (0; a2)) (path_seq A a1 a2)	2 goals (ID 1347)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph,	  fib_seq_to_seq' B (0; a2) i -> path_seq A a1 a2 i		goal 2 (ID 1349) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : fib_seq_to_seq' B (0; a2) i),	 ((path_seq A a1 a2) _f g) (?DiagramMap_obj i x) =	 ?DiagramMap_obj j (((fib_seq_to_seq' B (0; a2)) _f g) x)	";
            responses[i]=data;
          

            i = 547;
            data = "1 goal (ID 1347)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph,	  fib_seq_to_seq' B (0; a2) i -> path_seq A a1 a2 i	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	2 goals		goal 1 (ID 1349) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : fib_seq_to_seq' B (0; a2) i),	 ((path_seq A a1 a2) _f g)	   ((fun n : Graph.graph0 sequence_graph =>	     coe (ap B (seq_shift_pair_from_zero a2 n))) i x) =	 (fun n : Graph.graph0 sequence_graph =>	  coe (ap B (seq_shift_pair_from_zero a2 n))) j	   (((fib_seq_to_seq' B (0; a2)) _f g) x)	goal 2 (ID 1268) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n : Graph.graph0 sequence_graph =>	        coe (ap B (seq_shift_pair_from_zero a2 n));	      DiagramMap_comm := ?DiagramMap_comm	    |} i)	";
            responses[i]=data;
          

            i = 548;
            data = "1 goal (ID 1349)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : fib_seq_to_seq' B (0; a2) i),	  ((path_seq A a1 a2) _f g)	    ((fun n : Graph.graph0 sequence_graph =>	      coe (ap B (seq_shift_pair_from_zero a2 n))) i x) =	  (fun n : Graph.graph0 sequence_graph =>	   coe (ap B (seq_shift_pair_from_zero a2 n))) j	    (((fib_seq_to_seq' B (0; a2)) _f g) x)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	1 goal		goal 1 (ID 1268) is:	 forall i : Graph.graph0 sequence_graph,	 IsEquiv	   ({|	      DiagramMap_obj :=	        fun n : Graph.graph0 sequence_graph =>	        coe (ap B (seq_shift_pair_from_zero a2 n));	      DiagramMap_comm :=	        fun (n m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n m)	          (b : fib_seq_to_seq' B (0; a2) n) =>	        match	          p as p0 in (_ = y)	          return	            (((path_seq A a1 a2) _f p0)	               (coe (ap B (seq_shift_pair_from_zero a2 n)) b) =	             coe (ap B (seq_shift_pair_from_zero a2 y))	               (((fib_seq_to_seq' B (0; a2)) _f p0) b))	        with	        | 1 =>	            K seq_pair_shift (fibSequenceArr B)	              (seq_shift_pair_from_zero a2 n)	        end	    |} i)	";
            responses[i]=data;
          

            i = 549;
            data = "1 goal (ID 1268)	  	  H : Univalence	  A : Sequence	  a1, a2 : A 0	  B := {|	         fibSequence := fun x : {x : _ & A x} => (a1) ^+ (x.1) = x.2;	         fibSequenceArr :=	           fun x : {x : _ & A x} => ap (fun a : A x.1 => (a) ^+)	       |} : FibSequence A	  ============================	  forall i : Graph.graph0 sequence_graph,	  IsEquiv	    ({|	       DiagramMap_obj :=	         fun n : Graph.graph0 sequence_graph =>	         coe (ap B (seq_shift_pair_from_zero a2 n));	       DiagramMap_comm :=	         fun (n m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n m)	           (b : fib_seq_to_seq' B (0; a2) n) =>	         match	           p as p0 in (_ = y)	           return	             (((path_seq A a1 a2) _f p0)	                (coe (ap B (seq_shift_pair_from_zero a2 n)) b) =	              coe (ap B (seq_shift_pair_from_zero a2 y))	                (((fib_seq_to_seq' B (0; a2)) _f p0) b))	         with	         | 1 =>	             K seq_pair_shift (fibSequenceArr B)	               (seq_shift_pair_from_zero a2 n)	         end	     |} i)	No more goals.	";
            responses[i]=data;
          

            i = 550;
            data = "";
            responses[i]=data;
          

            i = 551;
            data = "";
            responses[i]=data;
          

            i = 552;
            data = "";
            responses[i]=data;
          

            i = 553;
            data = "";
            responses[i]=data;
          

            i = 554;
            data = "";
            responses[i]=data;
          

            i = 555;
            data = "1 goal (ID 913)	  	  H : Univalence	  A : Sequence	  n : Graph.graph0 sequence_graph	  a1, a2 : A n	  ============================	  inj A n a1 = inj A n a2 <~> Colimit (path_seq (shift_seq A n) a1 a2)	";
            responses[i]=data;
          

            i = 556;
            data = "";
            responses[i]=data;
          

            i = 557;
            data = "1 goal (ID 937)	  	  H : Univalence	  A : Sequence	  n : Graph.graph0 sequence_graph	  a1, a2 : A n	  ============================	  inj (shift_seq A n) 0 a1 = inj (shift_seq A n) 0 a2 <~>	  inj A n a1 = inj A n a2	";
            responses[i]=data;
          

            i = 558;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 559;
            data = "";
            responses[i]=data;
          

            i = 560;
            data = "";
            responses[i]=data;
          

            i = 561;
            data = "";
            responses[i]=data;
          

            i = 562;
            data = "";
            responses[i]=data;
          

            i = 563;
            data = "";
            responses[i]=data;
          

            i = 564;
            data = "";
            responses[i]=data;
          

            i = 565;
            data = "1 goal (ID 922)	  	  H : Univalence	  A : Sequence	  k : trunc_index	  ============================	  (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	  IsTrunc k (Colimit A)	";
            responses[i]=data;
          

            i = 566;
            data = "";
            responses[i]=data;
          

            i = 567;
            data = "2 goals (ID 928)	  	  H : Univalence	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, Contr (A n)) -> Contr (Colimit A)		goal 2 (ID 931) is:	 forall A : Sequence,	 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	 IsTrunc k.+1 (Colimit A)	";
            responses[i]=data;
          

            i = 568;
            data = "1 goal (ID 928)	  	  H : Univalence	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, Contr (A n)) -> Contr (Colimit A)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet -.	</infomsg>	1 goal		goal 1 (ID 931) is:	 forall A : Sequence,	 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	 IsTrunc k.+1 (Colimit A)	";
            responses[i]=data;
          

            i = 569;
            data = "1 goal (ID 931)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  IsTrunc k.+1 (Colimit A)	2 goals (ID 963)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : A i),	  (fun w : Colimit A =>	   forall y : Colimit A,	   (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	      match n with	      | -2 => Contr_internal A0	      | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	      end) k (w = y)) (inj A i x)		goal 2 (ID 965) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x) (?q j ((A _f g) x)) = 	 ?q i x	";
            responses[i]=data;
          

            i = 570;
            data = "1 goal (ID 963)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : A i),	  (fun w : Colimit A =>	   forall y : Colimit A,	   (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	      match n with	      | -2 => Contr_internal A0	      | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	      end) k (w = y)) (inj A i x)	2 goals (ID 974)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall (x : A 0%nat) (y : Colimit A),	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	     end) k (inj A 0%nat x = y)		goal 2 (ID 977) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	";
            responses[i]=data;
          

            i = 571;
            data = "1 goal (ID 974)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall (x : A 0%nat) (y : Colimit A),	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	     end) k (inj A 0%nat x = y)	2 goals (ID 998)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : A i),	  (fun w : Colimit A =>	   (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	      match n with	      | -2 => Contr_internal A0	      | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	      end) k (inj A 0%nat a = w)) (inj A i x)		goal 2 (ID 1000) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	       end) k (inj A 0%nat a = w)) (colimp i j g x) 	   (?q j ((A _f g) x)) = ?q i x	";
            responses[i]=data;
          

            i = 572;
            data = "1 goal (ID 998)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  ============================	  forall (i : Graph.graph0 sequence_graph) (x : A i),	  (fun w : Colimit A =>	   (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	      match n with	      | -2 => Contr_internal A0	      | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	      end) k (inj A 0%nat a = w)) (inj A i x)	2 goals (ID 1014)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall a b : A 0%nat,	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A 0%nat b)		goal 2 (ID 1017) is:	 forall A : Sequence,	 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	 forall (a : A 0%nat) (b : A (m.+1)%nat),	 (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	    match n with	    | -2 => Contr_internal A0	    | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	    end) k (inj A 0%nat a = inj A (m.+1)%nat b)	";
            responses[i]=data;
          

            i = 573;
            data = "1 goal (ID 1014)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall a b : A 0%nat,	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A 0%nat b)	1 goal (ID 1021)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a, b : A 0%nat	  ============================	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A 0%nat b)	";
            responses[i]=data;
          

            i = 574;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	4 goals		goal 1 (ID 1017) is:	 forall A : Sequence,	 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	 forall (a : A 0%nat) (b : A (m.+1)%nat),	 (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	    match n with	    | -2 => Contr_internal A0	    | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	    end) k (inj A 0%nat a = inj A (m.+1)%nat b)	goal 2 (ID 1000) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	       end) k (inj A 0%nat a = w)) (colimp i j g x)	   ((fun (m : Graph.graph0 sequence_graph) (b : A m) =>	     Overture.nat_rect	       (fun m0 : nat =>	        forall A0 : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	        forall (a0 : A0 0%nat) (b0 : A0 m0),	        (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a0 = inj A0 m0 b0))	       (fun (A0 : Sequence)	          (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	          (a0 b0 : A0 0%nat) =>	        istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A0 0) a0 b0))	          (equiv_path_colim 0%nat a0 b0)^-1)	       (fun (m0 : nat)	          (IHm : forall A0 : Sequence,	                 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	                 forall (a0 : A0 0%nat) (b0 : A0 m0),	                 (fix IsTrunc_internal	                    (n : trunc_index) (A1 : Type) {struct n} : Type :=	                    match n with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a0 = inj A0 m0 b0)) =>	        ?Goal0@{m:=m0}) m A trH a b) j ((A _f g) x)) =	 (fun (m : Graph.graph0 sequence_graph) (b : A m) =>	  Overture.nat_rect	    (fun m0 : nat =>	     forall A0 : Sequence,	     (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	     forall (a0 : A0 0%nat) (b0 : A0 m0),	     (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A1	        | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	        end) k (inj A0 0%nat a0 = inj A0 m0 b0))	    (fun (A0 : Sequence)	       (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	       (a0 b0 : A0 0%nat) =>	     istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A0 0) a0 b0))	       (equiv_path_colim 0%nat a0 b0)^-1)	    (fun (m0 : nat)	       (IHm : forall A0 : Sequence,	              (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	              forall (a0 : A0 0%nat) (b0 : A0 m0),	              (fix IsTrunc_internal	                 (n : trunc_index) (A1 : Type) {struct n} : Type :=	                 match n with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a0 = inj A0 m0 b0)) => 	     ?Goal0@{m:=m0}) m A trH a b) i x	goal 3 (ID 977) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	goal 4 (ID 965) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     Overture.nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           Overture.nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              istrunc_equiv_istrunc	                (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0)) =>	              ?Goal0@{m:=m0}) m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) => 	        ?Goal@{n:=n0}) n A trH) j ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  Overture.nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        Overture.nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0)) =>	           ?Goal0@{m:=m0}) m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) => ?Goal@{n:=n0}) n A trH) i x	";
            responses[i]=data;
          

            i = 575;
            data = "1 goal (ID 1017)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  m : nat	  IHm : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (a : A 0%nat) (b : A m),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	           end) k (inj A 0%nat a = inj A m b)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall (a : A 0%nat) (b : A (m.+1)%nat),	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A (m.+1)%nat b)	1 goal (ID 1017)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  m : nat	  IHm : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (a : A 0%nat) (b : A m),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	           end) k (inj A 0%nat a = inj A m b)	  ============================	  forall A : Sequence,	  (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	  forall (a : A 0%nat) (b : A (m.+1)%nat),	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A (m.+1)%nat b)	1 goal (ID 1045)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  m : nat	  IHm : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (a : A 0%nat) (b : A m),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	           end) k (inj A 0%nat a = inj A m b)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  b : A (m.+1)%nat	  ============================	  (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	     match n with	     | -2 => Contr_internal A0	     | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	     end) k (inj A 0%nat a = inj A (m.+1)%nat b)	";
            responses[i]=data;
          

            i = 576;
            data = "1 goal (ID 1062)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  m : nat	  IHm : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (a : A 0%nat) (b : A m),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	           end) k (inj A 0%nat a = inj A m b)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  b : A (m.+1)%nat	  ============================	  IsTrunc k (inj A 1%nat (a) ^+ = inj A (m.+1)%nat b)	";
            responses[i]=data;
          

            i = 577;
            data = "1 goal (ID 1179)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  m : nat	  IHm : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (a : A 0%nat) (b : A m),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	           end) k (inj A 0%nat a = inj A m b)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  b : A (m.+1)%nat	  ============================	  inj (succ_seq A) 0%nat (a) ^+ = inj (succ_seq A) m b <~>	  inj A 1%nat (a) ^+ = inj A (m.+1)%nat b	";
            responses[i]=data;
          

            i = 578;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 goals		goal 1 (ID 1000) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	       end) k (inj A 0%nat a = w)) (colimp i j g x)	   ((fun (m : Graph.graph0 sequence_graph) (b : A m) =>	     Overture.nat_rect	       (fun m0 : nat =>	        forall A0 : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	        forall (a0 : A0 0%nat) (b0 : A0 m0),	        (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a0 = inj A0 m0 b0))	       (fun (A0 : Sequence)	          (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	          (a0 b0 : A0 0%nat) =>	        istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A0 0) a0 b0))	          (equiv_path_colim 0%nat a0 b0)^-1)	       (fun (m0 : nat)	          (IHm : forall A0 : Sequence,	                 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	                 forall (a0 : A0 0%nat) (b0 : A0 m0),	                 (fix IsTrunc_internal	                    (n : trunc_index) (A1 : Type) {struct n} : Type :=	                    match n with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	          (A0 : Sequence)	          (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	          (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	        istrunc_equiv_istrunc (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	          (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	       trH a b) j ((A _f g) x)) =	 (fun (m : Graph.graph0 sequence_graph) (b : A m) =>	  Overture.nat_rect	    (fun m0 : nat =>	     forall A0 : Sequence,	     (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	     forall (a0 : A0 0%nat) (b0 : A0 m0),	     (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A1	        | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	        end) k (inj A0 0%nat a0 = inj A0 m0 b0))	    (fun (A0 : Sequence)	       (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	       (a0 b0 : A0 0%nat) =>	     istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A0 0) a0 b0))	       (equiv_path_colim 0%nat a0 b0)^-1)	    (fun (m0 : nat)	       (IHm : forall A0 : Sequence,	              (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	              forall (a0 : A0 0%nat) (b0 : A0 m0),	              (fix IsTrunc_internal	                 (n : trunc_index) (A1 : Type) {struct n} : Type :=	                 match n with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	       (A0 : Sequence)	       (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	       (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	     istrunc_equiv_istrunc (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	       (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	    trH a b) i x	goal 2 (ID 977) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	goal 3 (ID 965) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     Overture.nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           Overture.nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              istrunc_equiv_istrunc	                (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              istrunc_equiv_istrunc	                (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) => 	        ?Goal@{n:=n0}) n A trH) j ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  Overture.nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        Overture.nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	             (b0 : A1 (m0.+1)%nat) =>	           istrunc_equiv_istrunc	             (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	             (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	          m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) => ?Goal@{n:=n0}) n A trH) i x	";
            responses[i]=data;
          

            i = 579;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 goals		goal 1 (ID 1000) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	       end) k (inj A 0%nat a = w)) (colimp i j g x)	   ((fun (m : Graph.graph0 sequence_graph) (b : A m) =>	     Overture.nat_rect	       (fun m0 : nat =>	        forall A0 : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	        forall (a0 : A0 0%nat) (b0 : A0 m0),	        (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a0 = inj A0 m0 b0))	       (fun (A0 : Sequence)	          (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	          (a0 b0 : A0 0%nat) =>	        istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A0 0) a0 b0))	          (equiv_path_colim 0%nat a0 b0)^-1)	       (fun (m0 : nat)	          (IHm : forall A0 : Sequence,	                 (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	                 forall (a0 : A0 0%nat) (b0 : A0 m0),	                 (fix IsTrunc_internal	                    (n : trunc_index) (A1 : Type) {struct n} : Type :=	                    match n with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	          (A0 : Sequence)	          (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	          (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	        istrunc_equiv_istrunc (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	          (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	       trH a b) j ((A _f g) x)) =	 (fun (m : Graph.graph0 sequence_graph) (b : A m) =>	  Overture.nat_rect	    (fun m0 : nat =>	     forall A0 : Sequence,	     (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	     forall (a0 : A0 0%nat) (b0 : A0 m0),	     (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A1	        | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	        end) k (inj A0 0%nat a0 = inj A0 m0 b0))	    (fun (A0 : Sequence)	       (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	       (a0 b0 : A0 0%nat) =>	     istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A0 0) a0 b0))	       (equiv_path_colim 0%nat a0 b0)^-1)	    (fun (m0 : nat)	       (IHm : forall A0 : Sequence,	              (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	              forall (a0 : A0 0%nat) (b0 : A0 m0),	              (fix IsTrunc_internal	                 (n : trunc_index) (A1 : Type) {struct n} : Type :=	                 match n with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	       (A0 : Sequence)	       (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	       (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	     istrunc_equiv_istrunc (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	       (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	    trH a b) i x	goal 2 (ID 977) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	goal 3 (ID 965) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     Overture.nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           Overture.nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              istrunc_equiv_istrunc	                (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              istrunc_equiv_istrunc	                (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) => 	        ?Goal@{n:=n0}) n A trH) j ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  Overture.nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        Overture.nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	             (b0 : A1 (m0.+1)%nat) =>	           istrunc_equiv_istrunc	             (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	             (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	          m A0 trH0 a b) ?pp_q0@{A:=A0; trH:=trH0})	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) => ?Goal@{n:=n0}) n A trH) i x	1 goal (ID 1000)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : A i),	  transport	    (fun w : Colimit A =>	     (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A0	        | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	        end) k (inj A 0%nat a = w)) (colimp i j g x)	    ((fun (m : Graph.graph0 sequence_graph) (b : A m) =>	      Overture.nat_rect	        (fun m0 : nat =>	         forall A0 : Sequence,	         (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	         forall (a0 : A0 0%nat) (b0 : A0 m0),	         (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	              Type :=	            match n with	            | -2 => Contr_internal A1	            | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	            end) k (inj A0 0%nat a0 = inj A0 m0 b0))	        (fun (A0 : Sequence)	           (trH0 : forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) (a0 b0 : A0 0%nat) =>	         istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A0 0) a0 b0))	           (equiv_path_colim 0%nat a0 b0)^-1)	        (fun (m0 : nat)	           (IHm : forall A0 : Sequence,	                  (forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) ->	                  forall (a0 : A0 0%nat) (b0 : A0 m0),	                  (fix IsTrunc_internal	                     (n : trunc_index) (A1 : Type) {struct n} : Type :=	                     match n with	                     | -2 => Contr_internal A1	                     | n'.+1 =>	                         forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                     end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	           (A0 : Sequence)	           (trH0 : forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) (a0 : A0 0%nat) 	           (b0 : A0 (m0.+1)%nat) =>	         istrunc_equiv_istrunc (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	           (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m	        A trH a b) j ((A _f g) x)) =	  (fun (m : Graph.graph0 sequence_graph) (b : A m) =>	   Overture.nat_rect	     (fun m0 : nat =>	      forall A0 : Sequence,	      (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	      forall (a0 : A0 0%nat) (b0 : A0 m0),	      (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	           Type :=	         match n with	         | -2 => Contr_internal A1	         | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	         end) k (inj A0 0%nat a0 = inj A0 m0 b0))	     (fun (A0 : Sequence)	        (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	        (a0 b0 : A0 0%nat) =>	      istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A0 0) a0 b0))	        (equiv_path_colim 0%nat a0 b0)^-1)	     (fun (m0 : nat)	        (IHm : forall A0 : Sequence,	               (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	               forall (a0 : A0 0%nat) (b0 : A0 m0),	               (fix IsTrunc_internal	                  (n : trunc_index) (A1 : Type) {struct n} : Type :=	                  match n with	                  | -2 => Contr_internal A1	                  | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                  end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	        (A0 : Sequence)	        (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	        (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	      istrunc_equiv_istrunc (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	        (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	     trH a b) i x	1 goal (ID 1000)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A 0%nat	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : A i),	  transport	    (fun w : Colimit A =>	     (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A0	        | n'.+1 => forall x0 y : A0, IsTrunc_internal n' (x0 = y)	        end) k (inj A 0%nat a = w)) (colimp i j g x)	    ((fun (m : Graph.graph0 sequence_graph) (b : A m) =>	      Overture.nat_rect	        (fun m0 : nat =>	         forall A0 : Sequence,	         (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	         forall (a0 : A0 0%nat) (b0 : A0 m0),	         (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	              Type :=	            match n with	            | -2 => Contr_internal A1	            | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	            end) k (inj A0 0%nat a0 = inj A0 m0 b0))	        (fun (A0 : Sequence)	           (trH0 : forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) (a0 b0 : A0 0%nat) =>	         istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A0 0) a0 b0))	           (equiv_path_colim 0%nat a0 b0)^-1)	        (fun (m0 : nat)	           (IHm : forall A0 : Sequence,	                  (forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) ->	                  forall (a0 : A0 0%nat) (b0 : A0 m0),	                  (fix IsTrunc_internal	                     (n : trunc_index) (A1 : Type) {struct n} : Type :=	                     match n with	                     | -2 => Contr_internal A1	                     | n'.+1 =>	                         forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                     end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	           (A0 : Sequence)	           (trH0 : forall n : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n)) (a0 : A0 0%nat) 	           (b0 : A0 (m0.+1)%nat) =>	         istrunc_equiv_istrunc (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	           (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m	        A trH a b) j ((A _f g) x)) =	  (fun (m : Graph.graph0 sequence_graph) (b : A m) =>	   Overture.nat_rect	     (fun m0 : nat =>	      forall A0 : Sequence,	      (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	      forall (a0 : A0 0%nat) (b0 : A0 m0),	      (fix IsTrunc_internal (n : trunc_index) (A1 : Type) {struct n} :	           Type :=	         match n with	         | -2 => Contr_internal A1	         | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	         end) k (inj A0 0%nat a0 = inj A0 m0 b0))	     (fun (A0 : Sequence)	        (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	        (a0 b0 : A0 0%nat) =>	      istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A0 0) a0 b0))	        (equiv_path_colim 0%nat a0 b0)^-1)	     (fun (m0 : nat)	        (IHm : forall A0 : Sequence,	               (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n)) ->	               forall (a0 : A0 0%nat) (b0 : A0 m0),	               (fix IsTrunc_internal	                  (n : trunc_index) (A1 : Type) {struct n} : Type :=	                  match n with	                  | -2 => Contr_internal A1	                  | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                  end) k (inj A0 0%nat a0 = inj A0 m0 b0)) 	        (A0 : Sequence)	        (trH0 : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n))	        (a0 : A0 0%nat) (b0 : A0 (m0.+1)%nat) =>	      istrunc_equiv_istrunc (inj A0 1%nat (a0) ^+ = inj A0 (m0.+1)%nat b0)	        (equiv_concat_l (glue A0 0%nat a0) (inj A0 (m0.+1)%nat b0))^-1) m A	     trH a b) i x	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 goals		goal 1 (ID 977) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	goal 2 (ID 965) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     Overture.nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           Overture.nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              istrunc_equiv_istrunc	                (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              istrunc_equiv_istrunc	                (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             m A0 trH0 a b)	          (fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (b : A0 n0) =>	           path_ishprop	             (transport	                (fun w : Colimit A0 =>	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	                ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	                  Overture.nat_rect	                    (fun m1 : nat =>	                     forall A1 : Sequence,	                     (forall n1 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n1)) ->	                     forall (a0 : A1 0%nat) (b1 : A1 m1),	                     (fix IsTrunc_internal	                        (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                        match n1 with	                        | -2 => Contr_internal A2	                        | n'.+1 =>	                            forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                        end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (fun (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 b1 : A1 0%nat) =>	                     istrunc_equiv_istrunc	                       (Colimit (path_seq (shift_seq A1 0) a0 b1))	                       (equiv_path_colim 0%nat a0 b1)^-1)	                    (fun (m1 : nat)	                       (IHm : forall A1 : Sequence,	                              (forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) ->	                              forall (a0 : A1 0%nat) 	                              (b1 : A1 m1),	                              (fix IsTrunc_internal	                                 (n1 : trunc_index) (A2 : Type) {struct n1} :	                                   Type :=	                                 match n1 with	                                 | -2 => Contr_internal A2	                                 | n'.+1 =>	                                     forall x0 y : A2,	                                     IsTrunc_internal n' (x0 = y)	                                 end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                       (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                     istrunc_equiv_istrunc	                       (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                       (equiv_concat_l (glue A1 0%nat a0)	                          (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                   ((A0 _f p) b)))	             (Overture.nat_rect	                (fun m0 : nat =>	                 forall A1 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A1 n1)) ->	                 forall (a0 : A1 0%nat) (b0 : A1 m0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A2	                    | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                    end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (fun (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	                 istrunc_equiv_istrunc	                   (Colimit (path_seq (shift_seq A1 0) a0 b0))	                   (equiv_path_colim 0%nat a0 b0)^-1)	                (fun (m0 : nat)	                   (IHm : forall A1 : Sequence,	                          (forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) ->	                          forall (a0 : A1 0%nat) (b0 : A1 m0),	                          (fix IsTrunc_internal	                             (n1 : trunc_index) (A2 : Type) {struct n1} :	                               Type :=	                             match n1 with	                             | -2 => Contr_internal A2	                             | n'.+1 =>	                                 forall x0 y : A2,	                                 IsTrunc_internal n' (x0 = y)	                             end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                   (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                   (b0 : A1 (m0.+1)%nat) =>	                 istrunc_equiv_istrunc	                   (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                   (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	                n0 A0 trH0 a b)))	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) => 	        ?Goal@{n:=n0}) n A trH) j ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  Overture.nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        Overture.nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	             (b0 : A1 (m0.+1)%nat) =>	           istrunc_equiv_istrunc	             (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	             (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	          m A0 trH0 a b)	       (fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) (b : A0 n0) =>	        path_ishprop	          (transport	             (fun w : Colimit A0 =>	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	             ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	               Overture.nat_rect	                 (fun m1 : nat =>	                  forall A1 : Sequence,	                  (forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A1 n1)) ->	                  forall (a0 : A1 0%nat) (b1 : A1 m1),	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A2	                     | n'.+1 =>	                         forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                     end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                 (fun (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 b1 : A1 0%nat) =>	                  istrunc_equiv_istrunc	                    (Colimit (path_seq (shift_seq A1 0) a0 b1))	                    (equiv_path_colim 0%nat a0 b1)^-1)	                 (fun (m1 : nat)	                    (IHm : forall A1 : Sequence,	                           (forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) ->	                           forall (a0 : A1 0%nat) 	                           (b1 : A1 m1),	                           (fix IsTrunc_internal	                              (n1 : trunc_index) (A2 : Type) {struct n1} :	                                Type :=	                              match n1 with	                              | -2 => Contr_internal A2	                              | n'.+1 =>	                                  forall x0 y : A2,	                                  IsTrunc_internal n' (x0 = y)	                              end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                  istrunc_equiv_istrunc	                    (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                    (equiv_concat_l (glue A1 0%nat a0)	                       (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                ((A0 _f p) b)))	          (Overture.nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n1)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	              istrunc_equiv_istrunc	                (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n1 : trunc_index) (A2 : Type) {struct n1} :	                            Type :=	                          match n1 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              istrunc_equiv_istrunc	                (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             n0 A0 trH0 a b)))	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) => ?Goal@{n:=n0}) n A trH) i x	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet *.	</infomsg>	2 goals		goal 1 (ID 977) is:	 forall A : Sequence,	 (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	 forall (x : A (n.+1)%nat) (y : Colimit A),	 (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	    match n0 with	    | -2 => Contr_internal A0	    | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	    end) k (inj A (n.+1)%nat x = y)	goal 2 (ID 965) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     Overture.nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           Overture.nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              istrunc_equiv_istrunc	                (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              istrunc_equiv_istrunc	                (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             m A0 trH0 a b)	          (fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (b : A0 n0) =>	           path_ishprop	             (transport	                (fun w : Colimit A0 =>	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	                ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	                  Overture.nat_rect	                    (fun m1 : nat =>	                     forall A1 : Sequence,	                     (forall n1 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n1)) ->	                     forall (a0 : A1 0%nat) (b1 : A1 m1),	                     (fix IsTrunc_internal	                        (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                        match n1 with	                        | -2 => Contr_internal A2	                        | n'.+1 =>	                            forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                        end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (fun (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 b1 : A1 0%nat) =>	                     istrunc_equiv_istrunc	                       (Colimit (path_seq (shift_seq A1 0) a0 b1))	                       (equiv_path_colim 0%nat a0 b1)^-1)	                    (fun (m1 : nat)	                       (IHm : forall A1 : Sequence,	                              (forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) ->	                              forall (a0 : A1 0%nat) 	                              (b1 : A1 m1),	                              (fix IsTrunc_internal	                                 (n1 : trunc_index) (A2 : Type) {struct n1} :	                                   Type :=	                                 match n1 with	                                 | -2 => Contr_internal A2	                                 | n'.+1 =>	                                     forall x0 y : A2,	                                     IsTrunc_internal n' (x0 = y)	                                 end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                       (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                     istrunc_equiv_istrunc	                       (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                       (equiv_concat_l (glue A1 0%nat a0)	                          (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                   ((A0 _f p) b)))	             (Overture.nat_rect	                (fun m0 : nat =>	                 forall A1 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A1 n1)) ->	                 forall (a0 : A1 0%nat) (b0 : A1 m0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A2	                    | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                    end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (fun (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	                 istrunc_equiv_istrunc	                   (Colimit (path_seq (shift_seq A1 0) a0 b0))	                   (equiv_path_colim 0%nat a0 b0)^-1)	                (fun (m0 : nat)	                   (IHm : forall A1 : Sequence,	                          (forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) ->	                          forall (a0 : A1 0%nat) (b0 : A1 m0),	                          (fix IsTrunc_internal	                             (n1 : trunc_index) (A2 : Type) {struct n1} :	                               Type :=	                             match n1 with	                             | -2 => Contr_internal A2	                             | n'.+1 =>	                                 forall x0 y : A2,	                                 IsTrunc_internal n' (x0 = y)	                             end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                   (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                   (b0 : A1 (m0.+1)%nat) =>	                 istrunc_equiv_istrunc	                   (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                   (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	                n0 A0 trH0 a b)))	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) => 	        ?Goal@{n:=n0}) n A trH) j ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  Overture.nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        Overture.nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	             (b0 : A1 (m0.+1)%nat) =>	           istrunc_equiv_istrunc	             (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	             (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	          m A0 trH0 a b)	       (fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) (b : A0 n0) =>	        path_ishprop	          (transport	             (fun w : Colimit A0 =>	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	             ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	               Overture.nat_rect	                 (fun m1 : nat =>	                  forall A1 : Sequence,	                  (forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A1 n1)) ->	                  forall (a0 : A1 0%nat) (b1 : A1 m1),	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A2	                     | n'.+1 =>	                         forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                     end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                 (fun (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 b1 : A1 0%nat) =>	                  istrunc_equiv_istrunc	                    (Colimit (path_seq (shift_seq A1 0) a0 b1))	                    (equiv_path_colim 0%nat a0 b1)^-1)	                 (fun (m1 : nat)	                    (IHm : forall A1 : Sequence,	                           (forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) ->	                           forall (a0 : A1 0%nat) 	                           (b1 : A1 m1),	                           (fix IsTrunc_internal	                              (n1 : trunc_index) (A2 : Type) {struct n1} :	                                Type :=	                              match n1 with	                              | -2 => Contr_internal A2	                              | n'.+1 =>	                                  forall x0 y : A2,	                                  IsTrunc_internal n' (x0 = y)	                              end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                  istrunc_equiv_istrunc	                    (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                    (equiv_concat_l (glue A1 0%nat a0)	                       (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                ((A0 _f p) b)))	          (Overture.nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n1)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	              istrunc_equiv_istrunc	                (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n1 : trunc_index) (A2 : Type) {struct n1} :	                            Type :=	                          match n1 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              istrunc_equiv_istrunc	                (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             n0 A0 trH0 a b)))	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) => ?Goal@{n:=n0}) n A trH) i x	1 goal (ID 977)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  n : nat	  IHn : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (x : A n) (y : Colimit A),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	           end) k (inj A n x = y)	  ============================	  forall A : Sequence,	  (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n0)) ->	  forall (x : A (n.+1)%nat) (y : Colimit A),	  (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	     match n0 with	     | -2 => Contr_internal A0	     | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	     end) k (inj A (n.+1)%nat x = y)	1 goal (ID 1264)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  n : nat	  IHn : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)) ->	        forall (x : A n) (y : Colimit A),	        (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} :	             Type :=	           match n with	           | -2 => Contr_internal A0	           | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	           end) k (inj A n x = y)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  a : A (n.+1)%nat	  ============================	  forall a0 : Colimit (succ_seq A),	  (fun b : Colimit A =>	   (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} : Type :=	      match n0 with	      | -2 => Contr_internal A0	      | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	      end) k (inj A (n.+1)%nat a = b)) (colim_succ_seq_to_colim_seq A a0)	";
            responses[i]=data;
          

            i = 580;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 965) is:	 forall (i j : Graph.graph0 sequence_graph)	 (g : Graph.graph1 sequence_graph i j) (x : A i),	 transport	   (fun w : Colimit A =>	    forall y : Colimit A,	    (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	       match n with	       | -2 => Contr_internal A0	       | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	       end) k (w = y)) (colimp i j g x)	   ((fun n : Graph.graph0 sequence_graph =>	     Overture.nat_rect	       (fun n0 : nat =>	        forall A0 : Sequence,	        (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	        forall (x0 : A0 n0) (y : Colimit A0),	        (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	             Type :=	           match n1 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	           end) k (inj A0 n0 x0 = y))	       (fun (A0 : Sequence)	          (trH0 : forall n0 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	        Colimit_ind	          (fun w : Colimit A0 =>	           (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A1	              | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	              end) k (inj A0 0%nat a = w))	          (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	           Overture.nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                 match n0 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	              istrunc_equiv_istrunc	                (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n0 : trunc_index) (A2 : Type) {struct n0} :	                            Type :=	                          match n0 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n0 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              istrunc_equiv_istrunc	                (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             m A0 trH0 a b)	          (fun (n0 m : Graph.graph0 sequence_graph)	             (p : Graph.graph1 sequence_graph n0 m) 	             (b : A0 n0) =>	           path_ishprop	             (transport	                (fun w : Colimit A0 =>	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                    end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	                ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	                  Overture.nat_rect	                    (fun m1 : nat =>	                     forall A1 : Sequence,	                     (forall n1 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n1)) ->	                     forall (a0 : A1 0%nat) (b1 : A1 m1),	                     (fix IsTrunc_internal	                        (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                        match n1 with	                        | -2 => Contr_internal A2	                        | n'.+1 =>	                            forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                        end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (fun (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 b1 : A1 0%nat) =>	                     istrunc_equiv_istrunc	                       (Colimit (path_seq (shift_seq A1 0) a0 b1))	                       (equiv_path_colim 0%nat a0 b1)^-1)	                    (fun (m1 : nat)	                       (IHm : forall A1 : Sequence,	                              (forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) ->	                              forall (a0 : A1 0%nat) 	                              (b1 : A1 m1),	                              (fix IsTrunc_internal	                                 (n1 : trunc_index) (A2 : Type) {struct n1} :	                                   Type :=	                                 match n1 with	                                 | -2 => Contr_internal A2	                                 | n'.+1 =>	                                     forall x0 y : A2,	                                     IsTrunc_internal n' (x0 = y)	                                 end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                       (A1 : Sequence)	                       (trH1 : forall n1 : Graph.graph0 sequence_graph,	                               IsTrunc k.+1 (A1 n1)) 	                       (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                     istrunc_equiv_istrunc	                       (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                       (equiv_concat_l (glue A1 0%nat a0)	                          (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                   ((A0 _f p) b)))	             (Overture.nat_rect	                (fun m0 : nat =>	                 forall A1 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A1 n1)) ->	                 forall (a0 : A1 0%nat) (b0 : A1 m0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A2	                    | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                    end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (fun (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	                 istrunc_equiv_istrunc	                   (Colimit (path_seq (shift_seq A1 0) a0 b0))	                   (equiv_path_colim 0%nat a0 b0)^-1)	                (fun (m0 : nat)	                   (IHm : forall A1 : Sequence,	                          (forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) ->	                          forall (a0 : A1 0%nat) (b0 : A1 m0),	                          (fix IsTrunc_internal	                             (n1 : trunc_index) (A2 : Type) {struct n1} :	                               Type :=	                             match n1 with	                             | -2 => Contr_internal A2	                             | n'.+1 =>	                                 forall x0 y : A2,	                                 IsTrunc_internal n' (x0 = y)	                             end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                   (A1 : Sequence)	                   (trH1 : forall n1 : Graph.graph0 sequence_graph,	                           IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                   (b0 : A1 (m0.+1)%nat) =>	                 istrunc_equiv_istrunc	                   (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                   (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	                n0 A0 trH0 a b)))	       (fun (n0 : nat)	          (IHn : forall A0 : Sequence,	                 (forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) ->	                 forall (x0 : A0 n0) (y : Colimit A0),	                 (fix IsTrunc_internal	                    (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                    match n1 with	                    | -2 => Contr_internal A1	                    | n'.+1 =>	                        forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                    end) k (inj A0 n0 x0 = y)) (A0 : Sequence)	          (trH0 : forall n1 : Graph.graph0 sequence_graph,	                  IsTrunc k.+1 (A0 n1)) (a : A0 (n0.+1)%nat) =>	        functor_forall_equiv_pb (colim_succ_seq_to_colim_seq A0)	          (fun x0 : Colimit (succ_seq A0) =>	           istrunc_equiv_istrunc (inj (succ_seq A0) n0 a = x0)	             (equiv_ap (colim_succ_seq_to_colim_seq A0)	                (inj (succ_seq A0) n0 a) x0))) n A trH) j 	      ((A _f g) x)) =	 (fun n : Graph.graph0 sequence_graph =>	  Overture.nat_rect	    (fun n0 : nat =>	     forall A0 : Sequence,	     (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	     forall (x0 : A0 n0) (y : Colimit A0),	     (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	          Type :=	        match n1 with	        | -2 => Contr_internal A1	        | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	        end) k (inj A0 n0 x0 = y))	    (fun (A0 : Sequence)	       (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	       (a : A0 0%nat) =>	     Colimit_ind	       (fun w : Colimit A0 =>	        (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	             Type :=	           match n0 with	           | -2 => Contr_internal A1	           | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	           end) k (inj A0 0%nat a = w))	       (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	        Overture.nat_rect	          (fun m0 : nat =>	           forall A1 : Sequence,	           (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	           forall (a0 : A1 0%nat) (b0 : A1 m0),	           (fix IsTrunc_internal (n0 : trunc_index) (A2 : Type) {struct n0} :	                Type :=	              match n0 with	              | -2 => Contr_internal A2	              | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	          (fun (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	           istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A1 0) a0 b0))	             (equiv_path_colim 0%nat a0 b0)^-1)	          (fun (m0 : nat)	             (IHm : forall A1 : Sequence,	                    (forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) ->	                    forall (a0 : A1 0%nat) (b0 : A1 m0),	                    (fix IsTrunc_internal	                       (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                       match n0 with	                       | -2 => Contr_internal A2	                       | n'.+1 =>	                           forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                       end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (A1 : Sequence)	             (trH1 : forall n0 : Graph.graph0 sequence_graph,	                     IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	             (b0 : A1 (m0.+1)%nat) =>	           istrunc_equiv_istrunc	             (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	             (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	          m A0 trH0 a b)	       (fun (n0 m : Graph.graph0 sequence_graph)	          (p : Graph.graph1 sequence_graph n0 m) (b : A0 n0) =>	        path_ishprop	          (transport	             (fun w : Colimit A0 =>	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                 end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	             ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	               Overture.nat_rect	                 (fun m1 : nat =>	                  forall A1 : Sequence,	                  (forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A1 n1)) ->	                  forall (a0 : A1 0%nat) (b1 : A1 m1),	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A2	                     | n'.+1 =>	                         forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                     end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                 (fun (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 b1 : A1 0%nat) =>	                  istrunc_equiv_istrunc	                    (Colimit (path_seq (shift_seq A1 0) a0 b1))	                    (equiv_path_colim 0%nat a0 b1)^-1)	                 (fun (m1 : nat)	                    (IHm : forall A1 : Sequence,	                           (forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) ->	                           forall (a0 : A1 0%nat) 	                           (b1 : A1 m1),	                           (fix IsTrunc_internal	                              (n1 : trunc_index) (A2 : Type) {struct n1} :	                                Type :=	                              match n1 with	                              | -2 => Contr_internal A2	                              | n'.+1 =>	                                  forall x0 y : A2,	                                  IsTrunc_internal n' (x0 = y)	                              end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                    (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                  istrunc_equiv_istrunc	                    (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                    (equiv_concat_l (glue A1 0%nat a0)	                       (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                ((A0 _f p) b)))	          (Overture.nat_rect	             (fun m0 : nat =>	              forall A1 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n1)) ->	              forall (a0 : A1 0%nat) (b0 : A1 m0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A2	                 | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                 end) k (inj A1 0%nat a0 = inj A1 m0 b0))	             (fun (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	              istrunc_equiv_istrunc	                (Colimit (path_seq (shift_seq A1 0) a0 b0))	                (equiv_path_colim 0%nat a0 b0)^-1)	             (fun (m0 : nat)	                (IHm : forall A1 : Sequence,	                       (forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) ->	                       forall (a0 : A1 0%nat) (b0 : A1 m0),	                       (fix IsTrunc_internal	                          (n1 : trunc_index) (A2 : Type) {struct n1} :	                            Type :=	                          match n1 with	                          | -2 => Contr_internal A2	                          | n'.+1 =>	                              forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                          end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                (A1 : Sequence)	                (trH1 : forall n1 : Graph.graph0 sequence_graph,	                        IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                (b0 : A1 (m0.+1)%nat) =>	              istrunc_equiv_istrunc	                (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	             n0 A0 trH0 a b)))	    (fun (n0 : nat)	       (IHn : forall A0 : Sequence,	              (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	              forall (x0 : A0 n0) (y : Colimit A0),	              (fix IsTrunc_internal	                 (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                 match n1 with	                 | -2 => Contr_internal A1	                 | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                 end) k (inj A0 n0 x0 = y)) (A0 : Sequence)	       (trH0 : forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1))	       (a : A0 (n0.+1)%nat) =>	     functor_forall_equiv_pb (colim_succ_seq_to_colim_seq A0)	       (fun x0 : Colimit (succ_seq A0) =>	        istrunc_equiv_istrunc (inj (succ_seq A0) n0 a = x0)	          (equiv_ap (colim_succ_seq_to_colim_seq A0) 	             (inj (succ_seq A0) n0 a) x0))) n A trH) i x	";
            responses[i]=data;
          

            i = 581;
            data = "1 goal (ID 965)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  ============================	  forall (i j : Graph.graph0 sequence_graph)	  (g : Graph.graph1 sequence_graph i j) (x : A i),	  transport	    (fun w : Colimit A =>	     forall y : Colimit A,	     (fix IsTrunc_internal (n : trunc_index) (A0 : Type) {struct n} : Type :=	        match n with	        | -2 => Contr_internal A0	        | n'.+1 => forall x0 y0 : A0, IsTrunc_internal n' (x0 = y0)	        end) k (w = y)) (colimp i j g x)	    ((fun n : Graph.graph0 sequence_graph =>	      Overture.nat_rect	        (fun n0 : nat =>	         forall A0 : Sequence,	         (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	         forall (x0 : A0 n0) (y : Colimit A0),	         (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	              Type :=	            match n1 with	            | -2 => Contr_internal A1	            | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	            end) k (inj A0 n0 x0 = y))	        (fun (A0 : Sequence)	           (trH0 : forall n0 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n0)) (a : A0 0%nat) =>	         Colimit_ind	           (fun w : Colimit A0 =>	            (fix IsTrunc_internal	               (n0 : trunc_index) (A1 : Type) {struct n0} : Type :=	               match n0 with	               | -2 => Contr_internal A1	               | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	               end) k (inj A0 0%nat a = w))	           (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	            Overture.nat_rect	              (fun m0 : nat =>	               forall A1 : Sequence,	               (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	               forall (a0 : A1 0%nat) (b0 : A1 m0),	               (fix IsTrunc_internal	                  (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                  match n0 with	                  | -2 => Contr_internal A2	                  | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                  end) k (inj A1 0%nat a0 = inj A1 m0 b0))	              (fun (A1 : Sequence)	                 (trH1 : forall n0 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	               istrunc_equiv_istrunc	                 (Colimit (path_seq (shift_seq A1 0) a0 b0))	                 (equiv_path_colim 0%nat a0 b0)^-1)	              (fun (m0 : nat)	                 (IHm : forall A1 : Sequence,	                        (forall n0 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n0)) ->	                        forall (a0 : A1 0%nat) (b0 : A1 m0),	                        (fix IsTrunc_internal	                           (n0 : trunc_index) (A2 : Type) {struct n0} :	                             Type :=	                           match n0 with	                           | -2 => Contr_internal A2	                           | n'.+1 =>	                               forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                           end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                 (A1 : Sequence)	                 (trH1 : forall n0 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	                 (b0 : A1 (m0.+1)%nat) =>	               istrunc_equiv_istrunc	                 (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                 (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	              m A0 trH0 a b)	           (fun (n0 m : Graph.graph0 sequence_graph)	              (p : Graph.graph1 sequence_graph n0 m) 	              (b : A0 n0) =>	            path_ishprop	              (transport	                 (fun w : Colimit A0 =>	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A1	                     | n'.+1 =>	                         forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                     end) k (inj A0 0%nat a = w)) 	                 (colimp n0 m p b)	                 ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	                   Overture.nat_rect	                     (fun m1 : nat =>	                      forall A1 : Sequence,	                      (forall n1 : Graph.graph0 sequence_graph,	                       IsTrunc k.+1 (A1 n1)) ->	                      forall (a0 : A1 0%nat) (b1 : A1 m1),	                      (fix IsTrunc_internal	                         (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                         match n1 with	                         | -2 => Contr_internal A2	                         | n'.+1 =>	                             forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                         end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                     (fun (A1 : Sequence)	                        (trH1 : forall n1 : Graph.graph0 sequence_graph,	                                IsTrunc k.+1 (A1 n1)) 	                        (a0 b1 : A1 0%nat) =>	                      istrunc_equiv_istrunc	                        (Colimit (path_seq (shift_seq A1 0) a0 b1))	                        (equiv_path_colim 0%nat a0 b1)^-1)	                     (fun (m1 : nat)	                        (IHm : forall A1 : Sequence,	                               (forall n1 : Graph.graph0 sequence_graph,	                                IsTrunc k.+1 (A1 n1)) ->	                               forall (a0 : A1 0%nat) 	                               (b1 : A1 m1),	                               (fix IsTrunc_internal	                                  (n1 : trunc_index) (A2 : Type) {struct n1} :	                                    Type :=	                                  match n1 with	                                  | -2 => Contr_internal A2	                                  | n'.+1 =>	                                      forall x0 y : A2,	                                      IsTrunc_internal n' (x0 = y)	                                  end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                        (A1 : Sequence)	                        (trH1 : forall n1 : Graph.graph0 sequence_graph,	                                IsTrunc k.+1 (A1 n1)) 	                        (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                      istrunc_equiv_istrunc	                        (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                        (equiv_concat_l (glue A1 0%nat a0)	                           (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                    ((A0 _f p) b)))	              (Overture.nat_rect	                 (fun m0 : nat =>	                  forall A1 : Sequence,	                  (forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A1 n1)) ->	                  forall (a0 : A1 0%nat) (b0 : A1 m0),	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A2	                     | n'.+1 =>	                         forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                     end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                 (fun (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 b0 : A1 0%nat) =>	                  istrunc_equiv_istrunc	                    (Colimit (path_seq (shift_seq A1 0) a0 b0))	                    (equiv_path_colim 0%nat a0 b0)^-1)	                 (fun (m0 : nat)	                    (IHm : forall A1 : Sequence,	                           (forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) ->	                           forall (a0 : A1 0%nat) 	                           (b0 : A1 m0),	                           (fix IsTrunc_internal	                              (n1 : trunc_index) (A2 : Type) {struct n1} :	                                Type :=	                              match n1 with	                              | -2 => Contr_internal A2	                              | n'.+1 =>	                                  forall x0 y : A2,	                                  IsTrunc_internal n' (x0 = y)	                              end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                    (A1 : Sequence)	                    (trH1 : forall n1 : Graph.graph0 sequence_graph,	                            IsTrunc k.+1 (A1 n1)) 	                    (a0 : A1 0%nat) (b0 : A1 (m0.+1)%nat) =>	                  istrunc_equiv_istrunc	                    (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                    (equiv_concat_l (glue A1 0%nat a0)	                       (inj A1 (m0.+1)%nat b0))^-1) n0 A0 trH0 a b)))	        (fun (n0 : nat)	           (IHn : forall A0 : Sequence,	                  (forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n1)) ->	                  forall (x0 : A0 n0) (y : Colimit A0),	                  (fix IsTrunc_internal	                     (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                     match n1 with	                     | -2 => Contr_internal A1	                     | n'.+1 =>	                         forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                     end) k (inj A0 n0 x0 = y)) (A0 : Sequence)	           (trH0 : forall n1 : Graph.graph0 sequence_graph,	                   IsTrunc k.+1 (A0 n1)) (a : A0 (n0.+1)%nat) =>	         functor_forall_equiv_pb (colim_succ_seq_to_colim_seq A0)	           (fun x0 : Colimit (succ_seq A0) =>	            istrunc_equiv_istrunc (inj (succ_seq A0) n0 a = x0)	              (equiv_ap (colim_succ_seq_to_colim_seq A0)	                 (inj (succ_seq A0) n0 a) x0))) n A trH) j 	       ((A _f g) x)) =	  (fun n : Graph.graph0 sequence_graph =>	   Overture.nat_rect	     (fun n0 : nat =>	      forall A0 : Sequence,	      (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	      forall (x0 : A0 n0) (y : Colimit A0),	      (fix IsTrunc_internal (n1 : trunc_index) (A1 : Type) {struct n1} :	           Type :=	         match n1 with	         | -2 => Contr_internal A1	         | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	         end) k (inj A0 n0 x0 = y))	     (fun (A0 : Sequence)	        (trH0 : forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n0))	        (a : A0 0%nat) =>	      Colimit_ind	        (fun w : Colimit A0 =>	         (fix IsTrunc_internal (n0 : trunc_index) (A1 : Type) {struct n0} :	              Type :=	            match n0 with	            | -2 => Contr_internal A1	            | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	            end) k (inj A0 0%nat a = w))	        (fun (m : Graph.graph0 sequence_graph) (b : A0 m) =>	         Overture.nat_rect	           (fun m0 : nat =>	            forall A1 : Sequence,	            (forall n0 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n0)) ->	            forall (a0 : A1 0%nat) (b0 : A1 m0),	            (fix IsTrunc_internal	               (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	               match n0 with	               | -2 => Contr_internal A2	               | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	               end) k (inj A1 0%nat a0 = inj A1 m0 b0))	           (fun (A1 : Sequence)	              (trH1 : forall n0 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n0)) (a0 b0 : A1 0%nat) =>	            istrunc_equiv_istrunc (Colimit (path_seq (shift_seq A1 0) a0 b0))	              (equiv_path_colim 0%nat a0 b0)^-1)	           (fun (m0 : nat)	              (IHm : forall A1 : Sequence,	                     (forall n0 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n0)) ->	                     forall (a0 : A1 0%nat) (b0 : A1 m0),	                     (fix IsTrunc_internal	                        (n0 : trunc_index) (A2 : Type) {struct n0} : Type :=	                        match n0 with	                        | -2 => Contr_internal A2	                        | n'.+1 =>	                            forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                        end) k (inj A1 0%nat a0 = inj A1 m0 b0))	              (A1 : Sequence)	              (trH1 : forall n0 : Graph.graph0 sequence_graph,	                      IsTrunc k.+1 (A1 n0)) (a0 : A1 0%nat)	              (b0 : A1 (m0.+1)%nat) =>	            istrunc_equiv_istrunc	              (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	              (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	           m A0 trH0 a b)	        (fun (n0 m : Graph.graph0 sequence_graph)	           (p : Graph.graph1 sequence_graph n0 m) 	           (b : A0 n0) =>	         path_ishprop	           (transport	              (fun w : Colimit A0 =>	               (fix IsTrunc_internal	                  (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                  match n1 with	                  | -2 => Contr_internal A1	                  | n'.+1 => forall x0 y : A1, IsTrunc_internal n' (x0 = y)	                  end) k (inj A0 0%nat a = w)) (colimp n0 m p b)	              ((fun (m0 : Graph.graph0 sequence_graph) (b0 : A0 m0) =>	                Overture.nat_rect	                  (fun m1 : nat =>	                   forall A1 : Sequence,	                   (forall n1 : Graph.graph0 sequence_graph,	                    IsTrunc k.+1 (A1 n1)) ->	                   forall (a0 : A1 0%nat) (b1 : A1 m1),	                   (fix IsTrunc_internal	                      (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                      match n1 with	                      | -2 => Contr_internal A2	                      | n'.+1 =>	                          forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                      end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                  (fun (A1 : Sequence)	                     (trH1 : forall n1 : Graph.graph0 sequence_graph,	                             IsTrunc k.+1 (A1 n1)) 	                     (a0 b1 : A1 0%nat) =>	                   istrunc_equiv_istrunc	                     (Colimit (path_seq (shift_seq A1 0) a0 b1))	                     (equiv_path_colim 0%nat a0 b1)^-1)	                  (fun (m1 : nat)	                     (IHm : forall A1 : Sequence,	                            (forall n1 : Graph.graph0 sequence_graph,	                             IsTrunc k.+1 (A1 n1)) ->	                            forall (a0 : A1 0%nat) 	                            (b1 : A1 m1),	                            (fix IsTrunc_internal	                               (n1 : trunc_index) (A2 : Type) {struct n1} :	                                 Type :=	                               match n1 with	                               | -2 => Contr_internal A2	                               | n'.+1 =>	                                   forall x0 y : A2,	                                   IsTrunc_internal n' (x0 = y)	                               end) k (inj A1 0%nat a0 = inj A1 m1 b1))	                     (A1 : Sequence)	                     (trH1 : forall n1 : Graph.graph0 sequence_graph,	                             IsTrunc k.+1 (A1 n1)) 	                     (a0 : A1 0%nat) (b1 : A1 (m1.+1)%nat) =>	                   istrunc_equiv_istrunc	                     (inj A1 1%nat (a0) ^+ = inj A1 (m1.+1)%nat b1)	                     (equiv_concat_l (glue A1 0%nat a0)	                        (inj A1 (m1.+1)%nat b1))^-1) m0 A0 trH0 a b0) m	                 ((A0 _f p) b)))	           (Overture.nat_rect	              (fun m0 : nat =>	               forall A1 : Sequence,	               (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A1 n1)) ->	               forall (a0 : A1 0%nat) (b0 : A1 m0),	               (fix IsTrunc_internal	                  (n1 : trunc_index) (A2 : Type) {struct n1} : Type :=	                  match n1 with	                  | -2 => Contr_internal A2	                  | n'.+1 => forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                  end) k (inj A1 0%nat a0 = inj A1 m0 b0))	              (fun (A1 : Sequence)	                 (trH1 : forall n1 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n1)) (a0 b0 : A1 0%nat) =>	               istrunc_equiv_istrunc	                 (Colimit (path_seq (shift_seq A1 0) a0 b0))	                 (equiv_path_colim 0%nat a0 b0)^-1)	              (fun (m0 : nat)	                 (IHm : forall A1 : Sequence,	                        (forall n1 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n1)) ->	                        forall (a0 : A1 0%nat) (b0 : A1 m0),	                        (fix IsTrunc_internal	                           (n1 : trunc_index) (A2 : Type) {struct n1} :	                             Type :=	                           match n1 with	                           | -2 => Contr_internal A2	                           | n'.+1 =>	                               forall x0 y : A2, IsTrunc_internal n' (x0 = y)	                           end) k (inj A1 0%nat a0 = inj A1 m0 b0))	                 (A1 : Sequence)	                 (trH1 : forall n1 : Graph.graph0 sequence_graph,	                         IsTrunc k.+1 (A1 n1)) (a0 : A1 0%nat)	                 (b0 : A1 (m0.+1)%nat) =>	               istrunc_equiv_istrunc	                 (inj A1 1%nat (a0) ^+ = inj A1 (m0.+1)%nat b0)	                 (equiv_concat_l (glue A1 0%nat a0) (inj A1 (m0.+1)%nat b0))^-1)	              n0 A0 trH0 a b)))	     (fun (n0 : nat)	        (IHn : forall A0 : Sequence,	               (forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1)) ->	               forall (x0 : A0 n0) (y : Colimit A0),	               (fix IsTrunc_internal	                  (n1 : trunc_index) (A1 : Type) {struct n1} : Type :=	                  match n1 with	                  | -2 => Contr_internal A1	                  | n'.+1 => forall x1 y0 : A1, IsTrunc_internal n' (x1 = y0)	                  end) k (inj A0 n0 x0 = y)) (A0 : Sequence)	        (trH0 : forall n1 : Graph.graph0 sequence_graph, IsTrunc k.+1 (A0 n1))	        (a : A0 (n0.+1)%nat) =>	      functor_forall_equiv_pb (colim_succ_seq_to_colim_seq A0)	        (fun x0 : Colimit (succ_seq A0) =>	         istrunc_equiv_istrunc (inj (succ_seq A0) n0 a = x0)	           (equiv_ap (colim_succ_seq_to_colim_seq A0)	              (inj (succ_seq A0) n0 a) x0))) n A trH) i x	1 goal (ID 1512)	  	  H : Univalence	  k : trunc_index	  IHk : forall A : Sequence,	        (forall n : Graph.graph0 sequence_graph, IsTrunc k (A n)) ->	        IsTrunc k (Colimit A)	  A : Sequence	  trH : forall n : Graph.graph0 sequence_graph, IsTrunc k.+1 (A n)	  n, m : Graph.graph0 sequence_graph	  p : Graph.graph1 sequence_graph n m	  a : A n	  ============================	  forall a0 : Colimit A,	  IsHProp	    ((fun a1 : Colimit A =>	      (fix IsTrunc_internal (n0 : trunc_index) (A0 : Type) {struct n0} :	           Type :=	         match n0 with	         | -2 => Contr_internal A0	         | n'.+1 => forall x y : A0, IsTrunc_internal n' (x = y)	         end) k (inj A n a = a1)) a0)	";
            responses[i]=data;
          

            i = 582;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 583;
            data = "";
            responses[i]=data;
          

            i = 584;
            data = "";
            responses[i]=data;
          

            i = 585;
            data = "";
            responses[i]=data;
          

            i = 586;
            data = "";
            responses[i]=data;
          

            i = 587;
            data = "";
            responses[i]=data;
          

            i = 588;
            data = "";
            responses[i]=data;
          

            i = 589;
            data = "";
            responses[i]=data;
          

            i = 590;
            data = "";
            responses[i]=data;
          

            i = 591;
            data = "";
            responses[i]=data;
          

            i = 592;
            data = "";
            responses[i]=data;
          

            i = 593;
            data = "";
            responses[i]=data;
          

            i = 594;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.Colimits.Sequential</h1>
<div scenenumber="3" class="code"><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
</span></div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
We present a proof of the conjecture that sequential colimits in HoTT apropriately commute with Σ-types. As a corollary, we characterize the path space of a sequential colimit as a sequential colimit of path spaces. For the written account of these results see https://www.cs.cornell.edu/~ks858/papers/sequential_colimits_homotopy.pdf. 
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(10, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">Basics</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(11, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">Types</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(12, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#"><span class="id" title="library">Diagrams.Diagram</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(13, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Diagrams.Sequence.html#"><span class="id" title="library">Diagrams.Sequence</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(14, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#"><span class="id" title="library">Diagrams.Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(15, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Colimits.Colimit.html#"><span class="id" title="library">Colimits.Colimit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(16, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Spaces.Nat.html#"><span class="id" title="library">Spaces.Nat</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(17, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.HProp.html#"><span class="id" title="library">HProp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(18, '0_3_7');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.PathAny.html#"><span class="id" title="library">PathAny</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(19, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">nat_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(20, '0_3_7');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(21, '0_3_7');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="coe" class="idref" href="#coe"><span class="id" title="abbreviation">coe</span></a> := (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(22, '0_3_7');
      "><br>
<span class="id" title="keyword">Notation</span> <a id="08eb96ff0845089548bf8ee31b997ae3" class="idref" href="#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">"</span></a>a ^+" := (@<a class="idref" href="HoTT.Diagrams.Diagram.html#arr"><span class="id" title="projection">arr</span></a> <a class="idref" href="HoTT.Diagrams.Sequence.html#sequence_graph"><span class="id" title="definition">sequence_graph</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> 1 <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(23, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
Mapping spaces into hprops from colimits of sequences can be characterized. 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(27, '0_3_11');
      ">
<span class="id" title="keyword">Lemma</span> <a id="equiv_colim_seq_rec" class="idref" href="#equiv_colim_seq_rec"><span class="id" title="lemma">equiv_colim_seq_rec</span></a> `{<a id="H:1" class="idref" href="#H:1"><span class="id" title="binder">Funext</span></a>} (<a id="A:2" class="idref" href="#A:2"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>) (<a id="P:3" class="idref" href="#P:3"><span class="id" title="binder">P</span></a> : <span class="id" title="keyword">Type</span>) `{<a id="IsHProp0:4" class="idref" href="#IsHProp0:4"><span class="id" title="binder">IsHProp</span></a> <a id="IsHProp0:4" class="idref" href="#IsHProp0:4"><span class="id" title="binder">P</span></a>}<br>
  : <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:2"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#P:3"><span class="id" title="variable">P</span></a><a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:5" class="idref" href="#n:5"><span class="id" title="binder">n</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:2"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:5"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#P:3"><span class="id" title="variable">P</span></a><a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(28, '0_3_11');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(29, '0_3_11');
      "><br>
  <span class="id" title="tactic">symmetry</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(30, '0_3_11');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#equiv_colimit_rec"><span class="id" title="definition">equiv_colimit_rec</span></a> <span class="id" title="var">P</span> <a class="idref" href="HoTT.Basics.Equivalences.html#::equiv_scope:x_'oE'_x"><span class="id" title="notation">oE</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(31, '0_3_11');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Diagrams.Cocone.html#issig_Cocone"><span class="id" title="definition">issig_Cocone</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#::equiv_scope:x_'oE'_x"><span class="id" title="notation">oE</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(32, '0_3_11');
      "><br>
  <span class="id" title="tactic">symmetry</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(33, '0_3_11');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Overture.html#Build_Equiv"><span class="id" title="constructor">Build_Equiv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(34, '0_3_11');
      "><br>
  1: <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(35, '0_3_11');
      "><br>
  <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(36, '0_3_11');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(37, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
If a sequential colimit has maps homotopic to a constant map then the colimit is contractible. 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(41, '0_3_15');
      ">
<span class="id" title="keyword">Global Instance</span> <a id="contr_colim_seq_into_prop" class="idref" href="#contr_colim_seq_into_prop"><span class="id" title="instance">contr_colim_seq_into_prop</span></a> {<a id="funext:6" class="idref" href="#funext:6"><span class="id" title="binder">funext</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Funext"><span class="id" title="class">Funext</span></a>} (<a id="A:7" class="idref" href="#A:7"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>)<br>
  (<a id="a:9" class="idref" href="#a:9"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:8" class="idref" href="#n:8"><span class="id" title="binder">n</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:7"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:8"><span class="id" title="variable">n</span></a>) (<a id="H:11" class="idref" href="#H:11"><span class="id" title="binder">H</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:10" class="idref" href="#n:10"><span class="id" title="binder">n</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#a:9"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:10"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:7"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Diagrams.Diagram.html#:::x_'_f'_x"><span class="id" title="notation">_f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>)<br>
  : <a class="idref" href="HoTT.Basics.Overture.html#Contr"><span class="id" title="abbreviation">Contr</span></a> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:7"><span class="id" title="variable">A</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(42, '0_3_15');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(43, '0_3_15');
      "><br>
  <span class="id" title="var">transparent</span> <span class="id" title="tactic">assert</span> (<span class="id" title="var">B</span> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(44, '0_3_15');
      "><br>
  { <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(45, '0_3_15');
      "><br>
    1: <span class="id" title="tactic">exact</span> <span class="id" title="var">A</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(46, '0_3_15');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(47, '0_3_15');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#const"><span class="id" title="definition">const</span></a> (<span class="id" title="var">a</span> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a>)). }</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(48, '0_3_15');
      "><br>
  <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#contr_equiv'"><span class="id" title="definition">contr_equiv'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(49, '0_3_15');
      "><br>
  1: <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#equiv_functor_colimit"><span class="id" title="definition">equiv_functor_colimit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(50, '0_3_15');
      "><br>
  1: <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Diagrams.Sequence.html#equiv_sequence"><span class="id" title="definition">equiv_sequence</span></a> <span class="id" title="var">B</span> <span class="id" title="var">A</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(51, '0_3_15');
      "><br>
  1: <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(52, '0_3_15');
      "><br>
  { <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">e</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(53, '0_3_15');
      "><br>
    <span class="id" title="tactic">∃</span> <a class="idref" href="HoTT.Basics.Equivalences.html#equiv_idmap"><span class="id" title="definition">equiv_idmap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(54, '0_3_15');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(55, '0_3_15');
      "><br>
    <span class="id" title="tactic">symmetry</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(56, '0_3_15');
      "><br>
    <span class="id" title="tactic">exact</span> (<span class="id" title="var">H</span> <span class="id" title="var">_</span> (<span class="id" title="var">e</span> <span class="id" title="var">x</span>)). }</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(57, '0_3_15');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Overture.html#Build_Contr"><span class="id" title="constructor">Build_Contr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(58, '0_3_15');
      "><br>
  1: <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#colim"><span class="id" title="definition">colim</span></a> (<span class="id" title="var">D</span>:=<span class="id" title="var">B</span>) 1%<span class="id" title="var">nat</span> (<span class="id" title="var">a</span> 1%<span class="id" title="var">nat</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(59, '0_3_15');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(60, '0_3_15');
      "><br>
  { <span class="id" title="tactic">intros</span> <span class="id" title="var">i</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(61, '0_3_15');
      "><br>
    <span class="id" title="tactic">induction</span> <span class="id" title="var">i</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(62, '0_3_15');
      "><br>
    1: <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#colimp"><span class="id" title="definition">colimp</span></a> (<span class="id" title="var">D</span>:=<span class="id" title="var">B</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(63, '0_3_15');
      "><br>
    <span class="id" title="tactic">refine</span> (<span class="id" title="var">IHi</span> (<span class="id" title="var">a</span> <span class="id" title="var">i</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(64, '0_3_15');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Colimit.html#colimp"><span class="id" title="definition">colimp</span></a> (<span class="id" title="var">D</span>:=<span class="id" title="var">B</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a> (<span class="id" title="var">a</span> <span class="id" title="var">i</span>)<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(65, '0_3_15');
      "><br>
    <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Colimit.html#colimp"><span class="id" title="definition">colimp</span></a> (<span class="id" title="var">D</span>:=<span class="id" title="var">B</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a> (<span class="id" title="var">a</span> <span class="id" title="var">i</span><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(66, '0_3_15');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#colimp"><span class="id" title="definition">colimp</span></a> (<span class="id" title="var">D</span>:=<span class="id" title="var">B</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a> <span class="id" title="var">x</span>). }</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(67, '0_3_15');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> [] <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(68, '0_3_15');
      "><br>
  <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Types.Paths.html#transport_paths_FlFr"><span class="id" title="definition">transport_paths_FlFr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(69, '0_3_15');
      "><br>
  <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_const"><span class="id" title="definition">ap_const</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(70, '0_3_15');
      "><br>
  <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(71, '0_3_15');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="var">hott_simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(72, '0_3_15');
      "><br>
<span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(73, '0_3_15');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_shift_from_zero_by" class="idref" href="#seq_shift_from_zero_by"><span class="id" title="definition">seq_shift_from_zero_by</span></a> {<a id="A:12" class="idref" href="#A:12"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="a:13" class="idref" href="#a:13"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:12"><span class="id" title="variable">A</span></a> 0) <a id="k:14" class="idref" href="#k:14"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:12"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:14"><span class="id" title="variable">k</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(74, '0_3_15');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(75, '0_3_15');
      "><br>
  <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(76, '0_3_15');
      "><br>
  - <span class="id" title="tactic">exact</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(77, '0_3_15');
      "><br>
  - <span class="id" title="tactic">exact</span> <span class="id" title="var">q</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(78, '0_3_15');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(79, '0_3_15');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="89dcb9d9e23f2b78dc8a1b1571e3a602" class="idref" href="#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">"</span></a>a ^+ k" := (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_shift_from_zero_by"><span class="id" title="definition">seq_shift_from_zero_by</span></a> <span class="id" title="var">a</span> <span class="id" title="var">k</span>).</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(80, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
Shiftings; described in the paragraph after Lemma 3.7. 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(84, '0_3_19');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_pair_shift" class="idref" href="#seq_pair_shift"><span class="id" title="definition">seq_pair_shift</span></a> {<a id="A:15" class="idref" href="#A:15"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="x:16" class="idref" href="#x:16"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:15"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:15"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(85, '0_3_19');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(86, '0_3_19');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n</span> <span class="id" title="var">a</span>]; <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(87, '0_3_19');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(88, '0_3_19');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_pair_shift_by" class="idref" href="#seq_pair_shift_by"><span class="id" title="definition">seq_pair_shift_by</span></a> {<a id="A:17" class="idref" href="#A:17"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="x:18" class="idref" href="#x:18"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:17"><span class="id" title="variable">A</span></a>) (<a id="k:19" class="idref" href="#k:19"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:17"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(89, '0_3_19');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(90, '0_3_19');
      "><br>
  <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(91, '0_3_19');
      "><br>
  - <span class="id" title="tactic">exact</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(92, '0_3_19');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift"><span class="id" title="definition">seq_pair_shift</span></a> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(93, '0_3_19');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(94, '0_3_19');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="18b94a88d8c66f36461830ed891d1ead" class="idref" href="#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">"</span></a>x ^++" := (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift"><span class="id" title="definition">seq_pair_shift</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(95, '0_3_19');
      "><br>
<span class="id" title="keyword">Notation</span> <a id="9bb4541bd65c2f34599b9513bda9dddb" class="idref" href="#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">"</span></a>x ^++ k" := (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift_by"><span class="id" title="definition">seq_pair_shift_by</span></a> <span class="id" title="var">x</span> <span class="id" title="var">k</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(96, '0_3_19');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_pair_shift_assoc" class="idref" href="#seq_pair_shift_assoc"><span class="id" title="definition">seq_pair_shift_assoc</span></a> {<a id="A:20" class="idref" href="#A:20"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="x:21" class="idref" href="#x:21"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:20"><span class="id" title="variable">A</span></a>) (<a id="k:22" class="idref" href="#k:22"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#nat"><span class="id" title="inductive">nat</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:21"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">)^++</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:22"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:21"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">^++(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:22"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(97, '0_3_19');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(98, '0_3_19');
      "><br>
  <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(99, '0_3_19');
      "><br>
  - <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(100, '0_3_19');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift"><span class="id" title="definition">seq_pair_shift</span></a> <span class="id" title="var">q</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(101, '0_3_19');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(102, '0_3_19');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_shift_pair_from_zero" class="idref" href="#seq_shift_pair_from_zero"><span class="id" title="definition">seq_shift_pair_from_zero</span></a> {<a id="A:23" class="idref" href="#A:23"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="a:24" class="idref" href="#a:24"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:23"><span class="id" title="variable">A</span></a> 0) <a id="k:25" class="idref" href="#k:25"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a>0<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:24"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">^++</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:25"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:25"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:24"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:25"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(103, '0_3_19');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(104, '0_3_19');
      "><br>
  <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">q</span>].</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(105, '0_3_19');
      "><br>
  - <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(106, '0_3_19');
      "><br>
  - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift"><span class="id" title="definition">seq_pair_shift</span></a> <span class="id" title="var">q</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(107, '0_3_19');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(108, '0_3_19');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="inj" class="idref" href="#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">A</span> := (@<a class="idref" href="HoTT.Colimits.Colimit.html#colim"><span class="id" title="definition">colim</span></a> <a class="idref" href="HoTT.Diagrams.Sequence.html#sequence_graph"><span class="id" title="definition">sequence_graph</span></a> <span class="id" title="var">A</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(109, '0_3_19');
      "><br>
<span class="id" title="keyword">Notation</span> <a id="glue" class="idref" href="#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span> := (<span class="id" title="keyword">fun</span> <a id="n:26" class="idref" href="#n:26"><span class="id" title="binder">n</span></a> ⇒ @<a class="idref" href="HoTT.Colimits.Colimit.html#colimp"><span class="id" title="definition">colimp</span></a> <a class="idref" href="HoTT.Diagrams.Sequence.html#sequence_graph"><span class="id" title="definition">sequence_graph</span></a> <span class="id" title="var">A</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:26"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:26"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> 1).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(110, '0_3_19');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
The uniqueness principle for sequential colimits; Lemma 3.3. 
</div>
<div scenenumber="23" class="code">
<span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(114, '0_3_23');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colimit_uniq" class="idref" href="#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a> {<a id="A:27" class="idref" href="#A:27"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} <a id="E:28" class="idref" href="#E:28"><span class="id" title="binder">E</span></a> (<a id="F:29" class="idref" href="#F:29"><span class="id" title="binder">F</span></a> <a id="G:30" class="idref" href="#G:30"><span class="id" title="binder">G</span></a> : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:27"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#E:28"><span class="id" title="variable">E</span></a>)<br>
  (<a id="h:32" class="idref" href="#h:32"><span class="id" title="binder">h</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:31" class="idref" href="#n:31"><span class="id" title="binder">n</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:29"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:27"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:31"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:30"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:27"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:31"><span class="id" title="variable">n</span></a>)<br>
  (<a id="H:35" class="idref" href="#H:35"><span class="id" title="binder">H</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:33" class="idref" href="#n:33"><span class="id" title="binder">n</span></a> <a id="a:34" class="idref" href="#a:34"><span class="id" title="binder">a</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:29"><span class="id" title="variable">F</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:27"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:33"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:34"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#h:32"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:33"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:34"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#h:32"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:33"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:34"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:30"><span class="id" title="variable">G</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:27"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:33"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:34"><span class="id" title="variable">a</span></a>))<br>
  : <a class="idref" href="HoTT.Colimits.Sequential.html#F:29"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:30"><span class="id" title="variable">G</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(115, '0_3_23');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(116, '0_3_23');
      "><br>
  <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a> <span class="id" title="var">_</span> <span class="id" title="var">h</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(117, '0_3_23');
      "><br>
  <span class="id" title="tactic">generalize</span> (<span class="id" title="var">H</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>); <span class="id" title="tactic">generalize</span> (<span class="id" title="var">h</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>); <span class="id" title="tactic">destruct</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(118, '0_3_23');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span>; <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>); <span class="id" title="var">srefine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">)</span></a>); <span class="id" title="tactic">exact</span> <span class="id" title="var">q</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(119, '0_3_23');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(120, '0_3_23');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
<div class="doc" scenenumber="25">
The successor sequence from Lemma 3.6. 
</div>
<div scenenumber="27" class="code">
<span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(124, '0_3_27');
      ">
<span class="id" title="keyword">Definition</span> <a id="succ_seq" class="idref" href="#succ_seq"><span class="id" title="definition">succ_seq</span></a> (<a id="A:36" class="idref" href="#A:36"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>) : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a><br>
  := <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a> (<span class="id" title="keyword">fun</span> <a id="k:37" class="idref" href="#k:37"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#A:36"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:37"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a>) (<span class="id" title="keyword">fun</span> <a id="k:38" class="idref" href="#k:38"><span class="id" title="binder">k</span></a> <a id="a:39" class="idref" href="#a:39"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#a:39"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(125, '0_3_27');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_27"><pre><span></span></pre></div>
<div class="doc" scenenumber="29">
The shifted sequence from Lemma 3.7. 
</div>
<div scenenumber="31" class="code">
<span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(129, '0_3_31');
      ">
<span class="id" title="keyword">Definition</span> <a id="shift_seq" class="idref" href="#shift_seq"><span class="id" title="definition">shift_seq</span></a> (<a id="A:40" class="idref" href="#A:40"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>) <a id="n:41" class="idref" href="#n:41"><span class="id" title="binder">n</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a><br>
  := <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a> (<span class="id" title="keyword">fun</span> <a id="k:42" class="idref" href="#k:42"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#A:40"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#k:42"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Spaces.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:41"><span class="id" title="variable">n</span></a>)%<span class="id" title="var">nat</span>) (<span class="id" title="keyword">fun</span> <a id="k:43" class="idref" href="#k:43"><span class="id" title="binder">k</span></a> <a id="a:44" class="idref" href="#a:44"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#a:44"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(130, '0_3_31');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_31"><pre><span></span></pre></div>
<div class="doc" scenenumber="33">
The canonical equivalence between the colimit of the succesor sequence and the colimit of the original sequence; Lemma 3.6. 
</div>
<div scenenumber="35" class="code">
<span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(134, '0_3_35');
      ">
<span class="id" title="keyword">Definition</span> <a id="colim_succ_seq_to_colim_seq" class="idref" href="#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <a id="A:45" class="idref" href="#A:45"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:45"><span class="id" title="variable">A</span></a>) <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:45"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(135, '0_3_35');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(136, '0_3_35');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(137, '0_3_35');
      "><br>
  + <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:48" class="idref" href="#n:48"><span class="id" title="binder">n</span></a> <a id="a:49" class="idref" href="#a:49"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:46"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:47"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(138, '0_3_35');
      "><br>
  + <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(139, '0_3_35');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(140, '0_3_35');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="colim_succ_seq_to_colim_seq_beta_glue" class="idref" href="#colim_succ_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_succ_seq_to_colim_seq_beta_glue</span></a> <a id="A:50" class="idref" href="#A:50"><span class="id" title="binder">A</span></a> <a id="n:51" class="idref" href="#n:51"><span class="id" title="binder">n</span></a> <a id="a:52" class="idref" href="#a:52"><span class="id" title="binder">a</span></a><br>
  : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:50"><span class="id" title="variable">A</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:50"><span class="id" title="variable">A</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:51"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:52"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:50"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#n:51"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#a:52"><span class="id" title="variable">a</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(141, '0_3_35');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(142, '0_3_35');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(143, '0_3_35');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(144, '0_3_35');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="colim_succ_seq_to_colim_seq_ap_inj" class="idref" href="#colim_succ_seq_to_colim_seq_ap_inj"><span class="id" title="definition">colim_succ_seq_to_colim_seq_ap_inj</span></a> <a id="A:53" class="idref" href="#A:53"><span class="id" title="binder">A</span></a> <a id="n:54" class="idref" href="#n:54"><span class="id" title="binder">n</span></a> (<a id="a1:55" class="idref" href="#a1:55"><span class="id" title="binder">a1</span></a> <a id="a2:56" class="idref" href="#a2:56"><span class="id" title="binder">a2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:53"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:54"><span class="id" title="variable">n</span></a>) (<a id="p:57" class="idref" href="#p:57"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#a1:55"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:56"><span class="id" title="variable">a2</span></a>)<br>
  : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:53"><span class="id" title="variable">A</span></a>) (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:54"><span class="id" title="variable">n</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:57"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:54"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:57"><span class="id" title="variable">p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(145, '0_3_35');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(146, '0_3_35');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(147, '0_3_35');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(148, '0_3_35');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a id="isequiv_colim_succ_seq_to_colim_seq" class="idref" href="#isequiv_colim_succ_seq_to_colim_seq"><span class="id" title="instance">isequiv_colim_succ_seq_to_colim_seq</span></a> <a id="A:58" class="idref" href="#A:58"><span class="id" title="binder">A</span></a><br>
  : <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:58"><span class="id" title="variable">A</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(149, '0_3_35');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(150, '0_3_35');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_adjointify"><span class="id" title="definition">isequiv_adjointify</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(151, '0_3_35');
      "><br>
  + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(152, '0_3_35');
      "><br>
    × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:61" class="idref" href="#n:61"><span class="id" title="binder">n</span></a> <a id="a:62" class="idref" href="#a:62"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <span class="id" title="var">A</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:59"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:60"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(153, '0_3_35');
      "><br>
    × <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <span class="id" title="var">A</span>) <span class="id" title="var">n</span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(154, '0_3_35');
      "><br>
  + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(155, '0_3_35');
      "><br>
    × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:65" class="idref" href="#n:65"><span class="id" title="binder">n</span></a> <a id="a:66" class="idref" href="#a:66"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:63"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:64"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(156, '0_3_35');
      "><br>
    × <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a>, <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(157, '0_3_35');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_succ_seq_to_colim_seq_beta_glue</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(158, '0_3_35');
      "><br>
  + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(159, '0_3_35');
      "><br>
    × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:69" class="idref" href="#n:69"><span class="id" title="binder">n</span></a> <a id="a:70" class="idref" href="#a:70"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:67"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:68"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(160, '0_3_35');
      "><br>
    × <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a>, <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(161, '0_3_35');
      "><br>
      <span class="id" title="tactic">rewrite</span> (@<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a> <span class="id" title="var">_</span> <span class="id" title="var">A</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> 1); <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(162, '0_3_35');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(163, '0_3_35');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_colim_succ_seq_to_colim_seq" class="idref" href="#equiv_colim_succ_seq_to_colim_seq"><span class="id" title="definition">equiv_colim_succ_seq_to_colim_seq</span></a> <a id="A:71" class="idref" href="#A:71"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:71"><span class="id" title="variable">A</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:71"><span class="id" title="variable">A</span></a><br>
  := <a class="idref" href="HoTT.Basics.Overture.html#Build_Equiv"><span class="id" title="constructor">Build_Equiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:71"><span class="id" title="variable">A</span></a>) <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(164, '0_3_35');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_35"><pre><span></span></pre></div>
<div class="doc" scenenumber="37">
The canonical equivalence between the colimit of the shifted sequence and the colimit of the original sequence; Lemma 3.6. 
</div>
<div scenenumber="39" class="code">
<span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(168, '0_3_39');
      ">
<span class="id" title="keyword">Definition</span> <a id="colim_shift_seq_to_colim_seq" class="idref" href="#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <a id="A:72" class="idref" href="#A:72"><span class="id" title="binder">A</span></a> <a id="n:73" class="idref" href="#n:73"><span class="id" title="binder">n</span></a> : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:72"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:73"><span class="id" title="variable">n</span></a>) <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:72"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(169, '0_3_39');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(170, '0_3_39');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(171, '0_3_39');
      "><br>
  + <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="k:76" class="idref" href="#k:76"><span class="id" title="binder">k</span></a> <a id="a:77" class="idref" href="#a:77"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">A</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#k:74"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Spaces.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><span class="id" title="var">n</span>)%<span class="id" title="var">nat</span> <a class="idref" href="HoTT.Colimits.Sequential.html#a:75"><span class="id" title="variable">a</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(172, '0_3_39');
      "><br>
  + <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">l</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span> (<span class="id" title="var">k</span><a class="idref" href="HoTT.Spaces.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><span class="id" title="var">n</span>)%<span class="id" title="var">nat</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(173, '0_3_39');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(174, '0_3_39');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="colim_shift_seq_to_colim_seq_beta_glue" class="idref" href="#colim_shift_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_shift_seq_to_colim_seq_beta_glue</span></a> <a id="A:78" class="idref" href="#A:78"><span class="id" title="binder">A</span></a> <a id="n:79" class="idref" href="#n:79"><span class="id" title="binder">n</span></a> <a id="k:80" class="idref" href="#k:80"><span class="id" title="binder">k</span></a> <a id="a:81" class="idref" href="#a:81"><span class="id" title="binder">a</span></a><br>
  : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:78"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:79"><span class="id" title="variable">n</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:78"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:79"><span class="id" title="variable">n</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#k:80"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:81"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:78"><span class="id" title="variable">A</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#k:80"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Spaces.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:79"><span class="id" title="variable">n</span></a>)%<span class="id" title="var">nat</span> <a class="idref" href="HoTT.Colimits.Sequential.html#a:81"><span class="id" title="variable">a</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(175, '0_3_39');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(176, '0_3_39');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(177, '0_3_39');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(178, '0_3_39');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="colim_shift_seq_to_colim_seq_ap_inj" class="idref" href="#colim_shift_seq_to_colim_seq_ap_inj"><span class="id" title="definition">colim_shift_seq_to_colim_seq_ap_inj</span></a> <a id="A:82" class="idref" href="#A:82"><span class="id" title="binder">A</span></a> <a id="n:83" class="idref" href="#n:83"><span class="id" title="binder">n</span></a> <a id="k:84" class="idref" href="#k:84"><span class="id" title="binder">k</span></a> (<a id="a1:85" class="idref" href="#a1:85"><span class="id" title="binder">a1</span></a> <a id="a2:86" class="idref" href="#a2:86"><span class="id" title="binder">a2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:82"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:83"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:84"><span class="id" title="variable">k</span></a>) (<a id="p:87" class="idref" href="#p:87"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#a1:85"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:86"><span class="id" title="variable">a2</span></a>)<br>
  : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:82"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:83"><span class="id" title="variable">n</span></a>) (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#k:84"><span class="id" title="variable">k</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:87"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#k:84"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Spaces.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:83"><span class="id" title="variable">n</span></a>)%<span class="id" title="var">nat</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:87"><span class="id" title="variable">p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(179, '0_3_39');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(180, '0_3_39');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(181, '0_3_39');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(182, '0_3_39');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="J" class="idref" href="#J"><span class="id" title="definition">J</span></a> {<a id="X:88" class="idref" href="#X:88"><span class="id" title="binder">X</span></a> <a id="Y:89" class="idref" href="#Y:89"><span class="id" title="binder">Y</span></a> <a id="Z:90" class="idref" href="#Z:90"><span class="id" title="binder">Z</span></a>} {<a id="x1:91" class="idref" href="#x1:91"><span class="id" title="binder">x1</span></a> <a id="x2:92" class="idref" href="#x2:92"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:88"><span class="id" title="variable">X</span></a>} {<a id="y:93" class="idref" href="#y:93"><span class="id" title="binder">y</span></a>} {<a id="I:95" class="idref" href="#I:95"><span class="id" title="binder">I</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:94" class="idref" href="#x:94"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:89"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:94"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:90"><span class="id" title="variable">Z</span></a>} (<a id="p:96" class="idref" href="#p:96"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:91"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:92"><span class="id" title="variable">x2</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Sequential.html#I:95"><span class="id" title="variable">I</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:92"><span class="id" title="variable">x2</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:93"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#I:95"><span class="id" title="variable">I</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x1:91"><span class="id" title="variable">x1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:89"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:96"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#y:93"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(183, '0_3_39');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(184, '0_3_39');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(185, '0_3_39');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(186, '0_3_39');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="K" class="idref" href="#K"><span class="id" title="definition">K</span></a> {<a id="X:97" class="idref" href="#X:97"><span class="id" title="binder">X</span></a> <a id="Y:98" class="idref" href="#Y:98"><span class="id" title="binder">Y</span></a>} {<a id="x1:99" class="idref" href="#x1:99"><span class="id" title="binder">x1</span></a> <a id="x2:100" class="idref" href="#x2:100"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:97"><span class="id" title="variable">X</span></a>} {<a id="y:101" class="idref" href="#y:101"><span class="id" title="binder">y</span></a>} <a id="F:102" class="idref" href="#F:102"><span class="id" title="binder">F</span></a> <a id="G:103" class="idref" href="#G:103"><span class="id" title="binder">G</span></a> (<a id="p:104" class="idref" href="#p:104"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:99"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:100"><span class="id" title="variable">x2</span></a>) :<br>
  <a class="idref" href="HoTT.Colimits.Sequential.html#G:103"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:100"><span class="id" title="variable">x2</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:98"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:104"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#y:101"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:98"><span class="id" title="variable">Y</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:102"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:104"><span class="id" title="variable">p</span></a>)) (<a class="idref" href="HoTT.Colimits.Sequential.html#G:103"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x1:99"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:101"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(187, '0_3_39');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(188, '0_3_39');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(189, '0_3_39');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(190, '0_3_39');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="L" class="idref" href="#L"><span class="id" title="definition">L</span></a> {<a id="X:105" class="idref" href="#X:105"><span class="id" title="binder">X</span></a> <a id="Y:106" class="idref" href="#Y:106"><span class="id" title="binder">Y</span></a> <a id="Z:107" class="idref" href="#Z:107"><span class="id" title="binder">Z</span></a>} {<a id="x1:108" class="idref" href="#x1:108"><span class="id" title="binder">x1</span></a> <a id="x2:109" class="idref" href="#x2:109"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:105"><span class="id" title="variable">X</span></a>} {<a id="y:110" class="idref" href="#y:110"><span class="id" title="binder">y</span></a>} {<a id="F:111" class="idref" href="#F:111"><span class="id" title="binder">F</span></a> <a id="G:112" class="idref" href="#G:112"><span class="id" title="binder">G</span></a>} {<a id="I:114" class="idref" href="#I:114"><span class="id" title="binder">I</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:113" class="idref" href="#x:113"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:106"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:113"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:107"><span class="id" title="variable">Z</span></a>} {<a id="p:115" class="idref" href="#p:115"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:108"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:109"><span class="id" title="variable">x2</span></a>}<br>
  (<a id="Q:118" class="idref" href="#Q:118"><span class="id" title="binder">Q</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:116" class="idref" href="#x:116"><span class="id" title="binder">x</span></a> <a id="y:117" class="idref" href="#y:117"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#I:114"><span class="id" title="variable">I</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#F:111"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:116"><span class="id" title="variable">x</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#G:112"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:116"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:117"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#I:114"><span class="id" title="variable">I</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:116"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:117"><span class="id" title="variable">y</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Sequential.html#Q:118"><span class="id" title="variable">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:109"><span class="id" title="variable">x2</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:110"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#J"><span class="id" title="definition">J</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:115"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
    <a class="idref" href="HoTT.Colimits.Sequential.html#J"><span class="id" title="definition">J</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:111"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:115"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#I:114"><span class="id" title="variable">I</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#F:111"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x1:108"><span class="id" title="variable">x1</span></a>)) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#K"><span class="id" title="definition">K</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:111"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:112"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:115"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:106"><span class="id" title="variable">Y</span></a>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:111"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:115"><span class="id" title="variable">p</span></a>))) (<a class="idref" href="HoTT.Colimits.Sequential.html#G:112"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:109"><span class="id" title="variable">x2</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:110"><span class="id" title="variable">y</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a><br>
    <a class="idref" href="HoTT.Colimits.Sequential.html#Q:118"><span class="id" title="variable">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x1:108"><span class="id" title="variable">x1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:106"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:115"><span class="id" title="variable">p</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#y:110"><span class="id" title="variable">y</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(191, '0_3_39');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(192, '0_3_39');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">rewrite</span> !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(193, '0_3_39');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(194, '0_3_39');
      "><br>
<br>
<span class="id" title="keyword">Global Instance</span> <a id="isequiv_colim_shift_seq_to_colim_seq" class="idref" href="#isequiv_colim_shift_seq_to_colim_seq"><span class="id" title="instance">isequiv_colim_shift_seq_to_colim_seq</span></a> `{<a id="H:119" class="idref" href="#H:119"><span class="id" title="binder">Funext</span></a>} <a id="A:120" class="idref" href="#A:120"><span class="id" title="binder">A</span></a> <a id="n:121" class="idref" href="#n:121"><span class="id" title="binder">n</span></a><br>
  : <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:120"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:121"><span class="id" title="variable">n</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(195, '0_3_39');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(196, '0_3_39');
      "><br>
  <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">e</span>]; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_homotopic'"><span class="id" title="definition">isequiv_homotopic'</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(197, '0_3_39');
      "><br>
  - <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#equiv_functor_colimit"><span class="id" title="definition">equiv_functor_colimit</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_diagram_equiv"><span class="id" title="constructor">Build_diagram_equiv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(198, '0_3_39');
      "><br>
    + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_DiagramMap"><span class="id" title="constructor">Build_DiagramMap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(199, '0_3_39');
      "><br>
      × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="k:123" class="idref" href="#k:123"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">A</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.Nat.html#nat_add_n_O"><span class="id" title="lemma">nat_add_n_O</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:122"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(200, '0_3_39');
      "><br>
      × <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">l</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#K"><span class="id" title="definition">K</span></a> <a class="idref" href="HoTT.Basics.Overture.html#S"><span class="id" title="constructor">S</span></a> (<span class="id" title="keyword">fun</span> <a id="n:126" class="idref" href="#n:126"><span class="id" title="binder">n</span></a> <a id="a:127" class="idref" href="#a:127"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#a:125"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.Nat.html#nat_add_n_O"><span class="id" title="lemma">nat_add_n_O</span></a> <span class="id" title="var">k</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(201, '0_3_39');
      "><br>
        <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)))).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(202, '0_3_39');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">k</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Types.Universe.html#isequiv_path"><span class="id" title="instance">isequiv_path</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(203, '0_3_39');
      "><br>
  - <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(204, '0_3_39');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#J"><span class="id" title="definition">J</span></a> (<a class="idref" href="HoTT.Spaces.Nat.html#nat_add_n_O"><span class="id" title="lemma">nat_add_n_O</span></a> <span class="id" title="var">k</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(205, '0_3_39');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> !<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#L"><span class="id" title="definition">L</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(206, '0_3_39');
      "><br>
  - <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(207, '0_3_39');
      "><br>
    + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#equiv_functor_colimit"><span class="id" title="definition">equiv_functor_colimit</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_diagram_equiv"><span class="id" title="constructor">Build_diagram_equiv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(208, '0_3_39');
      "><br>
      × <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_DiagramMap"><span class="id" title="constructor">Build_DiagramMap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(209, '0_3_39');
      "><br>
        { <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="k:129" class="idref" href="#k:129"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">A</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.Nat.html#nat_add_n_Sm"><span class="id" title="lemma">nat_add_n_Sm</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:128"><span class="id" title="variable">k</span></a> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>)). }</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(210, '0_3_39');
      "><br>
        { <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">l</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#K"><span class="id" title="definition">K</span></a> <a class="idref" href="HoTT.Basics.Overture.html#S"><span class="id" title="constructor">S</span></a> (<span class="id" title="keyword">fun</span> <a id="n:132" class="idref" href="#n:132"><span class="id" title="binder">n</span></a> <a id="a:133" class="idref" href="#a:133"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#a:131"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Spaces.Nat.html#nat_add_n_Sm"><span class="id" title="lemma">nat_add_n_Sm</span></a> <span class="id" title="var">k</span> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(211, '0_3_39');
      "><br>
          <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap10"><span class="id" title="definition">ap10</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_V"><span class="id" title="definition">ap_V</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)))). }</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(212, '0_3_39');
      "><br>
      × <span class="id" title="tactic">intro</span> <span class="id" title="var">k</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Types.Universe.html#isequiv_path"><span class="id" title="instance">isequiv_path</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(213, '0_3_39');
      "><br>
    + <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#equiv_colim_succ_seq_to_colim_seq"><span class="id" title="definition">equiv_colim_succ_seq_to_colim_seq</span></a> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Basics.Overture.html#Build_Equiv"><span class="id" title="constructor">Build_Equiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(214, '0_3_39');
      "><br>
  - <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(215, '0_3_39');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#J"><span class="id" title="definition">J</span></a> (<a class="idref" href="HoTT.Spaces.Nat.html#nat_add_n_Sm"><span class="id" title="lemma">nat_add_n_Sm</span></a> <span class="id" title="var">k</span> <span class="id" title="var">n</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(216, '0_3_39');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(217, '0_3_39');
      "><br>
      <span class="id" title="tactic">rewrite</span> 2(<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose'"><span class="id" title="definition">ap_compose'</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <span class="id" title="var">k</span> <span class="id" title="var">a</span>)), <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>, 2<a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_pp"><span class="id" title="definition">ap_pp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(218, '0_3_39');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq_ap_inj"><span class="id" title="definition">colim_succ_seq_to_colim_seq_ap_inj</span></a>, <a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq_ap_inj"><span class="id" title="definition">colim_shift_seq_to_colim_seq_ap_inj</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(219, '0_3_39');
      "><br>
      <span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_succ_seq_to_colim_seq_beta_glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(220, '0_3_39');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_shift_seq_to_colim_seq_beta_glue</span></a>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#L"><span class="id" title="definition">L</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(221, '0_3_39');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(222, '0_3_39');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_colim_shift_seq_to_colim_seq" class="idref" href="#equiv_colim_shift_seq_to_colim_seq"><span class="id" title="definition">equiv_colim_shift_seq_to_colim_seq</span></a> `{<a id="H:134" class="idref" href="#H:134"><span class="id" title="binder">Funext</span></a>} <a id="A:135" class="idref" href="#A:135"><span class="id" title="binder">A</span></a> <a id="n:136" class="idref" href="#n:136"><span class="id" title="binder">n</span></a><br>
  : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:135"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:136"><span class="id" title="variable">n</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:135"><span class="id" title="variable">A</span></a><br>
  := <a class="idref" href="HoTT.Basics.Overture.html#Build_Equiv"><span class="id" title="constructor">Build_Equiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:135"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:136"><span class="id" title="variable">n</span></a>) <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(223, '0_3_39');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_39"><pre><span></span></pre></div>
<div class="doc" scenenumber="41">
Corollary 7.7.1 for k := -2; implies Lemma 7.2. 
</div>
<div scenenumber="43" class="code">
<span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(227, '0_3_43');
      ">
<span class="id" title="keyword">Definition</span> <a id="contr_colim_contr_seq" class="idref" href="#contr_colim_contr_seq"><span class="id" title="definition">contr_colim_contr_seq</span></a> `{<a id="H:137" class="idref" href="#H:137"><span class="id" title="binder">Funext</span></a>} (<a id="A:138" class="idref" href="#A:138"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>)<br>
  : <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="k:139" class="idref" href="#k:139"><span class="id" title="binder">k</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Contr"><span class="id" title="abbreviation">Contr</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#A:138"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:139"><span class="id" title="variable">k</span></a>)<a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Overture.html#Contr"><span class="id" title="abbreviation">Contr</span></a> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:138"><span class="id" title="variable">A</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(228, '0_3_43');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(229, '0_3_43');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">h_seqcontr</span>; <span class="id" title="tactic">pose</span> (<span class="id" title="var">unit_seq</span> := <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#Unit"><span class="id" title="inductive">Unit</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(230, '0_3_43');
      "><br>
  <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#contr_equiv'"><span class="id" title="definition">contr_equiv'</span></a> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> <span class="id" title="var">unit_seq</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(231, '0_3_43');
      "><br>
  - <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#equiv_functor_colimit"><span class="id" title="definition">equiv_functor_colimit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(232, '0_3_43');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_diagram_equiv"><span class="id" title="constructor">Build_diagram_equiv</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_DiagramMap"><span class="id" title="constructor">Build_DiagramMap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(233, '0_3_43');
      "><br>
    × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(234, '0_3_43');
      "><br>
    × <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(235, '0_3_43');
      "><br>
  - <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#Build_Contr"><span class="id" title="constructor">Build_Contr</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">unit_seq</span> 0 <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a>)); <span class="id" title="tactic">intro</span> <span class="id" title="var">y</span>; <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">revert</span> <span class="id" title="var">y</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(236, '0_3_43');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(237, '0_3_43');
      "><br>
    × <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">r</span>].</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(238, '0_3_43');
      "><br>
      + <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(239, '0_3_43');
      "><br>
      + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">unit_seq</span> <span class="id" title="var">n</span> <a class="idref" href="HoTT.Basics.Overture.html#tt"><span class="id" title="constructor">tt</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">r</span>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(240, '0_3_43');
      "><br>
    × <span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_const"><span class="id" title="definition">ap_const</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(241, '0_3_43');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(242, '0_3_43');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_43"><pre><span></span></pre></div>
<div class="doc" scenenumber="45">
Fibered sequences; Section 4. 
</div>
<div scenenumber="47" class="code">
<span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(246, '0_3_47');
      ">
<span class="id" title="keyword">Record</span> <a id="FibSequence" class="idref" href="#FibSequence"><span class="id" title="record">FibSequence</span></a> (<a id="A:140" class="idref" href="#A:140"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>) := {<br>
  <a id="fibSequence" class="idref" href="#fibSequence"><span class="id" title="projection">fibSequence</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:140"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>;<br>
  <a id="fibSequenceArr" class="idref" href="#fibSequenceArr"><span class="id" title="projection">fibSequenceArr</span></a> <a id="x:143" class="idref" href="#x:143"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence:142"><span class="id" title="method">fibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:143"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence:142"><span class="id" title="method">fibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:143"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a><br>
}.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(247, '0_3_47');
      "><br>
<br>
<span class="id" title="keyword">Coercion</span> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">fibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">:</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">&gt;-&gt;</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">Funclass</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(248, '0_3_47');
      "><br>
<br>
<span class="id" title="keyword">Arguments</span> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequence"><span class="id" title="projection">fibSequence</span></a> {<span class="id" title="var">A</span>}.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(249, '0_3_47');
      "><br>
<span class="id" title="keyword">Arguments</span> <a class="idref" href="HoTT.Colimits.Sequential.html#fibSequenceArr"><span class="id" title="projection">fibSequenceArr</span></a> {<span class="id" title="var">A</span>}.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(250, '0_3_47');
      "><br>
<br>
<span class="id" title="keyword">Notation</span> <a id="be7681fc4f0bf4f2eee9cf7f11f6ac16" class="idref" href="#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">"</span></a>b ^+f" := (<a class="idref" href="HoTT.Colimits.Sequential.html#fibSequenceArr"><span class="id" title="projection">fibSequenceArr</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(251, '0_3_47');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_47"><pre><span></span></pre></div>
<div class="doc" scenenumber="49">
The Sigma of a fibered type sequence; Definition 4.3. 
</div>
<div scenenumber="51" class="code">
<span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(255, '0_3_51');
      ">
<span class="id" title="keyword">Definition</span> <a id="sig_seq" class="idref" href="#sig_seq"><span class="id" title="definition">sig_seq</span></a> {<a id="A:145" class="idref" href="#A:145"><span class="id" title="binder">A</span></a>} (<a id="B:146" class="idref" href="#B:146"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:145"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(256, '0_3_51');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(257, '0_3_51');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(258, '0_3_51');
      "><br>
  - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:149" class="idref" href="#n:149"><span class="id" title="binder">n</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="a:150" class="idref" href="#a:150"><span class="id" title="binder">a</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <span class="id" title="var">A</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:147"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:147"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:148"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(259, '0_3_51');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <span class="id" title="var">b</span><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">f</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(260, '0_3_51');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(261, '0_3_51');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_51"><pre><span></span></pre></div>
<div class="doc" scenenumber="53">
The canonical projection from the sequential colimit of Sigmas to the sequential colimit of the first component; Definition 4.3. 
</div>
<div scenenumber="55" class="code">
<span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(265, '0_3_55');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_to_seq_colim_fst" class="idref" href="#seq_colim_sum_to_seq_colim_fst"><span class="id" title="definition">seq_colim_sum_to_seq_colim_fst</span></a> {<a id="A:151" class="idref" href="#A:151"><span class="id" title="binder">A</span></a>} (<a id="B:152" class="idref" href="#B:152"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:151"><span class="id" title="variable">A</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:152"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:151"><span class="id" title="variable">A</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(266, '0_3_55');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(267, '0_3_55');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(268, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> [<span class="id" title="var">a</span> <span class="id" title="var">_</span>]; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(269, '0_3_55');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(270, '0_3_55');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(271, '0_3_55');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_55"><pre><span></span></pre></div>
<div class="doc" scenenumber="57">
Given a sequence fibered over A, aach point x : sig A induces a new type sequence; Section 4. 
</div>
<div scenenumber="59" class="code">
<span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(275, '0_3_59');
      ">
<span class="id" title="keyword">Definition</span> <a id="fib_seq_to_seq" class="idref" href="#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> {<a id="A:153" class="idref" href="#A:153"><span class="id" title="binder">A</span></a>} (<a id="B:154" class="idref" href="#B:154"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:153"><span class="id" title="variable">A</span></a>) (<a id="x:155" class="idref" href="#x:155"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:153"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(276, '0_3_59');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(277, '0_3_59');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">k</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">h</span>].</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(278, '0_3_59');
      "><br>
  × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:157" class="idref" href="#x:157"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">B</span> <a class="idref" href="HoTT.Colimits.Sequential.html#x:156"><span class="id" title="variable">x</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(279, '0_3_59');
      "><br>
  × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:159" class="idref" href="#x:159"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">h</span> <a class="idref" href="HoTT.Colimits.Sequential.html#x:158"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(280, '0_3_59');
      "><br>
  × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:162" class="idref" href="#x:162"><span class="id" title="binder">x</span></a> <a id="b:163" class="idref" href="#b:163"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#b:161"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">f</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(281, '0_3_59');
      "><br>
  × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:165" class="idref" href="#x:165"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">h</span> <a class="idref" href="HoTT.Colimits.Sequential.html#x:164"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(282, '0_3_59');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(283, '0_3_59');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_59"><pre><span></span></pre></div>
<div class="doc" scenenumber="61">
The induced sequence can be equivalently described by using shifting; Lemma 7.1. 
</div>
<div scenenumber="63" class="code">
<span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(287, '0_3_63');
      ">
<span class="id" title="keyword">Definition</span> <a id="fib_seq_to_seq'" class="idref" href="#fib_seq_to_seq'"><span class="id" title="definition">fib_seq_to_seq'</span></a> {<a id="A:166" class="idref" href="#A:166"><span class="id" title="binder">A</span></a>} (<a id="B:167" class="idref" href="#B:167"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:166"><span class="id" title="variable">A</span></a>) (<a id="x:168" class="idref" href="#x:168"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:166"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a><br>
  := <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a> (<span class="id" title="keyword">fun</span> <a id="k:169" class="idref" href="#k:169"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#B:167"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:168"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#9bb4541bd65c2f34599b9513bda9dddb"><span class="id" title="notation">^++</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:169"><span class="id" title="variable">k</span></a>) (<span class="id" title="keyword">fun</span> <a id="k:170" class="idref" href="#k:170"><span class="id" title="binder">k</span></a> <a id="b:171" class="idref" href="#b:171"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#b:171"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">f</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(288, '0_3_63');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_fib_seq_to_seq" class="idref" href="#equiv_fib_seq_to_seq"><span class="id" title="definition">equiv_fib_seq_to_seq</span></a> {<a id="A:172" class="idref" href="#A:172"><span class="id" title="binder">A</span></a>} (<a id="B:173" class="idref" href="#B:173"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:172"><span class="id" title="variable">A</span></a>) (<a id="x:174" class="idref" href="#x:174"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:172"><span class="id" title="variable">A</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:173"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:174"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Diagrams.Diagram.html#19674d50802deb812a81f7a836f35199"><span class="id" title="notation">¬</span></a><a class="idref" href="HoTT.Diagrams.Diagram.html#19674d50802deb812a81f7a836f35199"><span class="id" title="notation">d</span></a><a class="idref" href="HoTT.Diagrams.Diagram.html#19674d50802deb812a81f7a836f35199"><span class="id" title="notation">¬</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq'"><span class="id" title="definition">fib_seq_to_seq'</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:173"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:174"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(289, '0_3_63');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(290, '0_3_63');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_diagram_equiv"><span class="id" title="constructor">Build_diagram_equiv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(291, '0_3_63');
      "><br>
  + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_DiagramMap"><span class="id" title="constructor">Build_DiagramMap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(292, '0_3_63');
      "><br>
    × <span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">e</span>].</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(293, '0_3_63');
      "><br>
      - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(294, '0_3_63');
      "><br>
      - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:176" class="idref" href="#x:176"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">B</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_pair_shift_assoc"><span class="id" title="definition">seq_pair_shift_assoc</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:175"><span class="id" title="variable">x</span></a> <span class="id" title="var">n</span>)) <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <span class="id" title="var">e</span> <a class="idref" href="HoTT.Colimits.Sequential.html#x:175"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(295, '0_3_63');
      "><br>
    × <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">p</span>].</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(296, '0_3_63');
      "><br>
      - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(297, '0_3_63');
      "><br>
      - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="x:179" class="idref" href="#x:179"><span class="id" title="binder">x</span></a> <a id="b:180" class="idref" href="#b:180"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#K"><span class="id" title="definition">K</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">p</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#x:177"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#18b94a88d8c66f36461830ed891d1ead"><span class="id" title="notation">^++</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#b:178"><span class="id" title="variable">b</span></a>)<a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(298, '0_3_63');
      "><br>
  + <span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">e</span>].</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(299, '0_3_63');
      "><br>
    × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_idmap"><span class="id" title="instance">isequiv_idmap</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(300, '0_3_63');
      "><br>
    × <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_compose"><span class="id" title="instance">isequiv_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(301, '0_3_63');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(302, '0_3_63');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_63"><pre><span></span></pre></div>
<div class="doc" scenenumber="65">
A fibered type sequence defines a type family; Section 4. 
</div>
<div scenenumber="67" class="code">
<span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(306, '0_3_67');
      ">
<span class="id" title="keyword">Definition</span> <a id="fib_seq_to_type_fam" class="idref" href="#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> `{<a id="H:181" class="idref" href="#H:181"><span class="id" title="binder">Univalence</span></a>} {<a id="A:182" class="idref" href="#A:182"><span class="id" title="binder">A</span></a>} (<a id="B:183" class="idref" href="#B:183"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:182"><span class="id" title="variable">A</span></a>) : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:182"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(307, '0_3_67');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(308, '0_3_67');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(309, '0_3_67');
      "><br>
  - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:186" class="idref" href="#n:186"><span class="id" title="binder">n</span></a> <a id="a:187" class="idref" href="#a:187"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:184"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:185"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(310, '0_3_67');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Universe.html#path_universe_uncurried"><span class="id" title="definition">path_universe_uncurried</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(311, '0_3_67');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#equiv_colim_succ_seq_to_colim_seq"><span class="id" title="definition">equiv_colim_succ_seq_to_colim_seq</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(312, '0_3_67');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(313, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="fib_seq_to_type_fam_beta_glue" class="idref" href="#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> `{<a id="H:188" class="idref" href="#H:188"><span class="id" title="binder">Univalence</span></a>} {<a id="A:189" class="idref" href="#A:189"><span class="id" title="binder">A</span></a>} <a id="B:190" class="idref" href="#B:190"><span class="id" title="binder">B</span></a> <a id="n:191" class="idref" href="#n:191"><span class="id" title="binder">n</span></a> <a id="a:192" class="idref" href="#a:192"><span class="id" title="binder">a</span></a> :<br>
  <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:190"><span class="id" title="variable">B</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:189"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:191"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:192"><span class="id" title="variable">a</span></a>))<a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
  <a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:190"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:191"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:192"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(314, '0_3_67');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(315, '0_3_67');
      "><br>
  <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(316, '0_3_67');
      "><br>
  <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Types.Universe.html#transport_idmap_path_universe_uncurried"><span class="id" title="definition">transport_idmap_path_universe_uncurried</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(317, '0_3_67');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(318, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Delta" class="idref" href="#Delta"><span class="id" title="definition">Delta</span></a> {<a id="X:193" class="idref" href="#X:193"><span class="id" title="binder">X</span></a> <a id="Y:194" class="idref" href="#Y:194"><span class="id" title="binder">Y</span></a>} {<a id="x1:195" class="idref" href="#x1:195"><span class="id" title="binder">x1</span></a> <a id="x2:196" class="idref" href="#x2:196"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:193"><span class="id" title="variable">X</span></a>} {<a id="F:197" class="idref" href="#F:197"><span class="id" title="binder">F</span></a>} (<a id="p:198" class="idref" href="#p:198"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:195"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:196"><span class="id" title="variable">x2</span></a>) (<a id="psi:199" class="idref" href="#psi:199"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:194"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:198"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:197"><span class="id" title="variable">F</span></a>) <a id="y:200" class="idref" href="#y:200"><span class="id" title="binder">y</span></a><br>
  : <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x1:195"><span class="id" title="variable">x1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:200"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x2:196"><span class="id" title="variable">x2</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#F:197"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:200"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(319, '0_3_67');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(320, '0_3_67');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">psi</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(321, '0_3_67');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(322, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Delta_proj" class="idref" href="#Delta_proj"><span class="id" title="definition">Delta_proj</span></a> {<a id="X:201" class="idref" href="#X:201"><span class="id" title="binder">X</span></a> <a id="Y:202" class="idref" href="#Y:202"><span class="id" title="binder">Y</span></a>} {<a id="x1:203" class="idref" href="#x1:203"><span class="id" title="binder">x1</span></a> <a id="x2:204" class="idref" href="#x2:204"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:201"><span class="id" title="variable">X</span></a>} {<a id="F:205" class="idref" href="#F:205"><span class="id" title="binder">F</span></a>} (<a id="p:206" class="idref" href="#p:206"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:203"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:204"><span class="id" title="variable">x2</span></a>) (<a id="psi:207" class="idref" href="#psi:207"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:202"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:206"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:205"><span class="id" title="variable">F</span></a>) <a id="y:208" class="idref" href="#y:208"><span class="id" title="binder">y</span></a><br>
  : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:206"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:207"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:208"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:206"><span class="id" title="variable">p</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(323, '0_3_67');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(324, '0_3_67');
      "><br>
  <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">psi</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(325, '0_3_67');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(326, '0_3_67');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_67"><pre><span></span></pre></div>
<div class="doc" scenenumber="69">
The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits; Definition 5.1. 
</div>
<div scenenumber="71" class="code">
<span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(330, '0_3_71');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_to_sum_seq_colim" class="idref" href="#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> `{<a id="H:209" class="idref" href="#H:209"><span class="id" title="binder">Univalence</span></a>} {<a id="A:210" class="idref" href="#A:210"><span class="id" title="binder">A</span></a>} (<a id="B:211" class="idref" href="#B:211"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:210"><span class="id" title="variable">A</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:211"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:211"><span class="id" title="variable">B</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(331, '0_3_71');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(332, '0_3_71');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec"><span class="id" title="definition">Colimit_rec</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Cocone.html#Build_Cocone"><span class="id" title="constructor">Build_Cocone</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(333, '0_3_71');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) 0 <span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(334, '0_3_71');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="var">srefine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) 0 <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(335, '0_3_71');
      "><br>
    <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <span class="id" title="var">B</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(336, '0_3_71');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(337, '0_3_71');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_to_sum_seq_colim_beta_glue" class="idref" href="#seq_colim_sum_to_sum_seq_colim_beta_glue"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim_beta_glue</span></a> `{<a id="H:212" class="idref" href="#H:212"><span class="id" title="binder">Univalence</span></a>} {<a id="A:213" class="idref" href="#A:213"><span class="id" title="binder">A</span></a>} <a id="B:214" class="idref" href="#B:214"><span class="id" title="binder">B</span></a> <a id="n:215" class="idref" href="#n:215"><span class="id" title="binder">n</span></a> <a id="a:216" class="idref" href="#a:216"><span class="id" title="binder">a</span></a> <a id="b:217" class="idref" href="#b:217"><span class="id" title="binder">b</span></a> :<br>
  <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:214"><span class="id" title="variable">B</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:214"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:215"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:216"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:217"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
  <a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:214"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:215"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:216"><span class="id" title="variable">a</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a><br>
  <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#exist"><span class="id" title="constructor">exist</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:213"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:215"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:216"><span class="id" title="variable">a</span></a>)) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) 0 <a class="idref" href="HoTT.Colimits.Sequential.html#b:217"><span class="id" title="variable">b</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(338, '0_3_71');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(339, '0_3_71');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(340, '0_3_71');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_71');
      " onmouseover="
      mouseover(341, '0_3_71');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_71"><pre><span></span></pre></div>
<div class="doc" scenenumber="73">
An alternative induction principle for the sum of colimits; Lemma 5.2 and Section 6. 
</div>
<div scenenumber="75" class="code">
<span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(345, '0_3_75');
      ">
<span class="id" title="keyword">Section</span> <a id="SeqColimitSumInd" class="idref" href="#SeqColimitSumInd"><span class="id" title="section">SeqColimitSumInd</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(346, '0_3_75');
      "><br>
<br>
  <span class="id" title="keyword">Context</span> `{<a id="H:218" class="idref" href="#H:218"><span class="id" title="binder">Univalence</span></a>} {<a id="A:219" class="idref" href="#A:219"><span class="id" title="binder">A</span></a>} (<a id="B:220" class="idref" href="#B:220"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:219"><span class="id" title="variable">A</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(347, '0_3_75');
      "><br>
  <span class="id" title="keyword">Context</span> (<a id="E:221" class="idref" href="#E:221"><span class="id" title="binder">E</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(348, '0_3_75');
      "><br>
  <span class="id" title="keyword">Context</span> (<a id="e:225" class="idref" href="#e:225"><span class="id" title="binder">e</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:222" class="idref" href="#n:222"><span class="id" title="binder">n</span></a> <a id="a:223" class="idref" href="#a:223"><span class="id" title="binder">a</span></a> <a id="b:224" class="idref" href="#b:224"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:222"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:223"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:224"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(349, '0_3_75');
      "><br>
  <span class="id" title="keyword">Context</span> (<a id="t:229" class="idref" href="#t:229"><span class="id" title="binder">t</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:226" class="idref" href="#n:226"><span class="id" title="binder">n</span></a> <a id="a:227" class="idref" href="#a:227"><span class="id" title="binder">a</span></a> <a id="b:228" class="idref" href="#b:228"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:226"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:227"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:228"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)<br>
    <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:226"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#a:227"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#b:228"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">f</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:226"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:227"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:228"><span class="id" title="variable">b</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_75');
      " onmouseover="
      mouseover(350, '0_3_75');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_75"><pre><span></span></pre></div>
<div class="doc" scenenumber="77">
The point-point case of the nested induction; corresponds to "h" in the paper. 
</div>
<div scenenumber="79" class="code">
<span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(354, '0_3_79');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Q" class="idref" href="#Q"><span class="id" title="definition">Q</span></a> <a id="k:230" class="idref" href="#k:230"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:231" class="idref" href="#n:231"><span class="id" title="binder">n</span></a> <a id="a:232" class="idref" href="#a:232"><span class="id" title="binder">a</span></a> <a id="b:233" class="idref" href="#b:233"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:231"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:232"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#k:230"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:233"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(355, '0_3_79');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(356, '0_3_79');
      "><br>
    <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">h</span>].</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(357, '0_3_79');
      "><br>
    - <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.e"><span class="id" title="variable">e</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(358, '0_3_79');
      "><br>
    - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>) <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <span class="id" title="var">h</span> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> (<span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(359, '0_3_79');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_79');
      " onmouseover="
      mouseover(360, '0_3_79');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_79"><pre><span></span></pre></div>
<div class="doc" scenenumber="81">
The path-point case of the nested induction is just reflexivity; corresponds to "mu" in the paper. 
</div>
<div scenenumber="83" class="code">
<span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(364, '0_3_83');
      ">
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Eta" class="idref" href="#Eta"><span class="id" title="definition">Eta</span></a> {<a id="X:234" class="idref" href="#X:234"><span class="id" title="binder">X</span></a> <a id="Y:235" class="idref" href="#Y:235"><span class="id" title="binder">Y</span></a> <a id="Z:236" class="idref" href="#Z:236"><span class="id" title="binder">Z</span></a>} {<a id="x:237" class="idref" href="#x:237"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:234"><span class="id" title="variable">X</span></a>} {<a id="y1:238" class="idref" href="#y1:238"><span class="id" title="binder">y1</span></a> <a id="y2:239" class="idref" href="#y2:239"><span class="id" title="binder">y2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#Y:235"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:237"><span class="id" title="variable">x</span></a>} {<a id="z:240" class="idref" href="#z:240"><span class="id" title="binder">z</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:235"><span class="id" title="variable">Y</span></a>} {<a id="p:241" class="idref" href="#p:241"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#y1:238"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:239"><span class="id" title="variable">y2</span></a>}<br>
    {<a id="q1:242" class="idref" href="#q1:242"><span class="id" title="binder">q1</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#z:240"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:237"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y1:238"><span class="id" title="variable">y1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>} {<a id="q2:243" class="idref" href="#q2:243"><span class="id" title="binder">q2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#z:240"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:237"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y2:239"><span class="id" title="variable">y2</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>} (<a id="theta:244" class="idref" href="#theta:244"><span class="id" title="binder">theta</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#q2:243"><span class="id" title="variable">q2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q1:242"><span class="id" title="variable">q1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#p:241"><span class="id" title="variable">p</span></a>)<br>
    : <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Z:236"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#exist"><span class="id" title="constructor">exist</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:235"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:237"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:241"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:236"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q1:242"><span class="id" title="variable">q1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:236"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q2:243"><span class="id" title="variable">q2</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(365, '0_3_83');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(366, '0_3_83');
      "><br>
    <span class="id" title="tactic">symmetry</span> <span class="id" title="tactic">in</span> <span class="id" title="var">theta</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">theta</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">q1</span>. </span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(367, '0_3_83');
      "><span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(368, '0_3_83');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(369, '0_3_83');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Epsilon" class="idref" href="#Epsilon"><span class="id" title="definition">Epsilon</span></a> {<a id="X:245" class="idref" href="#X:245"><span class="id" title="binder">X</span></a> <a id="Y:246" class="idref" href="#Y:246"><span class="id" title="binder">Y</span></a> <a id="Z:247" class="idref" href="#Z:247"><span class="id" title="binder">Z</span></a>} {<a id="x1:248" class="idref" href="#x1:248"><span class="id" title="binder">x1</span></a> <a id="x2:249" class="idref" href="#x2:249"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:245"><span class="id" title="variable">X</span></a>} {<a id="y1:250" class="idref" href="#y1:250"><span class="id" title="binder">y1</span></a> <a id="y2:251" class="idref" href="#y2:251"><span class="id" title="binder">y2</span></a>} {<a id="F:252" class="idref" href="#F:252"><span class="id" title="binder">F</span></a>} (<a id="p:253" class="idref" href="#p:253"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:248"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:249"><span class="id" title="variable">x2</span></a>) {<a id="q:254" class="idref" href="#q:254"><span class="id" title="binder">q</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#y1:250"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:251"><span class="id" title="variable">y2</span></a>}<br>
    {<a id="psi:255" class="idref" href="#psi:255"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:246"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:253"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:252"><span class="id" title="variable">F</span></a>} {<a id="r:256" class="idref" href="#r:256"><span class="id" title="binder">r</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#F:252"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y1:250"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:252"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:251"><span class="id" title="variable">y2</span></a>} (<a id="theta:257" class="idref" href="#theta:257"><span class="id" title="binder">theta</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:252"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q:254"><span class="id" title="variable">q</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#r:256"><span class="id" title="variable">r</span></a>)<br>
    : <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Z:247"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#exist"><span class="id" title="constructor">exist</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:246"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:249"><span class="id" title="variable">x2</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#r:256"><span class="id" title="variable">r</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:247"><span class="id" title="variable">Z</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:253"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:255"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y1:250"><span class="id" title="variable">y1</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:247"><span class="id" title="variable">Z</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:253"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:255"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:251"><span class="id" title="variable">y2</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Z:247"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#exist"><span class="id" title="constructor">exist</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:246"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x1:248"><span class="id" title="variable">x1</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#q:254"><span class="id" title="variable">q</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(370, '0_3_83');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(371, '0_3_83');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">theta</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">q</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(372, '0_3_83');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_83');
      " onmouseover="
      mouseover(373, '0_3_83');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_83"><pre><span></span></pre></div>
<div class="doc" scenenumber="85">
The point-path case of the nested induction; corresponds to "H" in the paper. 
</div>
<div scenenumber="87" class="code">
<span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(377, '0_3_87');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="R" class="idref" href="#R"><span class="id" title="definition">R</span></a> <a id="k:258" class="idref" href="#k:258"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:259" class="idref" href="#n:259"><span class="id" title="binder">n</span></a> <a id="a:260" class="idref" href="#a:260"><span class="id" title="binder">a</span></a> <a id="b:261" class="idref" href="#b:261"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#exist"><span class="id" title="constructor">exist</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.A"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:259"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:260"><span class="id" title="variable">a</span></a>)) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#k:258"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:261"><span class="id" title="variable">b</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:258"><span class="id" title="variable">k</span></a><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:259"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:260"><span class="id" title="variable">a</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#b:261"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>)) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:258"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:259"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:260"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:261"><span class="id" title="variable">b</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(378, '0_3_87');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(379, '0_3_87');
      "><br>
    <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">h</span>].</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(380, '0_3_87');
      "><br>
    - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="var">srapply</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.t"><span class="id" title="variable">t</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(381, '0_3_87');
      "><br>
      <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Eta"><span class="id" title="definition">Eta</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim_beta_glue"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(382, '0_3_87');
      "><br>
    - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="var">srefine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> (<span class="id" title="var">h</span> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> (<span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(383, '0_3_87');
      "><br>
      <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Epsilon"><span class="id" title="definition">Epsilon</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.A"><span class="id" title="variable">A</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>) (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_succ_seq_to_colim_seq_beta_glue</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(384, '0_3_87');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_87');
      " onmouseover="
      mouseover(385, '0_3_87');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_87"><pre><span></span></pre></div>
<div class="doc" scenenumber="89">
The point case of the nested induction; corresponds to "g" in the paper. 
</div>
<div scenenumber="91" class="code">
<span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(389, '0_3_91');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="F" class="idref" href="#F"><span class="id" title="definition">F</span></a> <a id="n:262" class="idref" href="#n:262"><span class="id" title="binder">n</span></a> <a id="a:263" class="idref" href="#a:263"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:264" class="idref" href="#x:264"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:262"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:263"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:264"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(390, '0_3_91');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(391, '0_3_91');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(392, '0_3_91');
      "><br>
    - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="k:266" class="idref" href="#k:266"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:265"><span class="id" title="variable">k</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(393, '0_3_91');
      "><br>
    - <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">l</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#R"><span class="id" title="definition">R</span></a> <span class="id" title="var">k</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(394, '0_3_91');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(395, '0_3_91');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="F_beta_glue" class="idref" href="#F_beta_glue"><span class="id" title="definition">F_beta_glue</span></a> <a id="n:267" class="idref" href="#n:267"><span class="id" title="binder">n</span></a> <a id="a:268" class="idref" href="#a:268"><span class="id" title="binder">a</span></a> <a id="b:269" class="idref" href="#b:269"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:267"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:268"><span class="id" title="variable">a</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> 0 <a class="idref" href="HoTT.Colimits.Sequential.html#b:269"><span class="id" title="variable">b</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#R"><span class="id" title="definition">R</span></a> 0 <a class="idref" href="HoTT.Colimits.Sequential.html#n:267"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:268"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:269"><span class="id" title="variable">b</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(396, '0_3_91');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(397, '0_3_91');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_ind_beta_colimp"><span class="id" title="definition">Colimit_ind_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(398, '0_3_91');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(399, '0_3_91');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Phi" class="idref" href="#Phi"><span class="id" title="definition">Phi</span></a> {<a id="X:270" class="idref" href="#X:270"><span class="id" title="binder">X</span></a> <a id="Y:271" class="idref" href="#Y:271"><span class="id" title="binder">Y</span></a> <a id="Z:272" class="idref" href="#Z:272"><span class="id" title="binder">Z</span></a>} {<a id="x1:273" class="idref" href="#x1:273"><span class="id" title="binder">x1</span></a> <a id="x2:274" class="idref" href="#x2:274"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:270"><span class="id" title="variable">X</span></a>} {<a id="y1:275" class="idref" href="#y1:275"><span class="id" title="binder">y1</span></a> <a id="y2:276" class="idref" href="#y2:276"><span class="id" title="binder">y2</span></a>} {<a id="F:277" class="idref" href="#F:277"><span class="id" title="binder">F</span></a>} (<a id="p:278" class="idref" href="#p:278"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:273"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:274"><span class="id" title="variable">x2</span></a>) {<a id="q:279" class="idref" href="#q:279"><span class="id" title="binder">q</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#y1:275"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:276"><span class="id" title="variable">y2</span></a>}<br>
    {<a id="psi:280" class="idref" href="#psi:280"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:271"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:278"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:277"><span class="id" title="variable">F</span></a>} {<a id="G1:282" class="idref" href="#G1:282"><span class="id" title="binder">G1</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="y:281" class="idref" href="#y:281"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:272"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x1:273"><span class="id" title="variable">x1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:281"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>} {<a id="G2:284" class="idref" href="#G2:284"><span class="id" title="binder">G2</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="y:283" class="idref" href="#y:283"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:272"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x2:274"><span class="id" title="variable">x2</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:283"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>}<br>
    {<a id="r:285" class="idref" href="#r:285"><span class="id" title="binder">r</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#F:277"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y1:275"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:277"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:276"><span class="id" title="variable">y2</span></a>} (<a id="theta:286" class="idref" href="#theta:286"><span class="id" title="binder">theta</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:277"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q:279"><span class="id" title="variable">q</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#r:285"><span class="id" title="variable">r</span></a>)<br>
    : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="u1:287" class="idref" href="#u1:287"><span class="id" title="binder">u1</span></a> <a id="u2:288" class="idref" href="#u2:288"><span class="id" title="binder">u2</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G2:284"><span class="id" title="variable">G2</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#r:285"><span class="id" title="variable">r</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#u2:288"><span class="id" title="variable">u2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#r:285"><span class="id" title="variable">r</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#u1:287"><span class="id" title="variable">u1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Epsilon"><span class="id" title="definition">Epsilon</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:278"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#theta:286"><span class="id" title="variable">theta</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#G1:282"><span class="id" title="variable">G1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y1:275"><span class="id" title="variable">y1</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a><br>
                      <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:272"><span class="id" title="variable">Z</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:278"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:280"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:276"><span class="id" title="variable">y2</span></a>)) (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G1:282"><span class="id" title="variable">G1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q:279"><span class="id" title="variable">q</span></a>)<br>
      <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="y:289" class="idref" href="#y:289"><span class="id" title="binder">y</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#G2:284"><span class="id" title="variable">G2</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#F:277"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:289"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:278"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:280"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:289"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G1:282"><span class="id" title="variable">G1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:289"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#q:279"><span class="id" title="variable">q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#u1:287"><span class="id" title="variable">u1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#u2:288"><span class="id" title="variable">u2</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(400, '0_3_91');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(401, '0_3_91');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">theta</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">q</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">u1</span> <span class="id" title="var">u2</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>, !<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>. </span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(402, '0_3_91');
      "><span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(403, '0_3_91');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">s</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span>; <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(404, '0_3_91');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_91');
      " onmouseover="
      mouseover(405, '0_3_91');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_91"><pre><span></span></pre></div>
<div class="doc" scenenumber="93">
The path case of the nested induction; corresponds to "omega" in the paper. 
</div>
<div scenenumber="95" class="code">
<span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(409, '0_3_95');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="G" class="idref" href="#G"><span class="id" title="definition">G</span></a> <a id="n:290" class="idref" href="#n:290"><span class="id" title="binder">n</span></a> <a id="a:291" class="idref" href="#a:291"><span class="id" title="binder">a</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="y:292" class="idref" href="#y:292"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
    <a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:290"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:291"><span class="id" title="variable">a</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:290"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:291"><span class="id" title="variable">a</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#y:292"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:290"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#a:291"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#y:292"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(410, '0_3_95');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(411, '0_3_95');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(412, '0_3_95');
      "><br>
    - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="k:295" class="idref" href="#k:295"><span class="id" title="binder">k</span></a> <a id="b:296" class="idref" href="#b:296"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(413, '0_3_95');
      "><br>
    - <span class="id" title="tactic">intros</span> <span class="id" title="var">k</span> <span class="id" title="var">l</span> <span class="id" title="var">p</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(414, '0_3_95');
      "><br>
      <span class="id" title="var">snrapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Phi"><span class="id" title="definition">Phi</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.A"><span class="id" title="variable">A</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>) (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq_beta_glue"><span class="id" title="definition">colim_succ_seq_to_colim_seq_beta_glue</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(415, '0_3_95');
      "><br>
      <span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_ind_beta_colimp"><span class="id" title="definition">Colimit_ind_beta_colimp</span></a> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <a id="k:299" class="idref" href="#k:299"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:297"><span class="id" title="variable">k</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(416, '0_3_95');
      "><br>
      <span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_ind_beta_colimp"><span class="id" title="definition">Colimit_ind_beta_colimp</span></a> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <a id="k:302" class="idref" href="#k:302"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:300"><span class="id" title="variable">k</span></a> <span class="id" title="var">n</span><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> <span class="id" title="var">a</span><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(417, '0_3_95');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(418, '0_3_95');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(419, '0_3_95');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="I" class="idref" href="#I"><span class="id" title="definition">I</span></a> {<a id="X:303" class="idref" href="#X:303"><span class="id" title="binder">X</span></a> <a id="Y:304" class="idref" href="#Y:304"><span class="id" title="binder">Y</span></a> <a id="Z:305" class="idref" href="#Z:305"><span class="id" title="binder">Z</span></a>} {<a id="x1:306" class="idref" href="#x1:306"><span class="id" title="binder">x1</span></a> <a id="x2:307" class="idref" href="#x2:307"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:303"><span class="id" title="variable">X</span></a>} {<a id="p:308" class="idref" href="#p:308"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:306"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:307"><span class="id" title="variable">x2</span></a>} {<a id="F:309" class="idref" href="#F:309"><span class="id" title="binder">F</span></a>} (<a id="psi:310" class="idref" href="#psi:310"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:304"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:308"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:309"><span class="id" title="variable">F</span></a>) {<a id="G1:311" class="idref" href="#G1:311"><span class="id" title="binder">G1</span></a> <a id="G2:312" class="idref" href="#G2:312"><span class="id" title="binder">G2</span></a>}<br>
    : <a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<span class="id" title="keyword">fun</span> <a id="x:313" class="idref" href="#x:313"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="y:314" class="idref" href="#y:314"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:305"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:313"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:314"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:308"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G1:311"><span class="id" title="variable">G1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G2:312"><span class="id" title="variable">G2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a><br>
      <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="y:315" class="idref" href="#y:315"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G2:312"><span class="id" title="variable">G2</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#F:309"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:315"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:308"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:310"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:315"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2b82354f12c687608f5c1ade3e7ee37d"><span class="id" title="notation">#</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G1:311"><span class="id" title="variable">G1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:315"><span class="id" title="variable">y</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(420, '0_3_95');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(421, '0_3_95');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">psi</span>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(422, '0_3_95');
      "><br>
    <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> (<a class="idref" href="HoTT.Types.Paths.html#equiv_path_inverse"><span class="id" title="definition">equiv_path_inverse</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Types.Forall.html#equiv_apD10"><span class="id" title="definition">equiv_apD10</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(423, '0_3_95');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_95');
      " onmouseover="
      mouseover(424, '0_3_95');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_95"><pre><span></span></pre></div>
<div class="doc" scenenumber="97">
The alternative induction rule in curried form; corresponds to curried "G" in
      the paper. 
</div>
<div scenenumber="99" class="code">
<span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(428, '0_3_99');
      ">
  <span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_ind_cur" class="idref" href="#seq_colim_sum_ind_cur"><span class="id" title="definition">seq_colim_sum_ind_cur</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:316" class="idref" href="#x:316"><span class="id" title="binder">x</span></a> <a id="y:317" class="idref" href="#y:317"><span class="id" title="binder">y</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:316"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:317"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(429, '0_3_99');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(430, '0_3_99');
      "><br>
    <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#F"><span class="id" title="definition">F</span></a>); <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(431, '0_3_99');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#I"><span class="id" title="definition">I</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>)<a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">)^-1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#f3f2d22838b594a6e5dbfb541ecf90ae"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(432, '0_3_99');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_99');
      " onmouseover="
      mouseover(433, '0_3_99');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_99"><pre><span></span></pre></div>
<div class="doc" scenenumber="101">
The computation rule for the alternative induction rule in curried form. 
</div>
<div scenenumber="103" class="code">
<span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(437, '0_3_103');
      ">
  <span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_ind_cur_beta_glue" class="idref" href="#seq_colim_sum_ind_cur_beta_glue"><span class="id" title="definition">seq_colim_sum_ind_cur_beta_glue</span></a> <a id="n:318" class="idref" href="#n:318"><span class="id" title="binder">n</span></a> <a id="a:319" class="idref" href="#a:319"><span class="id" title="binder">a</span></a> :<br>
    <a class="idref" href="HoTT.Colimits.Sequential.html#I"><span class="id" title="definition">I</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:318"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:319"><span class="id" title="variable">a</span></a>) (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind_cur"><span class="id" title="definition">seq_colim_sum_ind_cur</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:318"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:319"><span class="id" title="variable">a</span></a>)) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G"><span class="id" title="definition">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:318"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:319"><span class="id" title="variable">a</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(438, '0_3_103');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(439, '0_3_103');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#moveR_equiv_M"><span class="id" title="definition">moveR_equiv_M</span></a>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_ind_beta_colimp"><span class="id" title="definition">Colimit_ind_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(440, '0_3_103');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_103');
      " onmouseover="
      mouseover(441, '0_3_103');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_103"><pre><span></span></pre></div>
<div class="doc" scenenumber="105">
The alternative induction rule; corresponds to "G" in the paper. 
</div>
<div scenenumber="107" class="code">
<span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(445, '0_3_107');
      ">
  <span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_ind" class="idref" href="#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:320" class="idref" href="#x:320"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.E"><span class="id" title="variable">E</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:320"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(446, '0_3_107');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(447, '0_3_107');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">x</span> <span class="id" title="var">y</span>]; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind_cur"><span class="id" title="definition">seq_colim_sum_ind_cur</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(448, '0_3_107');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(449, '0_3_107');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Xi" class="idref" href="#Xi"><span class="id" title="definition">Xi</span></a> {<a id="X:321" class="idref" href="#X:321"><span class="id" title="binder">X</span></a> <a id="Y:322" class="idref" href="#Y:322"><span class="id" title="binder">Y</span></a> <a id="Z:323" class="idref" href="#Z:323"><span class="id" title="binder">Z</span></a>} <a id="G:324" class="idref" href="#G:324"><span class="id" title="binder">G</span></a> {<a id="x:325" class="idref" href="#x:325"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:321"><span class="id" title="variable">X</span></a>} {<a id="y1:326" class="idref" href="#y1:326"><span class="id" title="binder">y1</span></a> <a id="y2:327" class="idref" href="#y2:327"><span class="id" title="binder">y2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#Y:322"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:325"><span class="id" title="variable">x</span></a>} {<a id="z:328" class="idref" href="#z:328"><span class="id" title="binder">z</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:322"><span class="id" title="variable">Y</span></a>} {<a id="p:329" class="idref" href="#p:329"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#y1:326"><span class="id" title="variable">y1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y2:327"><span class="id" title="variable">y2</span></a>}<br>
    {<a id="q1:330" class="idref" href="#q1:330"><span class="id" title="binder">q1</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#z:328"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:325"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y1:326"><span class="id" title="variable">y1</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>} {<a id="q2:331" class="idref" href="#q2:331"><span class="id" title="binder">q2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#z:328"><span class="id" title="variable">z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:325"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y2:327"><span class="id" title="variable">y2</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>} (<a id="theta:332" class="idref" href="#theta:332"><span class="id" title="binder">theta</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#q2:331"><span class="id" title="variable">q2</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q1:330"><span class="id" title="variable">q1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#p:329"><span class="id" title="variable">p</span></a>)<br>
    : <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#G:324"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#exist"><span class="id" title="constructor">exist</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:322"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:325"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:329"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#transport"><span class="id" title="definition">transport</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Z:323"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#exist"><span class="id" title="constructor">exist</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:322"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:325"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:329"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:324"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q1:330"><span class="id" title="variable">q1</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Eta"><span class="id" title="definition">Eta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#theta:332"><span class="id" title="variable">theta</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#G:324"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#z:328"><span class="id" title="variable">z</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:324"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q2:331"><span class="id" title="variable">q2</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(450, '0_3_107');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(451, '0_3_107');
      "><br>
    <span class="id" title="var">revert</span> <span class="id" title="var">theta</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ind"><span class="id" title="definition">equiv_ind</span></a> (<a class="idref" href="HoTT.Types.Paths.html#equiv_path_inverse"><span class="id" title="definition">equiv_path_inverse</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)). </span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(452, '0_3_107');
      "><span class="id" title="tactic">intro</span> <span class="id" title="var">s</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(453, '0_3_107');
      "><br>
    <span class="id" title="var">revert</span> <span class="id" title="var">q1</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ind"><span class="id" title="definition">equiv_ind</span></a> (<a class="idref" href="HoTT.Types.Paths.html#equiv_path_inverse"><span class="id" title="definition">equiv_path_inverse</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)); <span class="id" title="tactic">intro</span> <span class="id" title="var">s</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(454, '0_3_107');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(455, '0_3_107');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(456, '0_3_107');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Mu" class="idref" href="#Mu"><span class="id" title="definition">Mu</span></a> {<a id="X:333" class="idref" href="#X:333"><span class="id" title="binder">X</span></a> <a id="Y:334" class="idref" href="#Y:334"><span class="id" title="binder">Y</span></a> <a id="Z:335" class="idref" href="#Z:335"><span class="id" title="binder">Z</span></a>} {<a id="x1:336" class="idref" href="#x1:336"><span class="id" title="binder">x1</span></a> <a id="x2:337" class="idref" href="#x2:337"><span class="id" title="binder">x2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#X:333"><span class="id" title="variable">X</span></a>} (<a id="p:338" class="idref" href="#p:338"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#x1:336"><span class="id" title="variable">x1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x2:337"><span class="id" title="variable">x2</span></a>) {<a id="F:339" class="idref" href="#F:339"><span class="id" title="binder">F</span></a>} (<a id="G:341" class="idref" href="#G:341"><span class="id" title="binder">G</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="z:340" class="idref" href="#z:340"><span class="id" title="binder">z</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Z:335"><span class="id" title="variable">Z</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#z:340"><span class="id" title="variable">z</span></a>)<br>
    {<a id="psi:342" class="idref" href="#psi:342"><span class="id" title="binder">psi</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#Y:334"><span class="id" title="variable">Y</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:338"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#F:339"><span class="id" title="variable">F</span></a>} {<a id="q:343" class="idref" href="#q:343"><span class="id" title="binder">q</span></a>} (<a id="theta:346" class="idref" href="#theta:346"><span class="id" title="binder">theta</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#I"><span class="id" title="definition">I</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:342"><span class="id" title="variable">psi</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> (<span class="id" title="keyword">fun</span> <a id="x:344" class="idref" href="#x:344"><span class="id" title="binder">x</span></a> <a id="y:345" class="idref" href="#y:345"><span class="id" title="binder">y</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#G:341"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:344"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#y:345"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:338"><span class="id" title="variable">p</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#q:343"><span class="id" title="variable">q</span></a>) <a id="y:347" class="idref" href="#y:347"><span class="id" title="binder">y</span></a><br>
    : <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:341"><span class="id" title="variable">G</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta"><span class="id" title="definition">Delta</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#p:338"><span class="id" title="variable">p</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#psi:342"><span class="id" title="variable">psi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:347"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#q:343"><span class="id" title="variable">q</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#y:347"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(457, '0_3_107');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(458, '0_3_107');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">psi</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">theta</span>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(459, '0_3_107');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_107');
      " onmouseover="
      mouseover(460, '0_3_107');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_107"><pre><span></span></pre></div>
<div class="doc" scenenumber="109">
The computation rule for the alternative induction rule. 
</div>
<div scenenumber="111" class="code">
<span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(464, '0_3_111');
      ">
  <span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_ind_beta_glue" class="idref" href="#seq_colim_sum_ind_beta_glue"><span class="id" title="definition">seq_colim_sum_ind_beta_glue</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:348" class="idref" href="#n:348"><span class="id" title="binder">n</span></a> <a id="a:349" class="idref" href="#a:349"><span class="id" title="binder">a</span></a> <a id="b:350" class="idref" href="#b:350"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:348"><span class="id" title="variable">n</span></a> <span class="id" title="var">_</span>)) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
    <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.t"><span class="id" title="variable">t</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:348"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:349"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:350"><span class="id" title="variable">b</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(465, '0_3_111');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(466, '0_3_111');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">pose</span> (<span class="id" title="var">h</span> := <a class="idref" href="HoTT.Colimits.Sequential.html#F_beta_glue"><span class="id" title="definition">F_beta_glue</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(467, '0_3_111');
      "><br>
    <span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Xi"><span class="id" title="definition">Xi</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim_beta_glue"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim_beta_glue</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(468, '0_3_111');
      "><br>
    <span class="id" title="tactic">rewrite</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#Mu"><span class="id" title="definition">Mu</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind_cur_beta_glue"><span class="id" title="definition">seq_colim_sum_ind_cur_beta_glue</span></a> <span class="id" title="var">n</span> <span class="id" title="var">a</span>)) <span class="id" title="tactic">in</span> <span class="id" title="var">h</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(469, '0_3_111');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">h</span>; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#cancelL"><span class="id" title="definition">cancelL</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">h</span>).</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(470, '0_3_111');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(471, '0_3_111');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumInd"><span class="id" title="section">SeqColimitSumInd</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_111');
      " onmouseover="
      mouseover(472, '0_3_111');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_111"><pre><span></span></pre></div>
<div class="doc" scenenumber="113">
An alternative recursion principle for the sum of colimits; Lemma 5.3. 
</div>
<div scenenumber="115" class="code">
<span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(476, '0_3_115');
      ">
<span class="id" title="keyword">Section</span> <a id="SeqColimitSumRec" class="idref" href="#SeqColimitSumRec"><span class="id" title="section">SeqColimitSumRec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(477, '0_3_115');
      "><br>
<br>
  <span class="id" title="keyword">Context</span> `{<a id="H:351" class="idref" href="#H:351"><span class="id" title="binder">Univalence</span></a>} {<a id="A:352" class="idref" href="#A:352"><span class="id" title="binder">A</span></a>} (<a id="B:353" class="idref" href="#B:353"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:352"><span class="id" title="variable">A</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(478, '0_3_115');
      "><br>
  <span class="id" title="keyword">Context</span> <a id="E:354" class="idref" href="#E:354"><span class="id" title="binder">E</span></a> (<a id="e:357" class="idref" href="#e:357"><span class="id" title="binder">e</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:355" class="idref" href="#n:355"><span class="id" title="binder">n</span></a> <a id="a:356" class="idref" href="#a:356"><span class="id" title="binder">a</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:355"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:356"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#E:354"><span class="id" title="variable">E</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(479, '0_3_115');
      "><br>
  <span class="id" title="keyword">Context</span> (<a id="t:361" class="idref" href="#t:361"><span class="id" title="binder">t</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:358" class="idref" href="#n:358"><span class="id" title="binder">n</span></a> <a id="a:359" class="idref" href="#a:359"><span class="id" title="binder">a</span></a> (<a id="b:360" class="idref" href="#b:360"><span class="id" title="binder">b</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#n:358"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:359"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:358"><span class="id" title="variable">n</span></a><a class="idref" href="HoTT.Basics.Nat.html#bda89d73ec4a8f23ae92b565ffb5aaa6"><span class="id" title="notation">.+1</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#a:359"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#b:360"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#be7681fc4f0bf4f2eee9cf7f11f6ac16"><span class="id" title="notation">f</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.e"><span class="id" title="variable">e</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:358"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:359"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:360"><span class="id" title="variable">b</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(480, '0_3_115');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_rec" class="idref" href="#seq_colim_sum_rec"><span class="id" title="definition">seq_colim_sum_rec</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a>)<a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.E"><span class="id" title="variable">E</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(481, '0_3_115');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(482, '0_3_115');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.e"><span class="id" title="variable">e</span></a> (<span class="id" title="keyword">fun</span> <a id="n:365" class="idref" href="#n:365"><span class="id" title="binder">n</span></a> <a id="a:366" class="idref" href="#a:366"><span class="id" title="binder">a</span></a> <a id="b:367" class="idref" href="#b:367"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_const"><span class="id" title="definition">transport_const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.t"><span class="id" title="variable">t</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:362"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:363"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:364"><span class="id" title="variable">b</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(483, '0_3_115');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(484, '0_3_115');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_rec_beta_glue" class="idref" href="#seq_colim_sum_rec_beta_glue"><span class="id" title="definition">seq_colim_sum_rec_beta_glue</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:368" class="idref" href="#n:368"><span class="id" title="binder">n</span></a> <a id="a:369" class="idref" href="#a:369"><span class="id" title="binder">a</span></a> <a id="b:370" class="idref" href="#b:370"><span class="id" title="binder">b</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a><br>
    <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_rec"><span class="id" title="definition">seq_colim_sum_rec</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a>) (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.B"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:368"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:369"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:370"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a><br>
    <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec.t"><span class="id" title="variable">t</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:368"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a:369"><span class="id" title="variable">a</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#b:370"><span class="id" title="variable">b</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(485, '0_3_115');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(486, '0_3_115');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#cancelL"><span class="id" title="definition">cancelL</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#apD_const"><span class="id" title="lemma">apD_const</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(487, '0_3_115');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind_beta_glue"><span class="id" title="definition">seq_colim_sum_ind_beta_glue</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(488, '0_3_115');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(489, '0_3_115');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Colimits.Sequential.html#SeqColimitSumRec"><span class="id" title="section">SeqColimitSumRec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_115');
      " onmouseover="
      mouseover(490, '0_3_115');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_115"><pre><span></span></pre></div>
<div class="doc" scenenumber="117">
Lemma 5.4. 
</div>
<div scenenumber="119" class="code">
<span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(494, '0_3_119');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colimit_sum_uniq" class="idref" href="#seq_colimit_sum_uniq"><span class="id" title="definition">seq_colimit_sum_uniq</span></a> `{<a id="H:371" class="idref" href="#H:371"><span class="id" title="binder">Univalence</span></a>} {<a id="A:372" class="idref" href="#A:372"><span class="id" title="binder">A</span></a>} (<a id="B:373" class="idref" href="#B:373"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:372"><span class="id" title="variable">A</span></a>) <a id="E:374" class="idref" href="#E:374"><span class="id" title="binder">E</span></a><br>
  (<a id="F:375" class="idref" href="#F:375"><span class="id" title="binder">F</span></a> <a id="G:376" class="idref" href="#G:376"><span class="id" title="binder">G</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:373"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#E:374"><span class="id" title="variable">E</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Sequential.html#F:375"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:373"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:376"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:373"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br>
    <a class="idref" href="HoTT.Colimits.Sequential.html#F:375"><span class="id" title="variable">F</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:376"><span class="id" title="variable">G</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(495, '0_3_119');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(496, '0_3_119');
      "><br>
  <span class="id" title="tactic">intro</span> <span class="id" title="var">h</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_ind"><span class="id" title="definition">seq_colim_sum_ind</span></a> <span class="id" title="var">B</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">h</span> <span class="id" title="var">_</span>)); <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(497, '0_3_119');
      "><br>
  <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#transport_compose"><span class="id" title="lemma">transport_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>); <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Overture.html#apD"><span class="id" title="definition">apD</span></a> <span class="id" title="var">h</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <span class="id" title="var">B</span>) <span class="id" title="var">n</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">a</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">b</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(498, '0_3_119');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_119');
      " onmouseover="
      mouseover(499, '0_3_119');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_119"><pre><span></span></pre></div>
<div class="doc" scenenumber="121">
The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits is an equivalence; Theorem 5.1. 
</div>
<div scenenumber="123" class="code">
<span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(503, '0_3_123');
      ">
<span class="id" title="keyword">Global Instance</span> <a id="isequiv_seq_colim_sum_to_sum_seq_colim" class="idref" href="#isequiv_seq_colim_sum_to_sum_seq_colim"><span class="id" title="instance">isequiv_seq_colim_sum_to_sum_seq_colim</span></a> `{<a id="H:377" class="idref" href="#H:377"><span class="id" title="binder">Univalence</span></a>} {<a id="A:378" class="idref" href="#A:378"><span class="id" title="binder">A</span></a>} (<a id="B:379" class="idref" href="#B:379"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:378"><span class="id" title="variable">A</span></a>)<br>
  : <a class="idref" href="HoTT.Basics.Overture.html#IsEquiv"><span class="id" title="class">IsEquiv</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:379"><span class="id" title="variable">B</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(504, '0_3_123');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(505, '0_3_123');
      "><br>
  <span class="id" title="tactic">assert</span> (<span class="id" title="var">L</span> : <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="G:381" class="idref" href="#G:381"><span class="id" title="binder">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#G:380"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Basics.Overture.html#idmap"><span class="id" title="abbreviation">idmap</span></a><a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(506, '0_3_123');
      "><br>
  - <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(507, '0_3_123');
      "><br>
    + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_rec"><span class="id" title="definition">seq_colim_sum_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(508, '0_3_123');
      "><br>
      × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:385" class="idref" href="#n:385"><span class="id" title="binder">n</span></a> <a id="a:386" class="idref" href="#a:386"><span class="id" title="binder">a</span></a> <a id="b:387" class="idref" href="#b:387"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <span class="id" title="var">B</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:382"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:383"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:384"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(509, '0_3_123');
      "><br>
      × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:391" class="idref" href="#n:391"><span class="id" title="binder">n</span></a> <a id="a:392" class="idref" href="#a:392"><span class="id" title="binder">a</span></a> <a id="b:393" class="idref" href="#b:393"><span class="id" title="binder">b</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <span class="id" title="var">B</span>) <a class="idref" href="HoTT.Colimits.Sequential.html#n:388"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#a:389"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#b:390"><span class="id" title="variable">b</span></a><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(510, '0_3_123');
      "><br>
    + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(511, '0_3_123');
      "><br>
      × <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:396" class="idref" href="#n:396"><span class="id" title="binder">n</span></a> <a id="a:397" class="idref" href="#a:397"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(512, '0_3_123');
      "><br>
      × <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_idmap"><span class="id" title="definition">ap_idmap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(513, '0_3_123');
      "><br>
        <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_rec_beta_glue"><span class="id" title="definition">seq_colim_sum_rec_beta_glue</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(514, '0_3_123');
      "><br>
  - <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#isequiv_adjointify"><span class="id" title="definition">isequiv_adjointify</span></a> <span class="id" title="var">_</span> <span class="id" title="var">L</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a> <span class="id" title="var">_</span> <span class="id" title="var">L</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a>); <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_sum_uniq"><span class="id" title="definition">seq_colimit_sum_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(515, '0_3_123');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">L</span><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(516, '0_3_123');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(517, '0_3_123');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_seq_colim_sum_to_sum_seq_colim" class="idref" href="#equiv_seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">equiv_seq_colim_sum_to_sum_seq_colim</span></a> `{<a id="H:398" class="idref" href="#H:398"><span class="id" title="binder">Univalence</span></a>} {<a id="A:399" class="idref" href="#A:399"><span class="id" title="binder">A</span></a>} (<a id="B:400" class="idref" href="#B:400"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:399"><span class="id" title="variable">A</span></a>)<br>
  : <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#sig_seq"><span class="id" title="definition">sig_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:400"><span class="id" title="variable">B</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#sig"><span class="id" title="record">sig</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:400"><span class="id" title="variable">B</span></a>)<br>
  := <a class="idref" href="HoTT.Basics.Overture.html#Build_Equiv"><span class="id" title="constructor">Build_Equiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#isequiv_seq_colim_sum_to_sum_seq_colim"><span class="id" title="instance">isequiv_seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:400"><span class="id" title="variable">B</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_123');
      " onmouseover="
      mouseover(518, '0_3_123');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_123"><pre><span></span></pre></div>
<div class="doc" scenenumber="125">
The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits commutes with the first projection; Theorem 5.1. 
</div>
<div scenenumber="127" class="code">
<span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(522, '0_3_127');
      ">
<span class="id" title="keyword">Definition</span> <a id="seq_colim_sum_to_sum_seq_colim_fst" class="idref" href="#seq_colim_sum_to_sum_seq_colim_fst"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim_fst</span></a> `{<a id="H:401" class="idref" href="#H:401"><span class="id" title="binder">Univalence</span></a>} {<a id="A:402" class="idref" href="#A:402"><span class="id" title="binder">A</span></a>} (<a id="B:403" class="idref" href="#B:403"><span class="id" title="binder">B</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#FibSequence"><span class="id" title="record">FibSequence</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:402"><span class="id" title="variable">A</span></a>)<br>
  : <a class="idref" href="HoTT.Basics.Overture.html#pr1"><span class="id" title="abbreviation">pr1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:403"><span class="id" title="variable">B</span></a><a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_seq_colim_fst"><span class="id" title="definition">seq_colim_sum_to_seq_colim_fst</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#B:403"><span class="id" title="variable">B</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(523, '0_3_127');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(524, '0_3_127');
      "><br>
  <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#seq_colimit_uniq"><span class="id" title="definition">seq_colimit_uniq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(525, '0_3_127');
      "><br>
  - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:406" class="idref" href="#n:406"><span class="id" title="binder">n</span></a> <a id="a:407" class="idref" href="#a:407"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(526, '0_3_127');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> [<span class="id" title="var">a</span> <span class="id" title="var">b</span>]; <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_1p"><span class="id" title="definition">concat_1p</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a>, <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a>, !<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_rec_beta_colimp"><span class="id" title="definition">Colimit_rec_beta_colimp</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(527, '0_3_127');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_pp"><span class="id" title="definition">ap_pp</span></a>, (<a class="idref" href="HoTT.Colimits.Sequential.html#Delta_proj"><span class="id" title="definition">Delta_proj</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam_beta_glue"><span class="id" title="definition">fib_seq_to_type_fam_beta_glue</span></a> <span class="id" title="var">B</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(528, '0_3_127');
      "><br>
    <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.PathGroupoids.html#whiskerL"><span class="id" title="definition">whiskerL</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.PathGroupoids.html#concat_p1"><span class="id" title="definition">concat_p1</span></a> <span class="id" title="var">_</span>); <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_compose"><span class="id" title="definition">ap_compose</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(529, '0_3_127');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Basics.PathGroupoids.html#ap_const"><span class="id" title="definition">ap_const</span></a>; <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(530, '0_3_127');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_127');
      " onmouseover="
      mouseover(531, '0_3_127');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_127"><pre><span></span></pre></div>
<div class="doc" scenenumber="129">
The characterization of path spaces in sequential colimits; Theorem 7.4, first part. 
</div>
<div scenenumber="131" class="code">
<span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(535, '0_3_131');
      ">
<span class="id" title="keyword">Definition</span> <a id="path_seq" class="idref" href="#path_seq"><span class="id" title="definition">path_seq</span></a> (<a id="A:408" class="idref" href="#A:408"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>) (<a id="a1:409" class="idref" href="#a1:409"><span class="id" title="binder">a1</span></a> <a id="a2:410" class="idref" href="#a2:410"><span class="id" title="binder">a2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:408"><span class="id" title="variable">A</span></a> 0)<br>
  := <a class="idref" href="HoTT.Diagrams.Sequence.html#Build_Sequence"><span class="id" title="definition">Build_Sequence</span></a> (<span class="id" title="keyword">fun</span> <a id="k:411" class="idref" href="#k:411"><span class="id" title="binder">k</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#a1:409"><span class="id" title="variable">a1</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:411"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:410"><span class="id" title="variable">a2</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">^+</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#k:411"><span class="id" title="variable">k</span></a>) (<span class="id" title="keyword">fun</span> <a id="k:412" class="idref" href="#k:412"><span class="id" title="binder">k</span></a> <a id="p:413" class="idref" href="#p:413"><span class="id" title="binder">p</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="a:414" class="idref" href="#a:414"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#a:414"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#p:413"><span class="id" title="variable">p</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(536, '0_3_131');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_path_colim_zero" class="idref" href="#equiv_path_colim_zero"><span class="id" title="definition">equiv_path_colim_zero</span></a> `{<a id="H:415" class="idref" href="#H:415"><span class="id" title="binder">Univalence</span></a>} {<a id="A:416" class="idref" href="#A:416"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} (<a id="a1:417" class="idref" href="#a1:417"><span class="id" title="binder">a1</span></a> <a id="a2:418" class="idref" href="#a2:418"><span class="id" title="binder">a2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:416"><span class="id" title="variable">A</span></a> 0) :<br>
  <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:416"><span class="id" title="variable">A</span></a> 0 <a class="idref" href="HoTT.Colimits.Sequential.html#a1:417"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:416"><span class="id" title="variable">A</span></a> 0 <a class="idref" href="HoTT.Colimits.Sequential.html#a2:418"><span class="id" title="variable">a2</span></a><a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#path_seq"><span class="id" title="definition">path_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:416"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a1:417"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:418"><span class="id" title="variable">a2</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(537, '0_3_131');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(538, '0_3_131');
      "><br>
  <span class="id" title="tactic">pose</span> (<span class="id" title="var">B</span> := <a class="idref" href="HoTT.Colimits.Sequential.html#Build_FibSequence"><span class="id" title="constructor">Build_FibSequence</span></a> <span class="id" title="var">A</span> (<span class="id" title="keyword">fun</span> <a id="x:422" class="idref" href="#x:422"><span class="id" title="binder">x</span></a> ⇒ <span class="id" title="var">a1</span><a class="idref" href="HoTT.Colimits.Sequential.html#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">^+(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#x:419"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.1'"><span class="id" title="notation">.1</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#89dcb9d9e23f2b78dc8a1b1571e3a602"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#x:419"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Basics.Overture.html#::fibration_scope:x_'.2'"><span class="id" title="notation">.2</span></a>) (<span class="id" title="keyword">fun</span> <a id="x:423" class="idref" href="#x:423"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="a:424" class="idref" href="#a:424"><span class="id" title="binder">a</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#a:421"><span class="id" title="variable">a</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#08eb96ff0845089548bf8ee31b997ae3"><span class="id" title="notation">^+</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(539, '0_3_131');
      "><br>
  <span class="id" title="tactic">transitivity</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_type_fam"><span class="id" title="definition">fib_seq_to_type_fam</span></a> <span class="id" title="var">B</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <span class="id" title="var">A</span> 0 <span class="id" title="var">a2</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(540, '0_3_131');
      "><br>
  + <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.PathAny.html#equiv_path_from_contr"><span class="id" title="definition">equiv_path_from_contr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(541, '0_3_131');
      "><br>
    - <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#fib_seq_to_seq"><span class="id" title="definition">fib_seq_to_seq</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a>0<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">a1</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) 0 <a class="idref" href="HoTT.Basics.Overture.html#idpath"><span class="id" title="constructor">idpath</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(542, '0_3_131');
      "><br>
    - <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#contr_equiv"><span class="id" title="lemma">contr_equiv</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_colim_sum_to_sum_seq_colim"><span class="id" title="definition">seq_colim_sum_to_sum_seq_colim</span></a> <span class="id" title="var">B</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(543, '0_3_131');
      "><br>
      <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#contr_colim_contr_seq"><span class="id" title="definition">contr_colim_contr_seq</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">k</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Contractible.html#contr_basedpaths"><span class="id" title="instance">contr_basedpaths</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(544, '0_3_131');
      "><br>
  + <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#equiv_functor_colimit"><span class="id" title="definition">equiv_functor_colimit</span></a>; <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#equiv_fib_seq_to_seq"><span class="id" title="definition">equiv_fib_seq_to_seq</span></a> <span class="id" title="var">B</span> <a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">(</span></a>0<a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">;</span></a><span class="id" title="var">a2</span><a class="idref" href="HoTT.Basics.Overture.html#4887cec9c4a6ccb88dc6b18963c35c8f"><span class="id" title="notation">)</span></a>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(545, '0_3_131');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_diagram_equiv"><span class="id" title="constructor">Build_diagram_equiv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(546, '0_3_131');
      "><br>
    × <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Diagrams.Diagram.html#Build_DiagramMap"><span class="id" title="constructor">Build_DiagramMap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(547, '0_3_131');
      "><br>
      - <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <a id="n:426" class="idref" href="#n:426"><span class="id" title="binder">n</span></a> ⇒ <a class="idref" href="HoTT.Colimits.Sequential.html#coe"><span class="id" title="abbreviation">coe</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">B</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_shift_pair_from_zero"><span class="id" title="definition">seq_shift_pair_from_zero</span></a> <span class="id" title="var">a2</span> <a class="idref" href="HoTT.Colimits.Sequential.html#n:425"><span class="id" title="variable">n</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(548, '0_3_131');
      "><br>
      - <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#K"><span class="id" title="definition">K</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#seq_shift_pair_from_zero"><span class="id" title="definition">seq_shift_pair_from_zero</span></a> <span class="id" title="var">a2</span> <span class="id" title="var">n</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(549, '0_3_131');
      "><br>
    × <span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Types.Universe.html#isequiv_path"><span class="id" title="instance">isequiv_path</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(550, '0_3_131');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_131');
      " onmouseover="
      mouseover(551, '0_3_131');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_131"><pre><span></span></pre></div>
<div class="doc" scenenumber="133">
The characterization of path spaces in sequential colimits; Theorem 7.4, second part. 
</div>
<div scenenumber="135" class="code">
<span class="command" onmouseout="
      mouseout('0_3_135');
      " onmouseover="
      mouseover(555, '0_3_135');
      ">
<span class="id" title="keyword">Definition</span> <a id="equiv_path_colim" class="idref" href="#equiv_path_colim"><span class="id" title="definition">equiv_path_colim</span></a> `{<a id="H:427" class="idref" href="#H:427"><span class="id" title="binder">Univalence</span></a>} {<a id="A:428" class="idref" href="#A:428"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} <a id="n:429" class="idref" href="#n:429"><span class="id" title="binder">n</span></a> (<a id="a1:430" class="idref" href="#a1:430"><span class="id" title="binder">a1</span></a> <a id="a2:431" class="idref" href="#a2:431"><span class="id" title="binder">a2</span></a> : <a class="idref" href="HoTT.Colimits.Sequential.html#A:428"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:429"><span class="id" title="variable">n</span></a>) :<br>
  <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:428"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:429"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a1:430"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#inj"><span class="id" title="abbreviation">inj</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:428"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:429"><span class="id" title="variable">n</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:431"><span class="id" title="variable">a2</span></a><a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#path_seq"><span class="id" title="definition">path_seq</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#shift_seq"><span class="id" title="definition">shift_seq</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:428"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:429"><span class="id" title="variable">n</span></a>) <a class="idref" href="HoTT.Colimits.Sequential.html#a1:430"><span class="id" title="variable">a1</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#a2:431"><span class="id" title="variable">a2</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_135');
      " onmouseover="
      mouseover(556, '0_3_135');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_135');
      " onmouseover="
      mouseover(557, '0_3_135');
      "><br>
  <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Overture.html#transitivity"><span class="id" title="definition">transitivity</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#equiv_path_colim_zero"><span class="id" title="definition">equiv_path_colim_zero</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)); <span class="id" title="tactic">symmetry</span>.</span><span class="command" onmouseout="
      mouseout('0_3_135');
      " onmouseover="
      mouseover(558, '0_3_135');
      "><br>
  <span class="id" title="var">srapply</span> (@<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ap"><span class="id" title="definition">equiv_ap</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_shift_seq_to_colim_seq"><span class="id" title="definition">colim_shift_seq_to_colim_seq</span></a> <span class="id" title="var">A</span> <span class="id" title="var">n</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_135');
      " onmouseover="
      mouseover(559, '0_3_135');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_135');
      " onmouseover="
      mouseover(560, '0_3_135');
      "><br>
<br>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">trunc_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_135');
      " onmouseover="
      mouseover(561, '0_3_135');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_135"><pre><span></span></pre></div>
<div class="doc" scenenumber="137">
Corollary 7.7.1, second part. 
</div>
<div scenenumber="139" class="code">
<span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(565, '0_3_139');
      ">
<span class="id" title="keyword">Global Instance</span> <a id="trunc_seq_colim" class="idref" href="#trunc_seq_colim"><span class="id" title="instance">trunc_seq_colim</span></a> `{<a id="H:432" class="idref" href="#H:432"><span class="id" title="binder">Univalence</span></a>} {<a id="A:433" class="idref" href="#A:433"><span class="id" title="binder">A</span></a> : <a class="idref" href="HoTT.Diagrams.Sequence.html#Sequence"><span class="id" title="definition">Sequence</span></a>} <a id="k:434" class="idref" href="#k:434"><span class="id" title="binder">k</span></a> :<br>
  <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="n:435" class="idref" href="#n:435"><span class="id" title="binder">n</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:434"><span class="id" title="variable">k</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#A:433"><span class="id" title="variable">A</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#n:435"><span class="id" title="variable">n</span></a>)<a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Basics.Overture.html#IsTrunc"><span class="id" title="class">IsTrunc</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#k:434"><span class="id" title="variable">k</span></a> (<a class="idref" href="HoTT.Colimits.Colimit.html#Colimit"><span class="id" title="definition">Colimit</span></a> <a class="idref" href="HoTT.Colimits.Sequential.html#A:433"><span class="id" title="variable">A</span></a>) | 100.</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(566, '0_3_139');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(567, '0_3_139');
      "><br>
  <span class="id" title="var">revert</span> <span class="id" title="var">A</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">k</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">k</span> <span class="id" title="var">IHk</span>].</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(568, '0_3_139');
      "><br>
  - <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Sequential.html#contr_colim_contr_seq"><span class="id" title="definition">contr_colim_contr_seq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(569, '0_3_139');
      "><br>
  - <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">trH</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(570, '0_3_139');
      "><br>
    + <span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="var">revert</span> <span class="id" title="var">trH</span>; <span class="id" title="var">revert</span> <span class="id" title="var">A</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n</span> <span class="id" title="var">IHn</span>].</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(571, '0_3_139');
      "><br>
      × <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">trH</span> <span class="id" title="var">a</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Colimits.Colimit.html#Colimit_ind"><span class="id" title="definition">Colimit_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(572, '0_3_139');
      "><br>
        { <span class="id" title="tactic">intros</span> <span class="id" title="var">m</span> <span class="id" title="var">b</span>; <span class="id" title="var">revert</span> <span class="id" title="var">b</span>; <span class="id" title="var">revert</span> <span class="id" title="var">a</span>; <span class="id" title="var">revert</span> <span class="id" title="var">trH</span>; <span class="id" title="var">revert</span> <span class="id" title="var">A</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">m</span> <span class="id" title="var">IHm</span>].</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(573, '0_3_139');
      "><br>
          { <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">trH</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(574, '0_3_139');
      "><br>
            <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Trunc.html#istrunc_equiv_istrunc"><span class="id" title="definition">istrunc_equiv_istrunc</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_inverse"><span class="id" title="lemma">equiv_inverse</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#equiv_path_colim"><span class="id" title="definition">equiv_path_colim</span></a> <span class="id" title="var">_</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>))). }</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(575, '0_3_139');
      "><br>
          { <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">trH</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(576, '0_3_139');
      "><br>
            <span class="id" title="var">srefine</span> (<a class="idref" href="HoTT.Basics.Trunc.html#istrunc_equiv_istrunc"><span class="id" title="definition">istrunc_equiv_istrunc</span></a> <span class="id" title="var">_</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_inverse"><span class="id" title="lemma">equiv_inverse</span></a> (<a class="idref" href="HoTT.Types.Paths.html#equiv_concat_l"><span class="id" title="definition">equiv_concat_l</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#glue"><span class="id" title="abbreviation">glue</span></a> <span class="id" title="var">A</span> <span class="id" title="var">_</span> <span class="id" title="var">a</span>) <span class="id" title="var">_</span>))).</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(577, '0_3_139');
      "><br>
            <span class="id" title="var">srapply</span> (@<a class="idref" href="HoTT.Basics.Trunc.html#istrunc_equiv_istrunc"><span class="id" title="definition">istrunc_equiv_istrunc</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">k</span> (<span class="id" title="var">IHm</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <span class="id" title="var">A</span>) <span class="id" title="var">_</span> (@<a class="idref" href="HoTT.Diagrams.Diagram.html#arr"><span class="id" title="projection">arr</span></a> <span class="id" title="var">_</span> <span class="id" title="var">A</span> 0%<span class="id" title="var">nat</span> <span class="id" title="var">_</span> 1%<span class="id" title="var">path</span> <span class="id" title="var">a</span>) <span class="id" title="var">b</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(578, '0_3_139');
      "><br>
            <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ap"><span class="id" title="definition">equiv_ap</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <span class="id" title="var">A</span>)). }}</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(579, '0_3_139');
      "><br>
        { <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">b</span>; <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>; <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Basics.Trunc.html#ishprop_istrunc"><span class="id" title="instance">ishprop_istrunc</span></a>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>. }<br>
      × <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">trH</span> <span class="id" title="var">a</span>; <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Types.Forall.html#functor_forall_equiv_pb"><span class="id" title="definition">functor_forall_equiv_pb</span></a> (<a class="idref" href="HoTT.Colimits.Sequential.html#colim_succ_seq_to_colim_seq"><span class="id" title="definition">colim_succ_seq_to_colim_seq</span></a> <span class="id" title="var">A</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(580, '0_3_139');
      "><br>
        <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="var">srapply</span> (@<a class="idref" href="HoTT.Basics.Trunc.html#istrunc_equiv_istrunc"><span class="id" title="definition">istrunc_equiv_istrunc</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">k</span> (<span class="id" title="var">IHn</span> (<a class="idref" href="HoTT.Colimits.Sequential.html#succ_seq"><span class="id" title="definition">succ_seq</span></a> <span class="id" title="var">A</span>) <span class="id" title="var">_</span> <span class="id" title="var">a</span> <span class="id" title="var">x</span>)); <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ap"><span class="id" title="definition">equiv_ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(581, '0_3_139');
      "><br>
    + <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span>; <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>; <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Types.Forall.html#istrunc_forall"><span class="id" title="instance">istrunc_forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(582, '0_3_139');
      "><br>
      <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Basics.Trunc.html#ishprop_istrunc"><span class="id" title="instance">ishprop_istrunc</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(583, '0_3_139');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_139');
      " onmouseover="
      mouseover(584, '0_3_139');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_139"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
