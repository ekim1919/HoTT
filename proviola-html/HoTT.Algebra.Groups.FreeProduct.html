<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="coqdoc.css" type="text/css" rel="stylesheet">
<link href="proviola.css" type="text/css" rel="stylesheet">
<script type="text/javascript">
        var responses = new Array();

        function mouseover(id, scene) {
          set_response(get_response(id), scene);
        };

        function mouseout(scene) {
          set_response("", scene);
        };

        function set_array() {
          

            i = 0;
            data = "";
            responses[i]=data;
          

            i = 1;
            data = "";
            responses[i]=data;
          

            i = 2;
            data = "";
            responses[i]=data;
          

            i = 3;
            data = "";
            responses[i]=data;
          

            i = 4;
            data = "";
            responses[i]=data;
          

            i = 5;
            data = "";
            responses[i]=data;
          

            i = 6;
            data = "<infomsg>[Loading ML file ltac_plugin.cmxs ... done]</infomsg>	<infomsg>[Loading ML file number_string_notation_plugin.cmxs ... done]	</infomsg>	";
            responses[i]=data;
          

            i = 7;
            data = "";
            responses[i]=data;
          

            i = 8;
            data = "";
            responses[i]=data;
          

            i = 9;
            data = "";
            responses[i]=data;
          

            i = 10;
            data = "";
            responses[i]=data;
          

            i = 11;
            data = "";
            responses[i]=data;
          

            i = 12;
            data = "";
            responses[i]=data;
          

            i = 13;
            data = "";
            responses[i]=data;
          

            i = 14;
            data = "";
            responses[i]=data;
          

            i = 15;
            data = "";
            responses[i]=data;
          

            i = 16;
            data = "";
            responses[i]=data;
          

            i = 17;
            data = "";
            responses[i]=data;
          

            i = 18;
            data = "";
            responses[i]=data;
          

            i = 19;
            data = "";
            responses[i]=data;
          

            i = 20;
            data = "";
            responses[i]=data;
          

            i = 21;
            data = "";
            responses[i]=data;
          

            i = 22;
            data = "";
            responses[i]=data;
          

            i = 23;
            data = "";
            responses[i]=data;
          

            i = 24;
            data = "";
            responses[i]=data;
          

            i = 25;
            data = "";
            responses[i]=data;
          

            i = 26;
            data = "";
            responses[i]=data;
          

            i = 27;
            data = "";
            responses[i]=data;
          

            i = 28;
            data = "";
            responses[i]=data;
          

            i = 29;
            data = "";
            responses[i]=data;
          

            i = 30;
            data = "";
            responses[i]=data;
          

            i = 31;
            data = "";
            responses[i]=data;
          

            i = 32;
            data = "";
            responses[i]=data;
          

            i = 33;
            data = "";
            responses[i]=data;
          

            i = 34;
            data = "";
            responses[i]=data;
          

            i = 35;
            data = "";
            responses[i]=data;
          

            i = 36;
            data = "";
            responses[i]=data;
          

            i = 37;
            data = "";
            responses[i]=data;
          

            i = 38;
            data = "";
            responses[i]=data;
          

            i = 39;
            data = "";
            responses[i]=data;
          

            i = 40;
            data = "";
            responses[i]=data;
          

            i = 41;
            data = "";
            responses[i]=data;
          

            i = 42;
            data = "";
            responses[i]=data;
          

            i = 43;
            data = "";
            responses[i]=data;
          

            i = 44;
            data = "";
            responses[i]=data;
          

            i = 45;
            data = "";
            responses[i]=data;
          

            i = 46;
            data = "";
            responses[i]=data;
          

            i = 47;
            data = "";
            responses[i]=data;
          

            i = 48;
            data = "";
            responses[i]=data;
          

            i = 49;
            data = "";
            responses[i]=data;
          

            i = 50;
            data = "";
            responses[i]=data;
          

            i = 51;
            data = "";
            responses[i]=data;
          

            i = 52;
            data = "";
            responses[i]=data;
          

            i = 53;
            data = "";
            responses[i]=data;
          

            i = 54;
            data = "";
            responses[i]=data;
          

            i = 55;
            data = "";
            responses[i]=data;
          

            i = 56;
            data = "";
            responses[i]=data;
          

            i = 57;
            data = "";
            responses[i]=data;
          

            i = 58;
            data = "";
            responses[i]=data;
          

            i = 59;
            data = "";
            responses[i]=data;
          

            i = 60;
            data = "";
            responses[i]=data;
          

            i = 61;
            data = "";
            responses[i]=data;
          

            i = 62;
            data = "";
            responses[i]=data;
          

            i = 63;
            data = "";
            responses[i]=data;
          

            i = 64;
            data = "";
            responses[i]=data;
          

            i = 65;
            data = "";
            responses[i]=data;
          

            i = 66;
            data = "";
            responses[i]=data;
          

            i = 67;
            data = "";
            responses[i]=data;
          

            i = 68;
            data = "";
            responses[i]=data;
          

            i = 69;
            data = "";
            responses[i]=data;
          

            i = 70;
            data = "";
            responses[i]=data;
          

            i = 71;
            data = "";
            responses[i]=data;
          

            i = 72;
            data = "";
            responses[i]=data;
          

            i = 73;
            data = "";
            responses[i]=data;
          

            i = 74;
            data = "";
            responses[i]=data;
          

            i = 75;
            data = "";
            responses[i]=data;
          

            i = 76;
            data = "";
            responses[i]=data;
          

            i = 77;
            data = "";
            responses[i]=data;
          

            i = 78;
            data = "";
            responses[i]=data;
          

            i = 79;
            data = "";
            responses[i]=data;
          

            i = 80;
            data = "";
            responses[i]=data;
          

            i = 81;
            data = "";
            responses[i]=data;
          

            i = 82;
            data = "";
            responses[i]=data;
          

            i = 83;
            data = "";
            responses[i]=data;
          

            i = 84;
            data = "<infomsg>G is declared</infomsg>	<infomsg>H is declared</infomsg>	<infomsg>K is declared</infomsg>	<infomsg>f is declared</infomsg>	<infomsg>g is declared</infomsg>	";
            responses[i]=data;
          

            i = 85;
            data = "<infomsg>Words is defined</infomsg>	";
            responses[i]=data;
          

            i = 86;
            data = "";
            responses[i]=data;
          

            i = 87;
            data = "1 goal (ID 42)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  x ++ nil = x	";
            responses[i]=data;
          

            i = 88;
            data = "";
            responses[i]=data;
          

            i = 89;
            data = "1 goal (ID 50)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  a : H + K	  x : list (H + K)	  IHx : x ++ nil = x	  ============================	  (a :: x) ++ nil = a :: x	";
            responses[i]=data;
          

            i = 90;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 91;
            data = "";
            responses[i]=data;
          

            i = 92;
            data = "1 goal (ID 52)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y, z : Words	  ============================	  x ++ y ++ z = (x ++ y) ++ z	";
            responses[i]=data;
          

            i = 93;
            data = "";
            responses[i]=data;
          

            i = 94;
            data = "1 goal (ID 54)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  y : Words	  ============================	  forall x z : Words, x ++ y ++ z = (x ++ y) ++ z	";
            responses[i]=data;
          

            i = 95;
            data = "2 goals (ID 64)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  x ++ nil ++ z = (x ++ nil) ++ z		goal 2 (ID 66) is:	 x ++ (a :: y) ++ z = (x ++ a :: y) ++ z	";
            responses[i]=data;
          

            i = 96;
            data = "1 goal (ID 64)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  x ++ nil ++ z = (x ++ nil) ++ z	1 goal (ID 107)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  x ++ nil = x	";
            responses[i]=data;
          

            i = 97;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 66) is:	 x ++ (a :: y) ++ z = (x ++ a :: y) ++ z	1 goal (ID 66)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  a : H + K	  y : list (H + K)	  IHy : forall x z : Words, x ++ y ++ z = (x ++ y) ++ z	  x, z : Words	  ============================	  x ++ (a :: y) ++ z = (x ++ a :: y) ++ z	1 goal (ID 111)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  a : H + K	  x : Words	  ============================	  forall (z : Words) (y : list (H + K)),	  (forall x0 z0 : Words, x0 ++ y ++ z0 = (x0 ++ y) ++ z0) ->	  x ++ a :: y ++ z = (x ++ a :: y) ++ z	";
            responses[i]=data;
          

            i = 98;
            data = "1 goal (ID 119)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  a, a0 : H + K	  x : list (H + K)	  IHx : forall (z : Words) (y : list (H + K)),	        (forall x z0 : Words, x ++ y ++ z0 = (x ++ y) ++ z0) ->	        x ++ a :: y ++ z = (x ++ a :: y) ++ z	  ============================	  forall (z : Words) (y : list (H + K)),	  (forall x0 z0 : Words, x0 ++ y ++ z0 = (x0 ++ y) ++ z0) ->	  (a0 :: x) ++ a :: y ++ z = ((a0 :: x) ++ a :: y) ++ z	";
            responses[i]=data;
          

            i = 99;
            data = "1 goal (ID 128)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  a, a0 : H + K	  x : list (H + K)	  IHx : forall (z : Words) (y : list (H + K)),	        (forall x z0 : Words, x ++ y ++ z0 = (x ++ y) ++ z0) ->	        x ++ a :: y ++ z = (x ++ a :: y) ++ z	  z : Words	  y : list (H + K)	  IHy : forall x z : Words, x ++ y ++ z = (x ++ y) ++ z	  ============================	  (a0 :: x) ++ a :: y ++ z = ((a0 :: x) ++ a :: y) ++ z	";
            responses[i]=data;
          

            i = 100;
            data = "1 goal (ID 138)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  a, a0 : H + K	  x : list (H + K)	  IHx : forall (z : Words) (y : list (H + K)),	        (forall x z0 : Words, x ++ y ++ z0 = (x ++ y) ++ z0) ->	        x ++ a :: y ++ z = (x ++ a :: y) ++ z	  z : Words	  y : list (H + K)	  IHy : forall x z : Words, x ++ y ++ z = (x ++ y) ++ z	  ============================	  x ++ a :: y ++ z = (x ++ a :: y) ++ z	";
            responses[i]=data;
          

            i = 101;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 102;
            data = "";
            responses[i]=data;
          

            i = 103;
            data = "1 goal (ID 55)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  word_inverse : Words -> Words	  x : Words	  ============================	  Words	";
            responses[i]=data;
          

            i = 104;
            data = "";
            responses[i]=data;
          

            i = 105;
            data = "2 goals (ID 59)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  word_inverse : Words -> Words	  ============================	  Words		goal 2 (ID 62) is:	 Words	";
            responses[i]=data;
          

            i = 106;
            data = "1 goal (ID 62)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  word_inverse : Words -> Words	  x : H + K	  xs : list (H + K)	  ============================	  Words	";
            responses[i]=data;
          

            i = 107;
            data = "2 goals (ID 70)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  word_inverse : Words -> Words	  h : H	  xs : list (H + K)	  ============================	  Words		goal 2 (ID 72) is:	 Words	";
            responses[i]=data;
          

            i = 108;
            data = "1 goal (ID 70)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  word_inverse : Words -> Words	  h : H	  xs : list (H + K)	  ============================	  Words	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 72) is:	 Words	";
            responses[i]=data;
          

            i = 109;
            data = "1 goal (ID 72)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  word_inverse : Words -> Words	  k : K	  xs : list (H + K)	  ============================	  Words	No more goals.	";
            responses[i]=data;
          

            i = 110;
            data = "";
            responses[i]=data;
          

            i = 111;
            data = "";
            responses[i]=data;
          

            i = 112;
            data = "";
            responses[i]=data;
          

            i = 113;
            data = "";
            responses[i]=data;
          

            i = 114;
            data = "";
            responses[i]=data;
          

            i = 115;
            data = "1 goal (ID 62)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  ============================	  word_inverse (x ++ y) = word_inverse y ++ word_inverse x	";
            responses[i]=data;
          

            i = 116;
            data = "";
            responses[i]=data;
          

            i = 117;
            data = "2 goals (ID 66)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  y : Words	  ============================	  word_inverse (nil ++ y) = word_inverse y ++ word_inverse nil		goal 2 (ID 72) is:	 word_inverse ((x :: xs) ++ y) = word_inverse y ++ word_inverse (x :: xs)	";
            responses[i]=data;
          

            i = 118;
            data = "1 goal (ID 66)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  y : Words	  ============================	  word_inverse (nil ++ y) = word_inverse y ++ word_inverse nil	1 goal (ID 82)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  y : Words	  ============================	  word_inverse y ++ word_inverse nil = word_inverse (nil ++ y)	";
            responses[i]=data;
          

            i = 119;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 72) is:	 word_inverse ((x :: xs) ++ y) = word_inverse y ++ word_inverse (x :: xs)	1 goal (ID 72)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : H + K	  xs : list (H + K)	  y : Words	  IHxs : word_inverse (xs ++ y) = word_inverse y ++ word_inverse xs	  ============================	  word_inverse ((x :: xs) ++ y) = word_inverse y ++ word_inverse (x :: xs)	1 goal (ID 88)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : H + K	  xs : list (H + K)	  y : Words	  IHxs : word_inverse (xs ++ y) = word_inverse y ++ word_inverse xs	  ============================	  match x with	  | inl a => word_inverse (xs ++ y) ++ [inl (- a)]	  | inr b => word_inverse (xs ++ y) ++ [inr (- b)]	  end =	  word_inverse y ++	  match x with	  | inl a => word_inverse xs ++ [inl (- a)]	  | inr b => word_inverse xs ++ [inr (- b)]	  end	";
            responses[i]=data;
          

            i = 120;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 121;
            data = "";
            responses[i]=data;
          

            i = 122;
            data = "";
            responses[i]=data;
          

            i = 123;
            data = "";
            responses[i]=data;
          

            i = 124;
            data = "";
            responses[i]=data;
          

            i = 125;
            data = "";
            responses[i]=data;
          

            i = 126;
            data = "";
            responses[i]=data;
          

            i = 127;
            data = "";
            responses[i]=data;
          

            i = 128;
            data = "";
            responses[i]=data;
          

            i = 129;
            data = "";
            responses[i]=data;
          

            i = 130;
            data = "<infomsg>pc1 is defined</infomsg>	";
            responses[i]=data;
          

            i = 131;
            data = "<infomsg>pc2 is defined</infomsg>	";
            responses[i]=data;
          

            i = 132;
            data = "<infomsg>pc3 is defined</infomsg>	";
            responses[i]=data;
          

            i = 133;
            data = "<infomsg>pc4 is defined</infomsg>	";
            responses[i]=data;
          

            i = 134;
            data = "<infomsg>pc5 is defined</infomsg>	";
            responses[i]=data;
          

            i = 135;
            data = "";
            responses[i]=data;
          

            i = 136;
            data = "";
            responses[i]=data;
          

            i = 137;
            data = "";
            responses[i]=data;
          

            i = 138;
            data = "";
            responses[i]=data;
          

            i = 139;
            data = "1 goal (ID 63)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  pc1 -> Words	";
            responses[i]=data;
          

            i = 140;
            data = "";
            responses[i]=data;
          

            i = 141;
            data = "1 goal (ID 76)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  h1, h2 : H	  y : Words	  ============================	  Words	";
            responses[i]=data;
          

            i = 142;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 143;
            data = "";
            responses[i]=data;
          

            i = 144;
            data = "1 goal (ID 64)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  pc1 -> Words	";
            responses[i]=data;
          

            i = 145;
            data = "";
            responses[i]=data;
          

            i = 146;
            data = "1 goal (ID 77)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  h1, h2 : H	  y : Words	  ============================	  Words	";
            responses[i]=data;
          

            i = 147;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 148;
            data = "";
            responses[i]=data;
          

            i = 149;
            data = "";
            responses[i]=data;
          

            i = 150;
            data = "";
            responses[i]=data;
          

            i = 151;
            data = "";
            responses[i]=data;
          

            i = 152;
            data = "";
            responses[i]=data;
          

            i = 153;
            data = "1 goal (ID 65)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  pc2 -> Words	";
            responses[i]=data;
          

            i = 154;
            data = "";
            responses[i]=data;
          

            i = 155;
            data = "1 goal (ID 78)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  k1, k2 : K	  y : Words	  ============================	  Words	";
            responses[i]=data;
          

            i = 156;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 157;
            data = "";
            responses[i]=data;
          

            i = 158;
            data = "1 goal (ID 66)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  pc2 -> Words	";
            responses[i]=data;
          

            i = 159;
            data = "";
            responses[i]=data;
          

            i = 160;
            data = "1 goal (ID 79)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  k1, k2 : K	  y : Words	  ============================	  Words	";
            responses[i]=data;
          

            i = 161;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 162;
            data = "";
            responses[i]=data;
          

            i = 163;
            data = "";
            responses[i]=data;
          

            i = 164;
            data = "";
            responses[i]=data;
          

            i = 165;
            data = "";
            responses[i]=data;
          

            i = 166;
            data = "";
            responses[i]=data;
          

            i = 167;
            data = "1 goal (ID 67)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  pc3 -> Words	";
            responses[i]=data;
          

            i = 168;
            data = "";
            responses[i]=data;
          

            i = 169;
            data = "1 goal (ID 76)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  z : G	  y : Words	  ============================	  Words	";
            responses[i]=data;
          

            i = 170;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 171;
            data = "";
            responses[i]=data;
          

            i = 172;
            data = "1 goal (ID 68)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  pc3 -> Words	";
            responses[i]=data;
          

            i = 173;
            data = "";
            responses[i]=data;
          

            i = 174;
            data = "1 goal (ID 77)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  z : G	  y : Words	  ============================	  Words	";
            responses[i]=data;
          

            i = 175;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 176;
            data = "";
            responses[i]=data;
          

            i = 177;
            data = "";
            responses[i]=data;
          

            i = 178;
            data = "";
            responses[i]=data;
          

            i = 179;
            data = "";
            responses[i]=data;
          

            i = 180;
            data = "";
            responses[i]=data;
          

            i = 181;
            data = "1 goal (ID 69)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  pc4 -> Words	";
            responses[i]=data;
          

            i = 182;
            data = "";
            responses[i]=data;
          

            i = 183;
            data = "1 goal (ID 74)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  ============================	  Words	";
            responses[i]=data;
          

            i = 184;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 185;
            data = "";
            responses[i]=data;
          

            i = 186;
            data = "1 goal (ID 70)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  pc4 -> Words	";
            responses[i]=data;
          

            i = 187;
            data = "";
            responses[i]=data;
          

            i = 188;
            data = "1 goal (ID 75)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  ============================	  Words	";
            responses[i]=data;
          

            i = 189;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 190;
            data = "";
            responses[i]=data;
          

            i = 191;
            data = "";
            responses[i]=data;
          

            i = 192;
            data = "";
            responses[i]=data;
          

            i = 193;
            data = "";
            responses[i]=data;
          

            i = 194;
            data = "";
            responses[i]=data;
          

            i = 195;
            data = "1 goal (ID 71)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  pc5 -> Words	";
            responses[i]=data;
          

            i = 196;
            data = "";
            responses[i]=data;
          

            i = 197;
            data = "1 goal (ID 76)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  ============================	  Words	";
            responses[i]=data;
          

            i = 198;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 199;
            data = "";
            responses[i]=data;
          

            i = 200;
            data = "1 goal (ID 72)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  pc5 -> Words	";
            responses[i]=data;
          

            i = 201;
            data = "";
            responses[i]=data;
          

            i = 202;
            data = "1 goal (ID 77)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  ============================	  Words	";
            responses[i]=data;
          

            i = 203;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 204;
            data = "";
            responses[i]=data;
          

            i = 205;
            data = "";
            responses[i]=data;
          

            i = 206;
            data = "";
            responses[i]=data;
          

            i = 207;
            data = "";
            responses[i]=data;
          

            i = 208;
            data = "";
            responses[i]=data;
          

            i = 209;
            data = "1 goal (ID 73)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  pc1 + pc2 + pc3 + pc4 + pc5 -> Words	";
            responses[i]=data;
          

            i = 210;
            data = "";
            responses[i]=data;
          

            i = 211;
            data = "5 goals (ID 94)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : pc1	  ============================	  Words		goal 2 (ID 95) is:	 Words	goal 3 (ID 96) is:	 Words	goal 4 (ID 97) is:	 Words	goal 5 (ID 98) is:	 Words	";
            responses[i]=data;
          

            i = 212;
            data = "1 goal (ID 94)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : pc1	  ============================	  Words	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	4 goals		goal 1 (ID 95) is:	 Words	goal 2 (ID 96) is:	 Words	goal 3 (ID 97) is:	 Words	goal 4 (ID 98) is:	 Words	";
            responses[i]=data;
          

            i = 213;
            data = "1 goal (ID 95)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : pc2	  ============================	  Words	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 goals		goal 1 (ID 96) is:	 Words	goal 2 (ID 97) is:	 Words	goal 3 (ID 98) is:	 Words	";
            responses[i]=data;
          

            i = 214;
            data = "1 goal (ID 96)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : pc3	  ============================	  Words	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 97) is:	 Words	goal 2 (ID 98) is:	 Words	";
            responses[i]=data;
          

            i = 215;
            data = "1 goal (ID 97)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : pc4	  ============================	  Words	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 98) is:	 Words	";
            responses[i]=data;
          

            i = 216;
            data = "1 goal (ID 98)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : pc5	  ============================	  Words	No more goals.	";
            responses[i]=data;
          

            i = 217;
            data = "";
            responses[i]=data;
          

            i = 218;
            data = "1 goal (ID 74)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  pc1 + pc2 + pc3 + pc4 + pc5 -> Words	";
            responses[i]=data;
          

            i = 219;
            data = "";
            responses[i]=data;
          

            i = 220;
            data = "5 goals (ID 95)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : pc1	  ============================	  Words		goal 2 (ID 96) is:	 Words	goal 3 (ID 97) is:	 Words	goal 4 (ID 98) is:	 Words	goal 5 (ID 99) is:	 Words	";
            responses[i]=data;
          

            i = 221;
            data = "1 goal (ID 95)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : pc1	  ============================	  Words	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	4 goals		goal 1 (ID 96) is:	 Words	goal 2 (ID 97) is:	 Words	goal 3 (ID 98) is:	 Words	goal 4 (ID 99) is:	 Words	";
            responses[i]=data;
          

            i = 222;
            data = "1 goal (ID 96)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : pc2	  ============================	  Words	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 goals		goal 1 (ID 97) is:	 Words	goal 2 (ID 98) is:	 Words	goal 3 (ID 99) is:	 Words	";
            responses[i]=data;
          

            i = 223;
            data = "1 goal (ID 97)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : pc3	  ============================	  Words	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 98) is:	 Words	goal 2 (ID 99) is:	 Words	";
            responses[i]=data;
          

            i = 224;
            data = "1 goal (ID 98)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : pc4	  ============================	  Words	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 99) is:	 Words	";
            responses[i]=data;
          

            i = 225;
            data = "1 goal (ID 99)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : pc5	  ============================	  Words	No more goals.	";
            responses[i]=data;
          

            i = 226;
            data = "";
            responses[i]=data;
          

            i = 227;
            data = "";
            responses[i]=data;
          

            i = 228;
            data = "";
            responses[i]=data;
          

            i = 229;
            data = "";
            responses[i]=data;
          

            i = 230;
            data = "";
            responses[i]=data;
          

            i = 231;
            data = "<infomsg>amal_type is defined</infomsg>	";
            responses[i]=data;
          

            i = 232;
            data = "";
            responses[i]=data;
          

            i = 233;
            data = "";
            responses[i]=data;
          

            i = 234;
            data = "";
            responses[i]=data;
          

            i = 235;
            data = "";
            responses[i]=data;
          

            i = 236;
            data = "<infomsg>amal_eta is defined</infomsg>	";
            responses[i]=data;
          

            i = 237;
            data = "1 goal (ID 117)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  amal_eta (x ++ (inl h1 :: [inl h2]) ++ y) =	  amal_eta (x ++ [inl (h1 * h2)] ++ y)	";
            responses[i]=data;
          

            i = 238;
            data = "";
            responses[i]=data;
          

            i = 239;
            data = "1 goal (ID 118)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  tr (coeq (x ++ (inl h1 :: [inl h2]) ++ y)) =	  tr (coeq (x ++ [inl (h1 * h2)] ++ y))	";
            responses[i]=data;
          

            i = 240;
            data = "1 goal (ID 124)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  coeq (x ++ (inl h1 :: [inl h2]) ++ y) = coeq (x ++ [inl (h1 * h2)] ++ y)	";
            responses[i]=data;
          

            i = 241;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 242;
            data = "";
            responses[i]=data;
          

            i = 243;
            data = "1 goal (ID 141)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  amal_eta (x ++ (inr k1 :: [inr k2]) ++ y) =	  amal_eta (x ++ [inr (k1 * k2)] ++ y)	";
            responses[i]=data;
          

            i = 244;
            data = "";
            responses[i]=data;
          

            i = 245;
            data = "1 goal (ID 142)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  tr (coeq (x ++ (inr k1 :: [inr k2]) ++ y)) =	  tr (coeq (x ++ [inr (k1 * k2)] ++ y))	";
            responses[i]=data;
          

            i = 246;
            data = "1 goal (ID 148)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  coeq (x ++ (inr k1 :: [inr k2]) ++ y) = coeq (x ++ [inr (k1 * k2)] ++ y)	";
            responses[i]=data;
          

            i = 247;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 248;
            data = "";
            responses[i]=data;
          

            i = 249;
            data = "1 goal (ID 163)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  ============================	  amal_eta (x ++ [inl (f z)] ++ y) = amal_eta (x ++ [inr (g z)] ++ y)	";
            responses[i]=data;
          

            i = 250;
            data = "";
            responses[i]=data;
          

            i = 251;
            data = "1 goal (ID 164)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  ============================	  tr (coeq (x ++ [inl (f z)] ++ y)) = tr (coeq (x ++ [inr (g z)] ++ y))	";
            responses[i]=data;
          

            i = 252;
            data = "1 goal (ID 170)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  ============================	  coeq (x ++ [inl (f z)] ++ y) = coeq (x ++ [inr (g z)] ++ y)	";
            responses[i]=data;
          

            i = 253;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 254;
            data = "";
            responses[i]=data;
          

            i = 255;
            data = "1 goal (ID 177)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  ============================	  amal_eta (x ++ [inl mon_unit] ++ y) = amal_eta (x ++ y)	";
            responses[i]=data;
          

            i = 256;
            data = "";
            responses[i]=data;
          

            i = 257;
            data = "1 goal (ID 178)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  ============================	  tr (coeq (x ++ [inl mon_unit] ++ y)) = tr (coeq (x ++ y))	";
            responses[i]=data;
          

            i = 258;
            data = "1 goal (ID 184)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  ============================	  coeq (x ++ [inl mon_unit] ++ y) = coeq (x ++ y)	";
            responses[i]=data;
          

            i = 259;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 260;
            data = "";
            responses[i]=data;
          

            i = 261;
            data = "1 goal (ID 191)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  ============================	  amal_eta (x ++ [inr mon_unit] ++ y) = amal_eta (x ++ y)	";
            responses[i]=data;
          

            i = 262;
            data = "";
            responses[i]=data;
          

            i = 263;
            data = "1 goal (ID 192)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  ============================	  tr (coeq (x ++ [inr mon_unit] ++ y)) = tr (coeq (x ++ y))	";
            responses[i]=data;
          

            i = 264;
            data = "1 goal (ID 198)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  ============================	  coeq (x ++ [inr mon_unit] ++ y) = coeq (x ++ y)	";
            responses[i]=data;
          

            i = 265;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 266;
            data = "";
            responses[i]=data;
          

            i = 267;
            data = "";
            responses[i]=data;
          

            i = 268;
            data = "";
            responses[i]=data;
          

            i = 269;
            data = "";
            responses[i]=data;
          

            i = 270;
            data = "";
            responses[i]=data;
          

            i = 271;
            data = "1 goal (ID 286)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  ============================	  forall x : amal_type, P x	";
            responses[i]=data;
          

            i = 272;
            data = "";
            responses[i]=data;
          

            i = 273;
            data = "1 goal (ID 305)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  ============================	  forall a : Coeq map1 map2, P (tr a)	";
            responses[i]=data;
          

            i = 274;
            data = "2 goals (ID 342)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  ============================	  forall a : Words, (fun w : Coeq map1 map2 => P (tr w)) (coeq a)		goal 2 (ID 344) is:	 forall b : pc1 + pc2 + pc3 + pc4 + pc5,	 transport (fun w : Coeq map1 map2 => P (tr w)) (cglue b) (?coeq' (map1 b)) =	 ?coeq' (map2 b)	";
            responses[i]=data;
          

            i = 275;
            data = "1 goal (ID 344)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  ============================	  forall b : pc1 + pc2 + pc3 + pc4 + pc5,	  transport (fun w : Coeq map1 map2 => P (tr w)) (cglue b) (e (map1 b)) =	  e (map2 b)	";
            responses[i]=data;
          

            i = 276;
            data = "1 goal (ID 351)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  a : pc1 + pc2 + pc3 + pc4 + pc5	  ============================	  transport (fun w : Coeq map1 map2 => P (tr w)) (cglue a) (e (map1 a)) =	  e (map2 a)	";
            responses[i]=data;
          

            i = 277;
            data = "1 goal (ID 377)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  a : pc1 + pc2 + pc3 + pc4 + pc5	  ============================	  DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue a) 	    (e (map1 a)) (e (map2 a))	";
            responses[i]=data;
          

            i = 278;
            data = "5 goals (ID 403)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  a : pc1	  ============================	  DPath (fun w : Coeq map1 map2 => P (tr w))	    (cglue (inl (inl (inl (inl a))))) (e (map1 (inl (inl (inl (inl a))))))	    (e (map2 (inl (inl (inl (inl a))))))		goal 2 (ID 404) is:	 DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inl (inl (inl (inr a)))))	   (e (map1 (inl (inl (inl (inr a)))))) (e (map2 (inl (inl (inl (inr a))))))	goal 3 (ID 405) is:	 DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inl (inl (inr a))))	   (e (map1 (inl (inl (inr a))))) (e (map2 (inl (inl (inr a)))))	goal 4 (ID 406) is:	 DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inl (inr a)))	   (e (map1 (inl (inr a)))) (e (map2 (inl (inr a))))	goal 5 (ID 407) is:	 DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inr a))	   (e (map1 (inr a))) (e (map2 (inr a)))	";
            responses[i]=data;
          

            i = 279;
            data = "1 goal (ID 403)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  a : pc1	  ============================	  DPath (fun w : Coeq map1 map2 => P (tr w))	    (cglue (inl (inl (inl (inl a))))) (e (map1 (inl (inl (inl (inl a))))))	    (e (map2 (inl (inl (inl (inl a))))))	1 goal (ID 420)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  x : Words	  h1, h2 : H	  y : Words	  ============================	  DPath (fun w : Coeq map1 map2 => P (tr w))	    (cglue (inl (inl (inl (inl (x, h1, h2, y))))))	    (e (map1 (inl (inl (inl (inl (x, h1, h2, y)))))))	    (e (map2 (inl (inl (inl (inl (x, h1, h2, y)))))))	";
            responses[i]=data;
          

            i = 280;
            data = "1 goal (ID 431)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  x : Words	  h1, h2 : H	  y : Words	  ============================	  DPath P (ap tr (cglue (inl (inl (inl (inl (x, h1, h2, y)))))))	    (e (map1 (inl (inl (inl (inl (x, h1, h2, y)))))))	    (e (map2 (inl (inl (inl (inl (x, h1, h2, y)))))))	";
            responses[i]=data;
          

            i = 281;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	4 goals		goal 1 (ID 404) is:	 DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inl (inl (inl (inr a)))))	   (e (map1 (inl (inl (inl (inr a)))))) (e (map2 (inl (inl (inl (inr a))))))	goal 2 (ID 405) is:	 DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inl (inl (inr a))))	   (e (map1 (inl (inl (inr a))))) (e (map2 (inl (inl (inr a)))))	goal 3 (ID 406) is:	 DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inl (inr a)))	   (e (map1 (inl (inr a)))) (e (map2 (inl (inr a))))	goal 4 (ID 407) is:	 DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inr a))	   (e (map1 (inr a))) (e (map2 (inr a)))	";
            responses[i]=data;
          

            i = 282;
            data = "1 goal (ID 404)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  a : pc2	  ============================	  DPath (fun w : Coeq map1 map2 => P (tr w))	    (cglue (inl (inl (inl (inr a))))) (e (map1 (inl (inl (inl (inr a))))))	    (e (map2 (inl (inl (inl (inr a))))))	1 goal (ID 444)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  x : Words	  k1, k2 : K	  y : Words	  ============================	  DPath (fun w : Coeq map1 map2 => P (tr w))	    (cglue (inl (inl (inl (inr (x, k1, k2, y))))))	    (e (map1 (inl (inl (inl (inr (x, k1, k2, y)))))))	    (e (map2 (inl (inl (inl (inr (x, k1, k2, y)))))))	";
            responses[i]=data;
          

            i = 283;
            data = "1 goal (ID 455)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  x : Words	  k1, k2 : K	  y : Words	  ============================	  DPath P (ap tr (cglue (inl (inl (inl (inr (x, k1, k2, y)))))))	    (e (map1 (inl (inl (inl (inr (x, k1, k2, y)))))))	    (e (map2 (inl (inl (inl (inr (x, k1, k2, y)))))))	";
            responses[i]=data;
          

            i = 284;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	3 goals		goal 1 (ID 405) is:	 DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inl (inl (inr a))))	   (e (map1 (inl (inl (inr a))))) (e (map2 (inl (inl (inr a)))))	goal 2 (ID 406) is:	 DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inl (inr a)))	   (e (map1 (inl (inr a)))) (e (map2 (inl (inr a))))	goal 3 (ID 407) is:	 DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inr a))	   (e (map1 (inr a))) (e (map2 (inr a)))	";
            responses[i]=data;
          

            i = 285;
            data = "1 goal (ID 405)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  a : pc3	  ============================	  DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inl (inl (inr a))))	    (e (map1 (inl (inl (inr a))))) (e (map2 (inl (inl (inr a)))))	1 goal (ID 464)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  x : Words	  z : G	  y : Words	  ============================	  DPath (fun w : Coeq map1 map2 => P (tr w))	    (cglue (inl (inl (inr (x, z, y)))))	    (e (map1 (inl (inl (inr (x, z, y))))))	    (e (map2 (inl (inl (inr (x, z, y))))))	";
            responses[i]=data;
          

            i = 286;
            data = "1 goal (ID 475)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  x : Words	  z : G	  y : Words	  ============================	  DPath P (ap tr (cglue (inl (inl (inr (x, z, y))))))	    (e (map1 (inl (inl (inr (x, z, y))))))	    (e (map2 (inl (inl (inr (x, z, y))))))	";
            responses[i]=data;
          

            i = 287;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	2 goals		goal 1 (ID 406) is:	 DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inl (inr a)))	   (e (map1 (inl (inr a)))) (e (map2 (inl (inr a))))	goal 2 (ID 407) is:	 DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inr a))	   (e (map1 (inr a))) (e (map2 (inr a)))	";
            responses[i]=data;
          

            i = 288;
            data = "1 goal (ID 406)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  a : pc4	  ============================	  DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inl (inr a)))	    (e (map1 (inl (inr a)))) (e (map2 (inl (inr a))))	1 goal (ID 480)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  x, y : Words	  ============================	  DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inl (inr (x, y))))	    (e (map1 (inl (inr (x, y))))) (e (map2 (inl (inr (x, y)))))	";
            responses[i]=data;
          

            i = 289;
            data = "1 goal (ID 491)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  x, y : Words	  ============================	  DPath P (ap tr (cglue (inl (inr (x, y))))) (e (map1 (inl (inr (x, y)))))	    (e (map2 (inl (inr (x, y)))))	";
            responses[i]=data;
          

            i = 290;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 407) is:	 DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inr a))	   (e (map1 (inr a))) (e (map2 (inr a)))	";
            responses[i]=data;
          

            i = 291;
            data = "1 goal (ID 407)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  a : pc5	  ============================	  DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inr a))	    (e (map1 (inr a))) (e (map2 (inr a)))	1 goal (ID 496)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  x, y : Words	  ============================	  DPath (fun w : Coeq map1 map2 => P (tr w)) (cglue (inr (x, y)))	    (e (map1 (inr (x, y)))) (e (map2 (inr (x, y))))	";
            responses[i]=data;
          

            i = 292;
            data = "1 goal (ID 507)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHSet (P x)	  e : forall w : Words, P (amal_eta w)	  mh : forall (x y : Words) (h1 h2 : H),	       DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	         (e (x ++ [inl (h1 * h2)] ++ y))	  mk : forall (x y : Words) (k1 k2 : K),	       DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	         (e (x ++ [inr (k1 * k2)] ++ y))	  t : forall (x y : Words) (z : G),	      DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	        (e (x ++ [inr (g z)] ++ y))	  oh : forall x y : Words,	       DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	  ok : forall x y : Words,	       DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	  x, y : Words	  ============================	  DPath P (ap tr (cglue (inr (x, y)))) (e (map1 (inr (x, y))))	    (e (map2 (inr (x, y))))	";
            responses[i]=data;
          

            i = 293;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 294;
            data = "";
            responses[i]=data;
          

            i = 295;
            data = "1 goal (ID 293)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHProp (P x)	  e : forall w : Words, P (amal_eta w)	  ============================	  forall x : amal_type, P x	";
            responses[i]=data;
          

            i = 296;
            data = "";
            responses[i]=data;
          

            i = 297;
            data = "6 goals (ID 1201)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHProp (P x)	  e : forall w : Words, P (amal_eta w)	  ============================	  forall w : Words, P (amal_eta w)		goal 2 (ID 1203) is:	 forall (x y : Words) (h1 h2 : H),	 DPath P (amal_mu_H x y h1 h2) (?e (x ++ (inl h1 :: [inl h2]) ++ y))	   (?e (x ++ [inl (h1 * h2)] ++ y))	goal 3 (ID 1205) is:	 forall (x y : Words) (k1 k2 : K),	 DPath P (amal_mu_K x y k1 k2) (?e (x ++ (inr k1 :: [inr k2]) ++ y))	   (?e (x ++ [inr (k1 * k2)] ++ y))	goal 4 (ID 1207) is:	 forall (x y : Words) (z : G),	 DPath P (amal_tau x y z) (?e (x ++ [inl (f z)] ++ y))	   (?e (x ++ [inr (g z)] ++ y))	goal 5 (ID 1209) is:	 forall x y : Words,	 DPath P (amal_omega_H x y) (?e (x ++ [inl mon_unit] ++ y)) (?e (x ++ y))	goal 6 (ID 1211) is:	 forall x y : Words,	 DPath P (amal_omega_K x y) (?e (x ++ [inr mon_unit] ++ y)) (?e (x ++ y))	";
            responses[i]=data;
          

            i = 298;
            data = "5 goals (ID 1203)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : amal_type -> Type	  H0 : forall x : amal_type, IsHProp (P x)	  e : forall w : Words, P (amal_eta w)	  ============================	  forall (x y : Words) (h1 h2 : H),	  DPath P (amal_mu_H x y h1 h2) (e (x ++ (inl h1 :: [inl h2]) ++ y))	    (e (x ++ [inl (h1 * h2)] ++ y))		goal 2 (ID 1205) is:	 forall (x y : Words) (k1 k2 : K),	 DPath P (amal_mu_K x y k1 k2) (e (x ++ (inr k1 :: [inr k2]) ++ y))	   (e (x ++ [inr (k1 * k2)] ++ y))	goal 3 (ID 1207) is:	 forall (x y : Words) (z : G),	 DPath P (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	   (e (x ++ [inr (g z)] ++ y))	goal 4 (ID 1209) is:	 forall x y : Words,	 DPath P (amal_omega_H x y) (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	goal 5 (ID 1211) is:	 forall x y : Words,	 DPath P (amal_omega_K x y) (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	";
            responses[i]=data;
          

            i = 299;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 300;
            data = "";
            responses[i]=data;
          

            i = 301;
            data = "";
            responses[i]=data;
          

            i = 302;
            data = "";
            responses[i]=data;
          

            i = 303;
            data = "";
            responses[i]=data;
          

            i = 304;
            data = "";
            responses[i]=data;
          

            i = 305;
            data = "1 goal (ID 380)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : Type	  IsHSet0 : IsHSet P	  e : Words -> P	  eh : forall (x y : Words) (h1 h2 : H),	       e (x ++ (inl h1 :: [inl h2]) ++ y) = e (x ++ [inl (h1 * h2)] ++ y)	  ek : forall (x y : Words) (k1 k2 : K),	       e (x ++ (inr k1 :: [inr k2]) ++ y) = e (x ++ [inr (k1 * k2)] ++ y)	  t : forall (x y : Words) (z : G),	      e (x ++ [inl (f z)] ++ y) = e (x ++ [inr (g z)] ++ y)	  oh : forall x y : Words, e (x ++ [inl mon_unit] ++ y) = e (x ++ y)	  ok : forall x y : Words, e (x ++ [inr mon_unit] ++ y) = e (x ++ y)	  ============================	  amal_type -> P	";
            responses[i]=data;
          

            i = 306;
            data = "";
            responses[i]=data;
          

            i = 307;
            data = "7 goals (ID 440)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : Type	  IsHSet0 : IsHSet P	  e : Words -> P	  eh : forall (x y : Words) (h1 h2 : H),	       e (x ++ (inl h1 :: [inl h2]) ++ y) = e (x ++ [inl (h1 * h2)] ++ y)	  ek : forall (x y : Words) (k1 k2 : K),	       e (x ++ (inr k1 :: [inr k2]) ++ y) = e (x ++ [inr (k1 * k2)] ++ y)	  t : forall (x y : Words) (z : G),	      e (x ++ [inl (f z)] ++ y) = e (x ++ [inr (g z)] ++ y)	  oh : forall x y : Words, e (x ++ [inl mon_unit] ++ y) = e (x ++ y)	  ok : forall x y : Words, e (x ++ [inr mon_unit] ++ y) = e (x ++ y)	  ============================	  forall x : amal_type, IsHSet ((fun _ : amal_type => P) x)		goal 2 (ID 442) is:	 forall w : Words, (fun _ : amal_type => P) (amal_eta w)	goal 3 (ID 444) is:	 forall (x y : Words) (h1 h2 : H),	 DPath (fun _ : amal_type => P) (amal_mu_H x y h1 h2)	   (?e (x ++ (inl h1 :: [inl h2]) ++ y)) (?e (x ++ [inl (h1 * h2)] ++ y))	goal 4 (ID 446) is:	 forall (x y : Words) (k1 k2 : K),	 DPath (fun _ : amal_type => P) (amal_mu_K x y k1 k2)	   (?e (x ++ (inr k1 :: [inr k2]) ++ y)) (?e (x ++ [inr (k1 * k2)] ++ y))	goal 5 (ID 448) is:	 forall (x y : Words) (z : G),	 DPath (fun _ : amal_type => P) (amal_tau x y z) (?e (x ++ [inl (f z)] ++ y))	   (?e (x ++ [inr (g z)] ++ y))	goal 6 (ID 450) is:	 forall x y : Words,	 DPath (fun _ : amal_type => P) (amal_omega_H x y)	   (?e (x ++ [inl mon_unit] ++ y)) (?e (x ++ y))	goal 7 (ID 452) is:	 forall x y : Words,	 DPath (fun _ : amal_type => P) (amal_omega_K x y)	   (?e (x ++ [inr mon_unit] ++ y)) (?e (x ++ y))	";
            responses[i]=data;
          

            i = 308;
            data = "6 goals (ID 442)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : Type	  IsHSet0 : IsHSet P	  e : Words -> P	  eh : forall (x y : Words) (h1 h2 : H),	       e (x ++ (inl h1 :: [inl h2]) ++ y) = e (x ++ [inl (h1 * h2)] ++ y)	  ek : forall (x y : Words) (k1 k2 : K),	       e (x ++ (inr k1 :: [inr k2]) ++ y) = e (x ++ [inr (k1 * k2)] ++ y)	  t : forall (x y : Words) (z : G),	      e (x ++ [inl (f z)] ++ y) = e (x ++ [inr (g z)] ++ y)	  oh : forall x y : Words, e (x ++ [inl mon_unit] ++ y) = e (x ++ y)	  ok : forall x y : Words, e (x ++ [inr mon_unit] ++ y) = e (x ++ y)	  ============================	  forall w : Words, (fun _ : amal_type => P) (amal_eta w)		goal 2 (ID 444) is:	 forall (x y : Words) (h1 h2 : H),	 DPath (fun _ : amal_type => P) (amal_mu_H x y h1 h2)	   (?e (x ++ (inl h1 :: [inl h2]) ++ y)) (?e (x ++ [inl (h1 * h2)] ++ y))	goal 3 (ID 446) is:	 forall (x y : Words) (k1 k2 : K),	 DPath (fun _ : amal_type => P) (amal_mu_K x y k1 k2)	   (?e (x ++ (inr k1 :: [inr k2]) ++ y)) (?e (x ++ [inr (k1 * k2)] ++ y))	goal 4 (ID 448) is:	 forall (x y : Words) (z : G),	 DPath (fun _ : amal_type => P) (amal_tau x y z) (?e (x ++ [inl (f z)] ++ y))	   (?e (x ++ [inr (g z)] ++ y))	goal 5 (ID 450) is:	 forall x y : Words,	 DPath (fun _ : amal_type => P) (amal_omega_H x y)	   (?e (x ++ [inl mon_unit] ++ y)) (?e (x ++ y))	goal 6 (ID 452) is:	 forall x y : Words,	 DPath (fun _ : amal_type => P) (amal_omega_K x y)	   (?e (x ++ [inr mon_unit] ++ y)) (?e (x ++ y))	";
            responses[i]=data;
          

            i = 309;
            data = "5 goals (ID 444)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : Type	  IsHSet0 : IsHSet P	  e : Words -> P	  eh : forall (x y : Words) (h1 h2 : H),	       e (x ++ (inl h1 :: [inl h2]) ++ y) = e (x ++ [inl (h1 * h2)] ++ y)	  ek : forall (x y : Words) (k1 k2 : K),	       e (x ++ (inr k1 :: [inr k2]) ++ y) = e (x ++ [inr (k1 * k2)] ++ y)	  t : forall (x y : Words) (z : G),	      e (x ++ [inl (f z)] ++ y) = e (x ++ [inr (g z)] ++ y)	  oh : forall x y : Words, e (x ++ [inl mon_unit] ++ y) = e (x ++ y)	  ok : forall x y : Words, e (x ++ [inr mon_unit] ++ y) = e (x ++ y)	  ============================	  forall (x y : Words) (h1 h2 : H),	  DPath (fun _ : amal_type => P) (amal_mu_H x y h1 h2)	    (e (x ++ (inl h1 :: [inl h2]) ++ y)) (e (x ++ [inl (h1 * h2)] ++ y))		goal 2 (ID 446) is:	 forall (x y : Words) (k1 k2 : K),	 DPath (fun _ : amal_type => P) (amal_mu_K x y k1 k2)	   (e (x ++ (inr k1 :: [inr k2]) ++ y)) (e (x ++ [inr (k1 * k2)] ++ y))	goal 3 (ID 448) is:	 forall (x y : Words) (z : G),	 DPath (fun _ : amal_type => P) (amal_tau x y z) (e (x ++ [inl (f z)] ++ y))	   (e (x ++ [inr (g z)] ++ y))	goal 4 (ID 450) is:	 forall x y : Words,	 DPath (fun _ : amal_type => P) (amal_omega_H x y)	   (e (x ++ [inl mon_unit] ++ y)) (e (x ++ y))	goal 5 (ID 452) is:	 forall x y : Words,	 DPath (fun _ : amal_type => P) (amal_omega_K x y)	   (e (x ++ [inr mon_unit] ++ y)) (e (x ++ y))	";
            responses[i]=data;
          

            i = 310;
            data = "5 goals (ID 497)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : Type	  IsHSet0 : IsHSet P	  e : Words -> P	  eh : forall (x y : Words) (h1 h2 : H),	       e (x ++ (inl h1 :: [inl h2]) ++ y) = e (x ++ [inl (h1 * h2)] ++ y)	  ek : forall (x y : Words) (k1 k2 : K),	       e (x ++ (inr k1 :: [inr k2]) ++ y) = e (x ++ [inr (k1 * k2)] ++ y)	  t : forall (x y : Words) (z : G),	      e (x ++ [inl (f z)] ++ y) = e (x ++ [inr (g z)] ++ y)	  oh : forall x y : Words, e (x ++ [inl mon_unit] ++ y) = e (x ++ y)	  ok : forall x y : Words, e (x ++ [inr mon_unit] ++ y) = e (x ++ y)	  x, y : Words	  h1, h2 : H	  ============================	  e (x ++ (inl h1 :: [inl h2]) ++ y) = e (x ++ [inl (h1 * h2)] ++ y)		goal 2 (ID 508) is:	 e (x ++ (inr k1 :: [inr k2]) ++ y) = e (x ++ [inr (k1 * k2)] ++ y)	goal 3 (ID 519) is:	 e (x ++ [inl (f z)] ++ y) = e (x ++ [inr (g z)] ++ y)	goal 4 (ID 530) is:	 e (x ++ [inl mon_unit] ++ y) = e (x ++ y)	goal 5 (ID 541) is:	 e (x ++ [inr mon_unit] ++ y) = e (x ++ y)	";
            responses[i]=data;
          

            i = 311;
            data = "4 goals (ID 508)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : Type	  IsHSet0 : IsHSet P	  e : Words -> P	  eh : forall (x y : Words) (h1 h2 : H),	       e (x ++ (inl h1 :: [inl h2]) ++ y) = e (x ++ [inl (h1 * h2)] ++ y)	  ek : forall (x y : Words) (k1 k2 : K),	       e (x ++ (inr k1 :: [inr k2]) ++ y) = e (x ++ [inr (k1 * k2)] ++ y)	  t : forall (x y : Words) (z : G),	      e (x ++ [inl (f z)] ++ y) = e (x ++ [inr (g z)] ++ y)	  oh : forall x y : Words, e (x ++ [inl mon_unit] ++ y) = e (x ++ y)	  ok : forall x y : Words, e (x ++ [inr mon_unit] ++ y) = e (x ++ y)	  x, y : Words	  k1, k2 : K	  ============================	  e (x ++ (inr k1 :: [inr k2]) ++ y) = e (x ++ [inr (k1 * k2)] ++ y)		goal 2 (ID 519) is:	 e (x ++ [inl (f z)] ++ y) = e (x ++ [inr (g z)] ++ y)	goal 3 (ID 530) is:	 e (x ++ [inl mon_unit] ++ y) = e (x ++ y)	goal 4 (ID 541) is:	 e (x ++ [inr mon_unit] ++ y) = e (x ++ y)	";
            responses[i]=data;
          

            i = 312;
            data = "3 goals (ID 519)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : Type	  IsHSet0 : IsHSet P	  e : Words -> P	  eh : forall (x y : Words) (h1 h2 : H),	       e (x ++ (inl h1 :: [inl h2]) ++ y) = e (x ++ [inl (h1 * h2)] ++ y)	  ek : forall (x y : Words) (k1 k2 : K),	       e (x ++ (inr k1 :: [inr k2]) ++ y) = e (x ++ [inr (k1 * k2)] ++ y)	  t : forall (x y : Words) (z : G),	      e (x ++ [inl (f z)] ++ y) = e (x ++ [inr (g z)] ++ y)	  oh : forall x y : Words, e (x ++ [inl mon_unit] ++ y) = e (x ++ y)	  ok : forall x y : Words, e (x ++ [inr mon_unit] ++ y) = e (x ++ y)	  x, y : Words	  z : G	  ============================	  e (x ++ [inl (f z)] ++ y) = e (x ++ [inr (g z)] ++ y)		goal 2 (ID 530) is:	 e (x ++ [inl mon_unit] ++ y) = e (x ++ y)	goal 3 (ID 541) is:	 e (x ++ [inr mon_unit] ++ y) = e (x ++ y)	";
            responses[i]=data;
          

            i = 313;
            data = "2 goals (ID 530)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : Type	  IsHSet0 : IsHSet P	  e : Words -> P	  eh : forall (x y : Words) (h1 h2 : H),	       e (x ++ (inl h1 :: [inl h2]) ++ y) = e (x ++ [inl (h1 * h2)] ++ y)	  ek : forall (x y : Words) (k1 k2 : K),	       e (x ++ (inr k1 :: [inr k2]) ++ y) = e (x ++ [inr (k1 * k2)] ++ y)	  t : forall (x y : Words) (z : G),	      e (x ++ [inl (f z)] ++ y) = e (x ++ [inr (g z)] ++ y)	  oh : forall x y : Words, e (x ++ [inl mon_unit] ++ y) = e (x ++ y)	  ok : forall x y : Words, e (x ++ [inr mon_unit] ++ y) = e (x ++ y)	  x, y : Words	  ============================	  e (x ++ [inl mon_unit] ++ y) = e (x ++ y)		goal 2 (ID 541) is:	 e (x ++ [inr mon_unit] ++ y) = e (x ++ y)	";
            responses[i]=data;
          

            i = 314;
            data = "1 goal (ID 541)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  P : Type	  IsHSet0 : IsHSet P	  e : Words -> P	  eh : forall (x y : Words) (h1 h2 : H),	       e (x ++ (inl h1 :: [inl h2]) ++ y) = e (x ++ [inl (h1 * h2)] ++ y)	  ek : forall (x y : Words) (k1 k2 : K),	       e (x ++ (inr k1 :: [inr k2]) ++ y) = e (x ++ [inr (k1 * k2)] ++ y)	  t : forall (x y : Words) (z : G),	      e (x ++ [inl (f z)] ++ y) = e (x ++ [inr (g z)] ++ y)	  oh : forall x y : Words, e (x ++ [inl mon_unit] ++ y) = e (x ++ y)	  ok : forall x y : Words, e (x ++ [inr mon_unit] ++ y) = e (x ++ y)	  x, y : Words	  ============================	  e (x ++ [inr mon_unit] ++ y) = e (x ++ y)	";
            responses[i]=data;
          

            i = 315;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 316;
            data = "";
            responses[i]=data;
          

            i = 317;
            data = "";
            responses[i]=data;
          

            i = 318;
            data = "";
            responses[i]=data;
          

            i = 319;
            data = "";
            responses[i]=data;
          

            i = 320;
            data = "";
            responses[i]=data;
          

            i = 321;
            data = "";
            responses[i]=data;
          

            i = 322;
            data = "";
            responses[i]=data;
          

            i = 323;
            data = "1 goal (ID 381)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  SgOp amal_type	";
            responses[i]=data;
          

            i = 324;
            data = "";
            responses[i]=data;
          

            i = 325;
            data = "1 goal (ID 386)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  y : amal_type	  ============================	  amal_type -> amal_type	";
            responses[i]=data;
          

            i = 326;
            data = "6 goals (ID 1294)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  amal_type -> amal_type		goal 2 (ID 1296) is:	 forall (y : amal_type) (y0 : Words) (h1 h2 : H),	 (fun x0 : Words => ?Goal@{x:=x0} y) (x ++ (inl h1 :: [inl h2]) ++ y0) =	 (fun x0 : Words => ?Goal@{x:=x0} y) (x ++ [inl (h1 * h2)] ++ y0)	goal 3 (ID 1298) is:	 forall (y : amal_type) (y0 : Words) (k1 k2 : K),	 (fun x0 : Words => ?Goal@{x:=x0} y) (x ++ (inr k1 :: [inr k2]) ++ y0) =	 (fun x0 : Words => ?Goal@{x:=x0} y) (x ++ [inr (k1 * k2)] ++ y0)	goal 4 (ID 1300) is:	 forall (y : amal_type) (y0 : Words) (z : G),	 (fun x0 : Words => ?Goal@{x:=x0} y) (x ++ [inl (f z)] ++ y0) =	 (fun x0 : Words => ?Goal@{x:=x0} y) (x ++ [inr (g z)] ++ y0)	goal 5 (ID 1302) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words => ?Goal@{x:=x0} y) (x ++ [inl mon_unit] ++ y0) =	 (fun x0 : Words => ?Goal@{x:=x0} y) (x ++ y0)	goal 6 (ID 1304) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words => ?Goal@{x:=x0} y) (x ++ [inr mon_unit] ++ y0) =	 (fun x0 : Words => ?Goal@{x:=x0} y) (x ++ y0)	";
            responses[i]=data;
          

            i = 327;
            data = "1 goal (ID 1294)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  amal_type -> amal_type	6 goals (ID 2205)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y : Words	  ============================	  amal_type		goal 2 (ID 2206) is:	 forall (y0 : Words) (h1 h2 : H),	 (fun y1 : Words => ?Goal4@{y:=y1}) (y ++ (inl h1 :: [inl h2]) ++ y0) =	 (fun y1 : Words => ?Goal4@{y:=y1}) (y ++ [inl (h1 * h2)] ++ y0)	goal 3 (ID 2207) is:	 forall (y0 : Words) (k1 k2 : K),	 (fun y1 : Words => ?Goal4@{y:=y1}) (y ++ (inr k1 :: [inr k2]) ++ y0) =	 (fun y1 : Words => ?Goal4@{y:=y1}) (y ++ [inr (k1 * k2)] ++ y0)	goal 4 (ID 2208) is:	 forall (y0 : Words) (z : G),	 (fun y1 : Words => ?Goal4@{y:=y1}) (y ++ [inl (f z)] ++ y0) =	 (fun y1 : Words => ?Goal4@{y:=y1}) (y ++ [inr (g z)] ++ y0)	goal 5 (ID 2209) is:	 forall y0 : Words,	 (fun y1 : Words => ?Goal4@{y:=y1}) (y ++ [inl mon_unit] ++ y0) =	 (fun y1 : Words => ?Goal4@{y:=y1}) (y ++ y0)	goal 6 (ID 2210) is:	 forall y0 : Words,	 (fun y1 : Words => ?Goal4@{y:=y1}) (y ++ [inr mon_unit] ++ y0) =	 (fun y1 : Words => ?Goal4@{y:=y1}) (y ++ y0)	";
            responses[i]=data;
          

            i = 328;
            data = "5 goals (ID 2206)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y : Words	  ============================	  forall (y0 : Words) (h1 h2 : H),	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ (inl h1 :: [inl h2]) ++ y0) =	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl (h1 * h2)] ++ y0)		goal 2 (ID 2207) is:	 forall (y0 : Words) (k1 k2 : K),	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ (inr k1 :: [inr k2]) ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr (k1 * k2)] ++ y0)	goal 3 (ID 2208) is:	 forall (y0 : Words) (z : G),	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl (f z)] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr (g z)] ++ y0)	goal 4 (ID 2209) is:	 forall y0 : Words,	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl mon_unit] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	goal 5 (ID 2210) is:	 forall y0 : Words,	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr mon_unit] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	";
            responses[i]=data;
          

            i = 329;
            data = "1 goal (ID 2206)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y : Words	  ============================	  forall (y0 : Words) (h1 h2 : H),	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ (inl h1 :: [inl h2]) ++ y0) =	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl (h1 * h2)] ++ y0)	1 goal (ID 2214)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y, z : Words	  h1, h2 : H	  ============================	  (fun y0 : Words => amal_eta (x ++ y0)) (y ++ (inl h1 :: [inl h2]) ++ z) =	  (fun y0 : Words => amal_eta (x ++ y0)) (y ++ [inl (h1 * h2)] ++ z)	";
            responses[i]=data;
          

            i = 330;
            data = "3 focused goals (shelved: 2) (ID 2241)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y, z : Words	  h1, h2 : H	  ============================	  x ++ y ++ (inl h1 :: [inl h2]) ++ z = ?Goal8		goal 2 (ID 2242) is:	 amal_eta ?Goal8 = amal_eta ?Goal11	goal 3 (ID 2244) is:	 x ++ y ++ [inl (h1 * h2)] ++ z = ?Goal11	";
            responses[i]=data;
          

            i = 331;
            data = "1 goal (ID 2242)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y, z : Words	  h1, h2 : H	  ============================	  amal_eta ((x ++ y) ++ (inl h1 :: [inl h2]) ++ z) =	  amal_eta ((x ++ y) ++ [inl (h1 * h2)] ++ z)	";
            responses[i]=data;
          

            i = 332;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	9 goals		goal 1 (ID 2207) is:	 forall (y0 : Words) (k1 k2 : K),	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ (inr k1 :: [inr k2]) ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr (k1 * k2)] ++ y0)	goal 2 (ID 2208) is:	 forall (y0 : Words) (z : G),	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl (f z)] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr (g z)] ++ y0)	goal 3 (ID 2209) is:	 forall y0 : Words,	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl mon_unit] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	goal 4 (ID 2210) is:	 forall y0 : Words,	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr mon_unit] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	goal 5 (ID 1296) is:	 forall (y : amal_type) (y0 : Words) (h1 h2 : H),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h0 h3 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h0 h3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal7@{x:=x0; y:=y1}) y)	   (x ++ (inl h1 :: [inl h2]) ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h0 h3 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h0 h3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal7@{x:=x0; y:=y1}) y) (x ++ [inl (h1 * h2)] ++ y0)	goal 6 (ID 1298) is:	 forall (y : amal_type) (y0 : Words) (k1 k2 : K),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal7@{x:=x0; y:=y1}) y)	   (x ++ (inr k1 :: [inr k2]) ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal7@{x:=x0; y:=y1}) y) (x ++ [inr (k1 * k2)] ++ y0)	goal 7 (ID 1300) is:	 forall (y : amal_type) (y0 : Words) (z : G),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal7@{x:=x0; y:=y1}) y) (x ++ [inl (f z)] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal7@{x:=x0; y:=y1}) y) (x ++ [inr (g z)] ++ y0)	goal 8 (ID 1302) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal7@{x:=x0; y:=y1}) y) (x ++ [inl mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal7@{x:=x0; y:=y1}) y) (x ++ y0)	goal 9 (ID 1304) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal7@{x:=x0; y:=y1}) y) (x ++ [inr mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal7@{x:=x0; y:=y1}) y) (x ++ y0)	4 goals (ID 2207)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y : Words	  ============================	  forall (y0 : Words) (k1 k2 : K),	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ (inr k1 :: [inr k2]) ++ y0) =	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr (k1 * k2)] ++ y0)		goal 2 (ID 2208) is:	 forall (y0 : Words) (z : G),	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl (f z)] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr (g z)] ++ y0)	goal 3 (ID 2209) is:	 forall y0 : Words,	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl mon_unit] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	goal 4 (ID 2210) is:	 forall y0 : Words,	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr mon_unit] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	1 goal (ID 2207)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y : Words	  ============================	  forall (y0 : Words) (k1 k2 : K),	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ (inr k1 :: [inr k2]) ++ y0) =	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr (k1 * k2)] ++ y0)	1 goal (ID 2267)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y, z : Words	  k1, k2 : K	  ============================	  (fun y0 : Words => amal_eta (x ++ y0)) (y ++ (inr k1 :: [inr k2]) ++ z) =	  (fun y0 : Words => amal_eta (x ++ y0)) (y ++ [inr (k1 * k2)] ++ z)	";
            responses[i]=data;
          

            i = 333;
            data = "3 focused goals (shelved: 2) (ID 2294)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y, z : Words	  k1, k2 : K	  ============================	  x ++ y ++ (inr k1 :: [inr k2]) ++ z = ?Goal7		goal 2 (ID 2295) is:	 amal_eta ?Goal7 = amal_eta ?Goal10	goal 3 (ID 2297) is:	 x ++ y ++ [inr (k1 * k2)] ++ z = ?Goal10	";
            responses[i]=data;
          

            i = 334;
            data = "1 goal (ID 2295)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y, z : Words	  k1, k2 : K	  ============================	  amal_eta ((x ++ y) ++ (inr k1 :: [inr k2]) ++ z) =	  amal_eta ((x ++ y) ++ [inr (k1 * k2)] ++ z)	";
            responses[i]=data;
          

            i = 335;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	8 goals		goal 1 (ID 2208) is:	 forall (y0 : Words) (z : G),	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl (f z)] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr (g z)] ++ y0)	goal 2 (ID 2209) is:	 forall y0 : Words,	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl mon_unit] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	goal 3 (ID 2210) is:	 forall y0 : Words,	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr mon_unit] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	goal 4 (ID 1296) is:	 forall (y : amal_type) (y0 : Words) (h1 h2 : H),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h0 h3 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h0 h3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1}) y)	   (x ++ (inl h1 :: [inl h2]) ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h0 h3 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h0 h3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1}) y) (x ++ [inl (h1 * h2)] ++ y0)	goal 5 (ID 1298) is:	 forall (y : amal_type) (y0 : Words) (k1 k2 : K),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k0 k3 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k0 k3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1}) y)	   (x ++ (inr k1 :: [inr k2]) ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k0 k3 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k0 k3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1}) y) (x ++ [inr (k1 * k2)] ++ y0)	goal 6 (ID 1300) is:	 forall (y : amal_type) (y0 : Words) (z : G),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1}) y) (x ++ [inl (f z)] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1}) y) (x ++ [inr (g z)] ++ y0)	goal 7 (ID 1302) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1}) y) (x ++ [inl mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1}) y) (x ++ y0)	goal 8 (ID 1304) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1}) y) (x ++ [inr mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal6@{x:=x0; y:=y1}) y) (x ++ y0)	3 goals (ID 2208)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y : Words	  ============================	  forall (y0 : Words) (z : G),	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl (f z)] ++ y0) =	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr (g z)] ++ y0)		goal 2 (ID 2209) is:	 forall y0 : Words,	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl mon_unit] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	goal 3 (ID 2210) is:	 forall y0 : Words,	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr mon_unit] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	1 goal (ID 2208)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y : Words	  ============================	  forall (y0 : Words) (z : G),	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl (f z)] ++ y0) =	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr (g z)] ++ y0)	1 goal (ID 2319)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y, w : Words	  z : G	  ============================	  (fun y0 : Words => amal_eta (x ++ y0)) (y ++ [inl (f z)] ++ w) =	  (fun y0 : Words => amal_eta (x ++ y0)) (y ++ [inr (g z)] ++ w)	";
            responses[i]=data;
          

            i = 336;
            data = "3 focused goals (shelved: 2) (ID 2346)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y, w : Words	  z : G	  ============================	  x ++ y ++ [inl (f z)] ++ w = ?Goal6		goal 2 (ID 2347) is:	 amal_eta ?Goal6 = amal_eta ?Goal9	goal 3 (ID 2349) is:	 x ++ y ++ [inr (g z)] ++ w = ?Goal9	";
            responses[i]=data;
          

            i = 337;
            data = "1 goal (ID 2347)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y, w : Words	  z : G	  ============================	  amal_eta ((x ++ y) ++ [inl (f z)] ++ w) =	  amal_eta ((x ++ y) ++ [inr (g z)] ++ w)	";
            responses[i]=data;
          

            i = 338;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	7 goals		goal 1 (ID 2209) is:	 forall y0 : Words,	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl mon_unit] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	goal 2 (ID 2210) is:	 forall y0 : Words,	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr mon_unit] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	goal 3 (ID 1296) is:	 forall (y : amal_type) (y0 : Words) (h1 h2 : H),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h0 h3 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h0 h3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1}) y)	   (x ++ (inl h1 :: [inl h2]) ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h0 h3 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h0 h3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1}) y) (x ++ [inl (h1 * h2)] ++ y0)	goal 4 (ID 1298) is:	 forall (y : amal_type) (y0 : Words) (k1 k2 : K),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k0 k3 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k0 k3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1}) y)	   (x ++ (inr k1 :: [inr k2]) ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k0 k3 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k0 k3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1}) y) (x ++ [inr (k1 * k2)] ++ y0)	goal 5 (ID 1300) is:	 forall (y : amal_type) (y0 : Words) (z : G),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1}) y) (x ++ [inl (f z)] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1}) y) (x ++ [inr (g z)] ++ y0)	goal 6 (ID 1302) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1}) y) (x ++ [inl mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1}) y) (x ++ y0)	goal 7 (ID 1304) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1}) y) (x ++ [inr mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1})	    (fun y1 : Words => ?Goal5@{x:=x0; y:=y1}) y) (x ++ y0)	2 goals (ID 2209)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y : Words	  ============================	  forall y0 : Words,	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl mon_unit] ++ y0) =	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)		goal 2 (ID 2210) is:	 forall y0 : Words,	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr mon_unit] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	1 goal (ID 2209)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y : Words	  ============================	  forall y0 : Words,	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inl mon_unit] ++ y0) =	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	1 goal (ID 2350)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y, z : Words	  ============================	  (fun y0 : Words => amal_eta (x ++ y0)) (y ++ [inl mon_unit] ++ z) =	  (fun y0 : Words => amal_eta (x ++ y0)) (y ++ z)	";
            responses[i]=data;
          

            i = 339;
            data = "3 focused goals (shelved: 2) (ID 2377)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y, z : Words	  ============================	  x ++ y ++ [inl mon_unit] ++ z = ?Goal5		goal 2 (ID 2378) is:	 amal_eta ?Goal5 = amal_eta ?Goal8	goal 3 (ID 2380) is:	 x ++ y ++ z = ?Goal8	";
            responses[i]=data;
          

            i = 340;
            data = "1 goal (ID 2378)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y, z : Words	  ============================	  amal_eta ((x ++ y) ++ [inl mon_unit] ++ z) = amal_eta ((x ++ y) ++ z)	";
            responses[i]=data;
          

            i = 341;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	";
            responses[i]=data;
          

            i = 342;
            data = "6 goals		goal 1 (ID 2210) is:	 forall y0 : Words,	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr mon_unit] ++ y0) =	 (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	goal 2 (ID 1296) is:	 forall (y : amal_type) (y0 : Words) (h1 h2 : H),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h0 h3 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h0 h3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1}) y)	   (x ++ (inl h1 :: [inl h2]) ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h0 h3 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h0 h3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1}) y) (x ++ [inl (h1 * h2)] ++ y0)	goal 3 (ID 1298) is:	 forall (y : amal_type) (y0 : Words) (k1 k2 : K),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k0 k3 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k0 k3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1}) y)	   (x ++ (inr k1 :: [inr k2]) ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k0 k3 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k0 k3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1}) y) (x ++ [inr (k1 * k2)] ++ y0)	goal 4 (ID 1300) is:	 forall (y : amal_type) (y0 : Words) (z : G),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	      amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1}) y) (x ++ [inl (f z)] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	      amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1}) y) (x ++ [inr (g z)] ++ y0)	goal 5 (ID 1302) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1}) y) (x ++ [inl mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1}) y) (x ++ y0)	goal 6 (ID 1304) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1}) y) (x ++ [inr mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 : Words => ?Goal4@{x:=x0; y:=y1}) y) (x ++ y0)	1 goal (ID 2210)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y : Words	  ============================	  forall y0 : Words,	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr mon_unit] ++ y0) =	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	1 goal (ID 2210)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y : Words	  ============================	  forall y0 : Words,	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ [inr mon_unit] ++ y0) =	  (fun y1 : Words => amal_eta (x ++ y1)) (y ++ y0)	1 goal (ID 2381)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y, z : Words	  ============================	  (fun y0 : Words => amal_eta (x ++ y0)) (y ++ [inr mon_unit] ++ z) =	  (fun y0 : Words => amal_eta (x ++ y0)) (y ++ z)	3 focused goals (shelved: 2) (ID 2408)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y, z : Words	  ============================	  x ++ y ++ [inr mon_unit] ++ z = ?Goal4		goal 2 (ID 2409) is:	 amal_eta ?Goal4 = amal_eta ?Goal7	goal 3 (ID 2411) is:	 x ++ y ++ z = ?Goal7	";
            responses[i]=data;
          

            i = 343;
            data = "1 goal (ID 2409)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  y, z : Words	  ============================	  amal_eta ((x ++ y) ++ [inr mon_unit] ++ z) = amal_eta ((x ++ y) ++ z)	";
            responses[i]=data;
          

            i = 344;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	";
            responses[i]=data;
          

            i = 345;
            data = "5 goals		goal 1 (ID 1296) is:	 forall (y : amal_type) (y0 : Words) (h1 h2 : H),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h0 h3 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h0 h3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ (inl h1 :: [inl h2]) ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h0 h3 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h0 h3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inl (h1 * h2)] ++ y0)	goal 2 (ID 1298) is:	 forall (y : amal_type) (y0 : Words) (k1 k2 : K),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k0 k3 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k0 k3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ (inr k1 :: [inr k2]) ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k0 k3 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k0 k3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inr (k1 * k2)] ++ y0)	goal 3 (ID 1300) is:	 forall (y : amal_type) (y0 : Words) (z : G),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	      amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	      amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    y) (x ++ [inl (f z)] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	      amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	      amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    y) (x ++ [inr (g z)] ++ y0)	goal 4 (ID 1302) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inl mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	goal 5 (ID 1304) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inr mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	5 goals		goal 1 (ID 1296) is:	 forall (y : amal_type) (y0 : Words) (h1 h2 : H),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h0 h3 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h0 h3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ (inl h1 :: [inl h2]) ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h0 h3 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h0 h3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inl (h1 * h2)] ++ y0)	goal 2 (ID 1298) is:	 forall (y : amal_type) (y0 : Words) (k1 k2 : K),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k0 k3 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k0 k3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ (inr k1 :: [inr k2]) ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k0 k3 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k0 k3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inr (k1 * k2)] ++ y0)	goal 3 (ID 1300) is:	 forall (y : amal_type) (y0 : Words) (z : G),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	      amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	      amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    y) (x ++ [inl (f z)] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	      amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	      amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    y) (x ++ [inr (g z)] ++ y0)	goal 4 (ID 1302) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inl mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	goal 5 (ID 1304) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inr mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	5 goals (ID 1296)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  forall (y : amal_type) (y0 : Words) (h1 h2 : H),	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h0 h3 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h0 h3) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	     (fun (y1 z : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ (inl h1 :: [inl h2]) ++ y0) =	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h0 h3 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h0 h3) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	     (fun (y1 z : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ [inl (h1 * h2)] ++ y0)		goal 2 (ID 1298) is:	 forall (y : amal_type) (y0 : Words) (k1 k2 : K),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k0 k3 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k0 k3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ (inr k1 :: [inr k2]) ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k0 k3 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k0 k3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inr (k1 * k2)] ++ y0)	goal 3 (ID 1300) is:	 forall (y : amal_type) (y0 : Words) (z : G),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	      amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	      amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    y) (x ++ [inl (f z)] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	      amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	      amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    y) (x ++ [inr (g z)] ++ y0)	goal 4 (ID 1302) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inl mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	goal 5 (ID 1304) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inr mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	1 goal (ID 1296)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  forall (y : amal_type) (y0 : Words) (h1 h2 : H),	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h0 h3 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h0 h3) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	     (fun (y1 z : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ (inl h1 :: [inl h2]) ++ y0) =	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h0 h3 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h0 :: [inl h3]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h0 h3) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h0 * h3)] ++ z))^)	     (fun (y1 z : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ [inl (h1 * h2)] ++ y0)	1 goal (ID 2417)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  forall r : amal_type,	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y0 : Words => amal_eta (x0 ++ y0))	     (fun (y0 z : Words) (h0 h3 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ((inl h0 :: [inl h3]) ++ z)) @	       amal_mu_H (x0 ++ y0) z h0 h3) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inl (h0 * h3)] ++ z))^)	     (fun (y0 z : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ((inr k1 :: [inr k2]) ++ z)) @	       amal_mu_K (x0 ++ y0) z k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inr (k1 * k2)] ++ z))^)	     (fun (y0 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y0) w z) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inr (g z)] ++ w))^)	     (fun y0 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y0) z) @ ap amal_eta (word_concat_w_ww x0 y0 z)^)	     (fun y0 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y0) z) @ ap amal_eta (word_concat_w_ww x0 y0 z)^)	     r) (x ++ (inl h1 :: [inl h2]) ++ y) =	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y0 : Words => amal_eta (x0 ++ y0))	     (fun (y0 z : Words) (h0 h3 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ((inl h0 :: [inl h3]) ++ z)) @	       amal_mu_H (x0 ++ y0) z h0 h3) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inl (h0 * h3)] ++ z))^)	     (fun (y0 z : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ((inr k1 :: [inr k2]) ++ z)) @	       amal_mu_K (x0 ++ y0) z k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inr (k1 * k2)] ++ z))^)	     (fun (y0 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y0) w z) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inr (g z)] ++ w))^)	     (fun y0 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y0) z) @ ap amal_eta (word_concat_w_ww x0 y0 z)^)	     (fun y0 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y0) z) @ ap amal_eta (word_concat_w_ww x0 y0 z)^)	     r) (x ++ [inl (h1 * h2)] ++ y)	";
            responses[i]=data;
          

            i = 346;
            data = "";
            responses[i]=data;
          

            i = 347;
            data = "";
            responses[i]=data;
          

            i = 348;
            data = "1 goal (ID 2489)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  forall w : Words,	  Coeq_ind (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	    (fun y0 : Words => amal_eta ((x ++ inl h1 :: inl h2 :: y) ++ y0))	    (fun a : pc1 + pc2 + pc3 + pc4 + pc5 =>	     dp_path_transport^-1	       match	         a as s	         return	           (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	              (cglue s) (amal_eta ((x ++ inl h1 :: inl h2 :: y) ++ map1 s))	              (amal_eta ((x ++ inl h1 :: inl h2 :: y) ++ map2 s)))	       with	       | inl a0 =>	           match	             a0 as s	             return	               (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                  (cglue (inl s))	                  (amal_eta	                     ((x ++ inl h1 :: inl h2 :: y) ++	                      match s with	                      | inl (inl (inl a3)) => m1 a3	                      | inl (inl (inr b)) => m2 b	                      | inl (inr b) => m3 b	                      | inr b => m4 b	                      end))	                  (amal_eta	                     ((x ++ inl h1 :: inl h2 :: y) ++	                      match s with	                      | inl (inl (inl a3)) => m1' a3	                      | inl (inl (inr b)) => m2' b	                      | inl (inr b) => m3' b	                      | inr b => m4' b	                      end)))	           with	           | inl a1 =>	               match	                 a1 as s	                 return	                   (DPath	                      (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                      (cglue (inl (inl s)))	                      (amal_eta	                         ((x ++ inl h1 :: inl h2 :: y) ++	                          match s with	                          | inl (inl a3) => m1 a3	                          | inl (inr b) => m2 b	                          | inr b => m3 b	                          end))	                      (amal_eta	                         ((x ++ inl h1 :: inl h2 :: y) ++	                          match s with	                          | inl (inl a3) => m1' a3	                          | inl (inr b) => m2' b	                          | inr b => m3' b	                          end)))	               with	               | inl a2 =>	                   match	                     a2 as s	                     return	                       (DPath	                          (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                          (cglue (inl (inl (inl s))))	                          (amal_eta	                             ((x ++ inl h1 :: inl h2 :: y) ++	                              match s with	                              | inl a3 => m1 a3	                              | inr b => m2 b	                              end))	                          (amal_eta	                             ((x ++ inl h1 :: inl h2 :: y) ++	                              match s with	                              | inl a3 => m1' a3	                              | inr b => m2' b	                              end)))	                   with	                   | inl a3 =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inl	                                        (fst (fst (fst a3)),	                                        snd (fst (fst a3)), 	                                        snd (fst a3), 	                                        snd a3))))) as p in 	                          (_ = y0)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inl h1 :: inl h2 :: y) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inl h1 :: inl h2 :: y) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inl h1 :: inl h2 :: y) ++	                              fst (fst (fst a3)) ++	                              inl (snd (fst (fst a3)) * snd (fst a3))	                              :: snd a3)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww	                                   (x ++ inl h1 :: inl h2 :: y)	                                   (fst (fst (fst a3)))	                                   (inl (snd (fst (fst a3)))	                                    :: inl (snd (fst a3)) :: snd a3)) @	                              amal_mu_H	                                ((x ++ inl h1 :: inl h2 :: y) ++	                                 fst (fst (fst a3))) 	                                (snd a3) (snd (fst (fst a3))) 	                                (snd (fst a3))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inl h1 :: inl h2 :: y)	                                  (fst (fst (fst a3)))	                                  (inl (snd (fst (fst a3)) * snd (fst a3))	                                   :: snd a3))^))	                   | inr b =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inr	                                        (fst (fst (fst b)),	                                        snd (fst (fst b)), 	                                        snd (fst b), 	                                        snd b))))) as p in 	                          (_ = y0)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inl h1 :: inl h2 :: y) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inl h1 :: inl h2 :: y) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inl h1 :: inl h2 :: y) ++	                              fst (fst (fst b)) ++	                              inr (snd (fst (fst b)) * snd (fst b)) :: snd b)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww	                                   (x ++ inl h1 :: inl h2 :: y)	                                   (fst (fst (fst b)))	                                   (inr (snd (fst (fst b)))	                                    :: inr (snd (fst b)) :: snd b)) @	                              amal_mu_K	                                ((x ++ inl h1 :: inl h2 :: y) ++	                                 fst (fst (fst b))) 	                                (snd b) (snd (fst (fst b))) 	                                (snd (fst b))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inl h1 :: inl h2 :: y)	                                  (fst (fst (fst b)))	                                  (inr (snd (fst (fst b)) * snd (fst b))	                                   :: snd b))^))	                   end	               | inr b =>	                   (match	                      cglue	                        (inl (inl (inr (fst (fst b), snd (fst b), snd b))))	                      as p in (_ = y0)	                      return	                        (forall v : Trunc 0 (Coeq map1 map2),	                         DPath	                           (fun _ : Coeq map1 map2 =>	                            Trunc 0 (Coeq map1 map2)) p	                           (amal_eta	                              ((x ++ inl h1 :: inl h2 :: y) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v <~>	                         DPath	                           (fun _ : Trunc 0 (Coeq map1 map2) =>	                            Trunc 0 (Coeq map1 map2)) 	                           (ap tr p)	                           (amal_eta	                              ((x ++ inl h1 :: inl h2 :: y) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v)	                    with	                    | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                    end	                      (amal_eta	                         ((x ++ inl h1 :: inl h2 :: y) ++	                          fst (fst b) ++ inr (g (snd (fst b))) :: snd b)))^-1	                     (dp_const	                        ((ap amal_eta	                            (word_concat_w_ww (x ++ inl h1 :: inl h2 :: y)	                               (fst (fst b)) (inl (f (snd (fst b))) :: snd b)) @	                          amal_tau	                            ((x ++ inl h1 :: inl h2 :: y) ++ fst (fst b))	                            (snd b) (snd (fst b))) @	                         ap amal_eta	                           (word_concat_w_ww (x ++ inl h1 :: inl h2 :: y)	                              (fst (fst b)) (inr (g (snd (fst b))) :: snd b))^))	               end	           | inr b =>	               (match	                  cglue (inl (inr (fst b, snd b))) as p in (_ = y0)	                  return	                    (forall v : Trunc 0 (Coeq map1 map2),	                     DPath	                       (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                       (amal_eta	                          ((x ++ inl h1 :: inl h2 :: y) ++	                           fst b ++ inl mon_unit :: snd b)) v <~>	                     DPath	                       (fun _ : Trunc 0 (Coeq map1 map2) =>	                        Trunc 0 (Coeq map1 map2)) 	                       (ap tr p)	                       (amal_eta	                          ((x ++ inl h1 :: inl h2 :: y) ++	                           fst b ++ inl mon_unit :: snd b)) v)	                with	                | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                end	                  (amal_eta ((x ++ inl h1 :: inl h2 :: y) ++ fst b ++ snd b)))^-1	                 (dp_const	                    ((ap amal_eta	                        (word_concat_w_ww (x ++ inl h1 :: inl h2 :: y)	                           (fst b) (inl mon_unit :: snd b)) @	                      amal_omega_H ((x ++ inl h1 :: inl h2 :: y) ++ fst b)	                        (snd b)) @	                     ap amal_eta	                       (word_concat_w_ww (x ++ inl h1 :: inl h2 :: y) 	                          (fst b) (snd b))^))	           end	       | inr b =>	           (match	              cglue (inr (fst b, snd b)) as p in (_ = y0)	              return	                (forall v : Trunc 0 (Coeq map1 map2),	                 DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                   (amal_eta	                      ((x ++ inl h1 :: inl h2 :: y) ++	                       fst b ++ inr mon_unit :: snd b)) v <~>	                 DPath	                   (fun _ : Trunc 0 (Coeq map1 map2) =>	                    Trunc 0 (Coeq map1 map2)) (ap tr p)	                   (amal_eta	                      ((x ++ inl h1 :: inl h2 :: y) ++	                       fst b ++ inr mon_unit :: snd b)) v)	            with	            | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	            end (amal_eta ((x ++ inl h1 :: inl h2 :: y) ++ fst b ++ snd b)))^-1	             (dp_const	                ((ap amal_eta	                    (word_concat_w_ww (x ++ inl h1 :: inl h2 :: y) 	                       (fst b) (inr mon_unit :: snd b)) @	                  amal_omega_K ((x ++ inl h1 :: inl h2 :: y) ++ fst b)	                    (snd b)) @	                 ap amal_eta	                   (word_concat_w_ww (x ++ inl h1 :: inl h2 :: y) 	                      (fst b) (snd b))^))	       end) (coeq w) =	  Coeq_ind (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	    (fun y0 : Words => amal_eta ((x ++ inl (h1 * h2) :: y) ++ y0))	    (fun a : pc1 + pc2 + pc3 + pc4 + pc5 =>	     dp_path_transport^-1	       match	         a as s	         return	           (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	              (cglue s) (amal_eta ((x ++ inl (h1 * h2) :: y) ++ map1 s))	              (amal_eta ((x ++ inl (h1 * h2) :: y) ++ map2 s)))	       with	       | inl a0 =>	           match	             a0 as s	             return	               (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                  (cglue (inl s))	                  (amal_eta	                     ((x ++ inl (h1 * h2) :: y) ++	                      match s with	                      | inl (inl (inl a3)) => m1 a3	                      | inl (inl (inr b)) => m2 b	                      | inl (inr b) => m3 b	                      | inr b => m4 b	                      end))	                  (amal_eta	                     ((x ++ inl (h1 * h2) :: y) ++	                      match s with	                      | inl (inl (inl a3)) => m1' a3	                      | inl (inl (inr b)) => m2' b	                      | inl (inr b) => m3' b	                      | inr b => m4' b	                      end)))	           with	           | inl a1 =>	               match	                 a1 as s	                 return	                   (DPath	                      (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                      (cglue (inl (inl s)))	                      (amal_eta	                         ((x ++ inl (h1 * h2) :: y) ++	                          match s with	                          | inl (inl a3) => m1 a3	                          | inl (inr b) => m2 b	                          | inr b => m3 b	                          end))	                      (amal_eta	                         ((x ++ inl (h1 * h2) :: y) ++	                          match s with	                          | inl (inl a3) => m1' a3	                          | inl (inr b) => m2' b	                          | inr b => m3' b	                          end)))	               with	               | inl a2 =>	                   match	                     a2 as s	                     return	                       (DPath	                          (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                          (cglue (inl (inl (inl s))))	                          (amal_eta	                             ((x ++ inl (h1 * h2) :: y) ++	                              match s with	                              | inl a3 => m1 a3	                              | inr b => m2 b	                              end))	                          (amal_eta	                             ((x ++ inl (h1 * h2) :: y) ++	                              match s with	                              | inl a3 => m1' a3	                              | inr b => m2' b	                              end)))	                   with	                   | inl a3 =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inl	                                        (fst (fst (fst a3)),	                                        snd (fst (fst a3)), 	                                        snd (fst a3), 	                                        snd a3))))) as p in 	                          (_ = y0)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inl (h1 * h2) :: y) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inl (h1 * h2) :: y) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inl (h1 * h2) :: y) ++	                              fst (fst (fst a3)) ++	                              inl (snd (fst (fst a3)) * snd (fst a3))	                              :: snd a3)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ inl (h1 * h2) :: y)	                                   (fst (fst (fst a3)))	                                   (inl (snd (fst (fst a3)))	                                    :: inl (snd (fst a3)) :: snd a3)) @	                              amal_mu_H	                                ((x ++ inl (h1 * h2) :: y) ++	                                 fst (fst (fst a3))) 	                                (snd a3) (snd (fst (fst a3))) 	                                (snd (fst a3))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inl (h1 * h2) :: y)	                                  (fst (fst (fst a3)))	                                  (inl (snd (fst (fst a3)) * snd (fst a3))	                                   :: snd a3))^))	                   | inr b =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inr	                                        (fst (fst (fst b)),	                                        snd (fst (fst b)), 	                                        snd (fst b), 	                                        snd b))))) as p in 	                          (_ = y0)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inl (h1 * h2) :: y) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inl (h1 * h2) :: y) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inl (h1 * h2) :: y) ++	                              fst (fst (fst b)) ++	                              inr (snd (fst (fst b)) * snd (fst b)) :: snd b)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ inl (h1 * h2) :: y)	                                   (fst (fst (fst b)))	                                   (inr (snd (fst (fst b)))	                                    :: inr (snd (fst b)) :: snd b)) @	                              amal_mu_K	                                ((x ++ inl (h1 * h2) :: y) ++	                                 fst (fst (fst b))) 	                                (snd b) (snd (fst (fst b))) 	                                (snd (fst b))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inl (h1 * h2) :: y)	                                  (fst (fst (fst b)))	                                  (inr (snd (fst (fst b)) * snd (fst b))	                                   :: snd b))^))	                   end	               | inr b =>	                   (match	                      cglue	                        (inl (inl (inr (fst (fst b), snd (fst b), snd b))))	                      as p in (_ = y0)	                      return	                        (forall v : Trunc 0 (Coeq map1 map2),	                         DPath	                           (fun _ : Coeq map1 map2 =>	                            Trunc 0 (Coeq map1 map2)) p	                           (amal_eta	                              ((x ++ inl (h1 * h2) :: y) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v <~>	                         DPath	                           (fun _ : Trunc 0 (Coeq map1 map2) =>	                            Trunc 0 (Coeq map1 map2)) 	                           (ap tr p)	                           (amal_eta	                              ((x ++ inl (h1 * h2) :: y) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v)	                    with	                    | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                    end	                      (amal_eta	                         ((x ++ inl (h1 * h2) :: y) ++	                          fst (fst b) ++ inr (g (snd (fst b))) :: snd b)))^-1	                     (dp_const	                        ((ap amal_eta	                            (word_concat_w_ww (x ++ inl (h1 * h2) :: y)	                               (fst (fst b)) (inl (f (snd (fst b))) :: snd b)) @	                          amal_tau ((x ++ inl (h1 * h2) :: y) ++ fst (fst b))	                            (snd b) (snd (fst b))) @	                         ap amal_eta	                           (word_concat_w_ww (x ++ inl (h1 * h2) :: y)	                              (fst (fst b)) (inr (g (snd (fst b))) :: snd b))^))	               end	           | inr b =>	               (match	                  cglue (inl (inr (fst b, snd b))) as p in (_ = y0)	                  return	                    (forall v : Trunc 0 (Coeq map1 map2),	                     DPath	                       (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                       (amal_eta	                          ((x ++ inl (h1 * h2) :: y) ++	                           fst b ++ inl mon_unit :: snd b)) v <~>	                     DPath	                       (fun _ : Trunc 0 (Coeq map1 map2) =>	                        Trunc 0 (Coeq map1 map2)) 	                       (ap tr p)	                       (amal_eta	                          ((x ++ inl (h1 * h2) :: y) ++	                           fst b ++ inl mon_unit :: snd b)) v)	                with	                | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                end (amal_eta ((x ++ inl (h1 * h2) :: y) ++ fst b ++ snd b)))^-1	                 (dp_const	                    ((ap amal_eta	                        (word_concat_w_ww (x ++ inl (h1 * h2) :: y) 	                           (fst b) (inl mon_unit :: snd b)) @	                      amal_omega_H ((x ++ inl (h1 * h2) :: y) ++ fst b)	                        (snd b)) @	                     ap amal_eta	                       (word_concat_w_ww (x ++ inl (h1 * h2) :: y) 	                          (fst b) (snd b))^))	           end	       | inr b =>	           (match	              cglue (inr (fst b, snd b)) as p in (_ = y0)	              return	                (forall v : Trunc 0 (Coeq map1 map2),	                 DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                   (amal_eta	                      ((x ++ inl (h1 * h2) :: y) ++	                       fst b ++ inr mon_unit :: snd b)) v <~>	                 DPath	                   (fun _ : Trunc 0 (Coeq map1 map2) =>	                    Trunc 0 (Coeq map1 map2)) (ap tr p)	                   (amal_eta	                      ((x ++ inl (h1 * h2) :: y) ++	                       fst b ++ inr mon_unit :: snd b)) v)	            with	            | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	            end (amal_eta ((x ++ inl (h1 * h2) :: y) ++ fst b ++ snd b)))^-1	             (dp_const	                ((ap amal_eta	                    (word_concat_w_ww (x ++ inl (h1 * h2) :: y) 	                       (fst b) (inr mon_unit :: snd b)) @	                  amal_omega_K ((x ++ inl (h1 * h2) :: y) ++ fst b) (snd b)) @	                 ap amal_eta	                   (word_concat_w_ww (x ++ inl (h1 * h2) :: y) 	                      (fst b) (snd b))^))	       end) (coeq w)	1 goal (ID 2512)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  z : Words	  ============================	  amal_eta ((x ++ (inl h1 :: [inl h2]) ++ y) ++ z) =	  amal_eta ((x ++ [inl (h1 * h2)] ++ y) ++ z)	3 focused goals (shelved: 2) (ID 2539)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  z : Words	  ============================	  ?Goal3 = (x ++ (inl h1 :: [inl h2]) ++ y) ++ z		goal 2 (ID 2540) is:	 amal_eta ?Goal3 = amal_eta ?Goal6	goal 3 (ID 2542) is:	 ?Goal6 = (x ++ [inl (h1 * h2)] ++ y) ++ z	1 goal (ID 2540)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  z : Words	  ============================	  amal_eta (x ++ ((inl h1 :: [inl h2]) ++ y) ++ z) =	  amal_eta (x ++ ([inl (h1 * h2)] ++ y) ++ z)	";
            responses[i]=data;
          

            i = 349;
            data = "3 focused goals (shelved: 2) (ID 2579)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  z : Words	  ============================	  ?Goal3 = ((inl h1 :: [inl h2]) ++ y) ++ z		goal 2 (ID 2580) is:	 amal_eta (x ++ ?Goal3) = amal_eta (x ++ ?Goal6)	goal 3 (ID 2582) is:	 ?Goal6 = ([inl (h1 * h2)] ++ y) ++ z	";
            responses[i]=data;
          

            i = 350;
            data = "1 goal (ID 2580)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  z : Words	  ============================	  amal_eta (x ++ (inl h1 :: [inl h2]) ++ y ++ z) =	  amal_eta (x ++ [inl (h1 * h2)] ++ y ++ z)	";
            responses[i]=data;
          

            i = 351;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	";
            responses[i]=data;
          

            i = 352;
            data = "4 goals		goal 1 (ID 1298) is:	 forall (y : amal_type) (y0 : Words) (k1 k2 : K),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k0 k3 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k0 k3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ (inr k1 :: [inr k2]) ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k0 k3 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k0 k3) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inr (k1 * k2)] ++ y0)	goal 2 (ID 1300) is:	 forall (y : amal_type) (y0 : Words) (z : G),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	      amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	      amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    y) (x ++ [inl (f z)] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	      amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	      amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    y) (x ++ [inr (g z)] ++ y0)	goal 3 (ID 1302) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inl mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	goal 4 (ID 1304) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inr mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	4 goals (ID 1298)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  forall (y : amal_type) (y0 : Words) (k1 k2 : K),	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	     (fun (y1 z : Words) (k0 k3 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k0 k3) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ (inr k1 :: [inr k2]) ++ y0) =	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	     (fun (y1 z : Words) (k0 k3 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k0 k3) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ [inr (k1 * k2)] ++ y0)		goal 2 (ID 1300) is:	 forall (y : amal_type) (y0 : Words) (z : G),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	      amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	      amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    y) (x ++ [inl (f z)] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	      amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	      amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    y) (x ++ [inr (g z)] ++ y0)	goal 3 (ID 1302) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inl mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	goal 4 (ID 1304) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inr mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	1 goal (ID 1298)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  forall (y : amal_type) (y0 : Words) (k1 k2 : K),	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	     (fun (y1 z : Words) (k0 k3 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k0 k3) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ (inr k1 :: [inr k2]) ++ y0) =	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	     (fun (y1 z : Words) (k0 k3 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k0 :: [inr k3]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k0 k3) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k0 * k3)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ [inr (k1 * k2)] ++ y0)	1 goal (ID 2588)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  forall r : amal_type,	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y0 : Words => amal_eta (x0 ++ y0))	     (fun (y0 z : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ((inl h1 :: [inl h2]) ++ z)) @	       amal_mu_H (x0 ++ y0) z h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inl (h1 * h2)] ++ z))^)	     (fun (y0 z : Words) (k0 k3 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ((inr k0 :: [inr k3]) ++ z)) @	       amal_mu_K (x0 ++ y0) z k0 k3) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inr (k0 * k3)] ++ z))^)	     (fun (y0 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y0) w z) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inr (g z)] ++ w))^)	     (fun y0 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y0) z) @ ap amal_eta (word_concat_w_ww x0 y0 z)^)	     (fun y0 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y0) z) @ ap amal_eta (word_concat_w_ww x0 y0 z)^)	     r) (x ++ (inr k1 :: [inr k2]) ++ y) =	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y0 : Words => amal_eta (x0 ++ y0))	     (fun (y0 z : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ((inl h1 :: [inl h2]) ++ z)) @	       amal_mu_H (x0 ++ y0) z h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inl (h1 * h2)] ++ z))^)	     (fun (y0 z : Words) (k0 k3 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ((inr k0 :: [inr k3]) ++ z)) @	       amal_mu_K (x0 ++ y0) z k0 k3) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inr (k0 * k3)] ++ z))^)	     (fun (y0 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y0) w z) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inr (g z)] ++ w))^)	     (fun y0 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y0) z) @ ap amal_eta (word_concat_w_ww x0 y0 z)^)	     (fun y0 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y0) z) @ ap amal_eta (word_concat_w_ww x0 y0 z)^)	     r) (x ++ [inr (k1 * k2)] ++ y)	";
            responses[i]=data;
          

            i = 353;
            data = "";
            responses[i]=data;
          

            i = 354;
            data = "";
            responses[i]=data;
          

            i = 355;
            data = "1 goal (ID 2660)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  forall w : Words,	  Coeq_ind (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	    (fun y0 : Words => amal_eta ((x ++ inr k1 :: inr k2 :: y) ++ y0))	    (fun a : pc1 + pc2 + pc3 + pc4 + pc5 =>	     dp_path_transport^-1	       match	         a as s	         return	           (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	              (cglue s) (amal_eta ((x ++ inr k1 :: inr k2 :: y) ++ map1 s))	              (amal_eta ((x ++ inr k1 :: inr k2 :: y) ++ map2 s)))	       with	       | inl a0 =>	           match	             a0 as s	             return	               (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                  (cglue (inl s))	                  (amal_eta	                     ((x ++ inr k1 :: inr k2 :: y) ++	                      match s with	                      | inl (inl (inl a3)) => m1 a3	                      | inl (inl (inr b)) => m2 b	                      | inl (inr b) => m3 b	                      | inr b => m4 b	                      end))	                  (amal_eta	                     ((x ++ inr k1 :: inr k2 :: y) ++	                      match s with	                      | inl (inl (inl a3)) => m1' a3	                      | inl (inl (inr b)) => m2' b	                      | inl (inr b) => m3' b	                      | inr b => m4' b	                      end)))	           with	           | inl a1 =>	               match	                 a1 as s	                 return	                   (DPath	                      (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                      (cglue (inl (inl s)))	                      (amal_eta	                         ((x ++ inr k1 :: inr k2 :: y) ++	                          match s with	                          | inl (inl a3) => m1 a3	                          | inl (inr b) => m2 b	                          | inr b => m3 b	                          end))	                      (amal_eta	                         ((x ++ inr k1 :: inr k2 :: y) ++	                          match s with	                          | inl (inl a3) => m1' a3	                          | inl (inr b) => m2' b	                          | inr b => m3' b	                          end)))	               with	               | inl a2 =>	                   match	                     a2 as s	                     return	                       (DPath	                          (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                          (cglue (inl (inl (inl s))))	                          (amal_eta	                             ((x ++ inr k1 :: inr k2 :: y) ++	                              match s with	                              | inl a3 => m1 a3	                              | inr b => m2 b	                              end))	                          (amal_eta	                             ((x ++ inr k1 :: inr k2 :: y) ++	                              match s with	                              | inl a3 => m1' a3	                              | inr b => m2' b	                              end)))	                   with	                   | inl a3 =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inl	                                        (fst (fst (fst a3)),	                                        snd (fst (fst a3)), 	                                        snd (fst a3), 	                                        snd a3))))) as p in 	                          (_ = y0)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inr k1 :: inr k2 :: y) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inr k1 :: inr k2 :: y) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inr k1 :: inr k2 :: y) ++	                              fst (fst (fst a3)) ++	                              inl (snd (fst (fst a3)) * snd (fst a3))	                              :: snd a3)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww	                                   (x ++ inr k1 :: inr k2 :: y)	                                   (fst (fst (fst a3)))	                                   (inl (snd (fst (fst a3)))	                                    :: inl (snd (fst a3)) :: snd a3)) @	                              amal_mu_H	                                ((x ++ inr k1 :: inr k2 :: y) ++	                                 fst (fst (fst a3))) 	                                (snd a3) (snd (fst (fst a3))) 	                                (snd (fst a3))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inr k1 :: inr k2 :: y)	                                  (fst (fst (fst a3)))	                                  (inl (snd (fst (fst a3)) * snd (fst a3))	                                   :: snd a3))^))	                   | inr b =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inr	                                        (fst (fst (fst b)),	                                        snd (fst (fst b)), 	                                        snd (fst b), 	                                        snd b))))) as p in 	                          (_ = y0)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inr k1 :: inr k2 :: y) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inr k1 :: inr k2 :: y) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inr k1 :: inr k2 :: y) ++	                              fst (fst (fst b)) ++	                              inr (snd (fst (fst b)) * snd (fst b)) :: snd b)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww	                                   (x ++ inr k1 :: inr k2 :: y)	                                   (fst (fst (fst b)))	                                   (inr (snd (fst (fst b)))	                                    :: inr (snd (fst b)) :: snd b)) @	                              amal_mu_K	                                ((x ++ inr k1 :: inr k2 :: y) ++	                                 fst (fst (fst b))) 	                                (snd b) (snd (fst (fst b))) 	                                (snd (fst b))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inr k1 :: inr k2 :: y)	                                  (fst (fst (fst b)))	                                  (inr (snd (fst (fst b)) * snd (fst b))	                                   :: snd b))^))	                   end	               | inr b =>	                   (match	                      cglue	                        (inl (inl (inr (fst (fst b), snd (fst b), snd b))))	                      as p in (_ = y0)	                      return	                        (forall v : Trunc 0 (Coeq map1 map2),	                         DPath	                           (fun _ : Coeq map1 map2 =>	                            Trunc 0 (Coeq map1 map2)) p	                           (amal_eta	                              ((x ++ inr k1 :: inr k2 :: y) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v <~>	                         DPath	                           (fun _ : Trunc 0 (Coeq map1 map2) =>	                            Trunc 0 (Coeq map1 map2)) 	                           (ap tr p)	                           (amal_eta	                              ((x ++ inr k1 :: inr k2 :: y) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v)	                    with	                    | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                    end	                      (amal_eta	                         ((x ++ inr k1 :: inr k2 :: y) ++	                          fst (fst b) ++ inr (g (snd (fst b))) :: snd b)))^-1	                     (dp_const	                        ((ap amal_eta	                            (word_concat_w_ww (x ++ inr k1 :: inr k2 :: y)	                               (fst (fst b)) (inl (f (snd (fst b))) :: snd b)) @	                          amal_tau	                            ((x ++ inr k1 :: inr k2 :: y) ++ fst (fst b))	                            (snd b) (snd (fst b))) @	                         ap amal_eta	                           (word_concat_w_ww (x ++ inr k1 :: inr k2 :: y)	                              (fst (fst b)) (inr (g (snd (fst b))) :: snd b))^))	               end	           | inr b =>	               (match	                  cglue (inl (inr (fst b, snd b))) as p in (_ = y0)	                  return	                    (forall v : Trunc 0 (Coeq map1 map2),	                     DPath	                       (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                       (amal_eta	                          ((x ++ inr k1 :: inr k2 :: y) ++	                           fst b ++ inl mon_unit :: snd b)) v <~>	                     DPath	                       (fun _ : Trunc 0 (Coeq map1 map2) =>	                        Trunc 0 (Coeq map1 map2)) 	                       (ap tr p)	                       (amal_eta	                          ((x ++ inr k1 :: inr k2 :: y) ++	                           fst b ++ inl mon_unit :: snd b)) v)	                with	                | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                end	                  (amal_eta ((x ++ inr k1 :: inr k2 :: y) ++ fst b ++ snd b)))^-1	                 (dp_const	                    ((ap amal_eta	                        (word_concat_w_ww (x ++ inr k1 :: inr k2 :: y)	                           (fst b) (inl mon_unit :: snd b)) @	                      amal_omega_H ((x ++ inr k1 :: inr k2 :: y) ++ fst b)	                        (snd b)) @	                     ap amal_eta	                       (word_concat_w_ww (x ++ inr k1 :: inr k2 :: y) 	                          (fst b) (snd b))^))	           end	       | inr b =>	           (match	              cglue (inr (fst b, snd b)) as p in (_ = y0)	              return	                (forall v : Trunc 0 (Coeq map1 map2),	                 DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                   (amal_eta	                      ((x ++ inr k1 :: inr k2 :: y) ++	                       fst b ++ inr mon_unit :: snd b)) v <~>	                 DPath	                   (fun _ : Trunc 0 (Coeq map1 map2) =>	                    Trunc 0 (Coeq map1 map2)) (ap tr p)	                   (amal_eta	                      ((x ++ inr k1 :: inr k2 :: y) ++	                       fst b ++ inr mon_unit :: snd b)) v)	            with	            | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	            end (amal_eta ((x ++ inr k1 :: inr k2 :: y) ++ fst b ++ snd b)))^-1	             (dp_const	                ((ap amal_eta	                    (word_concat_w_ww (x ++ inr k1 :: inr k2 :: y) 	                       (fst b) (inr mon_unit :: snd b)) @	                  amal_omega_K ((x ++ inr k1 :: inr k2 :: y) ++ fst b)	                    (snd b)) @	                 ap amal_eta	                   (word_concat_w_ww (x ++ inr k1 :: inr k2 :: y) 	                      (fst b) (snd b))^))	       end) (coeq w) =	  Coeq_ind (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	    (fun y0 : Words => amal_eta ((x ++ inr (k1 * k2) :: y) ++ y0))	    (fun a : pc1 + pc2 + pc3 + pc4 + pc5 =>	     dp_path_transport^-1	       match	         a as s	         return	           (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	              (cglue s) (amal_eta ((x ++ inr (k1 * k2) :: y) ++ map1 s))	              (amal_eta ((x ++ inr (k1 * k2) :: y) ++ map2 s)))	       with	       | inl a0 =>	           match	             a0 as s	             return	               (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                  (cglue (inl s))	                  (amal_eta	                     ((x ++ inr (k1 * k2) :: y) ++	                      match s with	                      | inl (inl (inl a3)) => m1 a3	                      | inl (inl (inr b)) => m2 b	                      | inl (inr b) => m3 b	                      | inr b => m4 b	                      end))	                  (amal_eta	                     ((x ++ inr (k1 * k2) :: y) ++	                      match s with	                      | inl (inl (inl a3)) => m1' a3	                      | inl (inl (inr b)) => m2' b	                      | inl (inr b) => m3' b	                      | inr b => m4' b	                      end)))	           with	           | inl a1 =>	               match	                 a1 as s	                 return	                   (DPath	                      (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                      (cglue (inl (inl s)))	                      (amal_eta	                         ((x ++ inr (k1 * k2) :: y) ++	                          match s with	                          | inl (inl a3) => m1 a3	                          | inl (inr b) => m2 b	                          | inr b => m3 b	                          end))	                      (amal_eta	                         ((x ++ inr (k1 * k2) :: y) ++	                          match s with	                          | inl (inl a3) => m1' a3	                          | inl (inr b) => m2' b	                          | inr b => m3' b	                          end)))	               with	               | inl a2 =>	                   match	                     a2 as s	                     return	                       (DPath	                          (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                          (cglue (inl (inl (inl s))))	                          (amal_eta	                             ((x ++ inr (k1 * k2) :: y) ++	                              match s with	                              | inl a3 => m1 a3	                              | inr b => m2 b	                              end))	                          (amal_eta	                             ((x ++ inr (k1 * k2) :: y) ++	                              match s with	                              | inl a3 => m1' a3	                              | inr b => m2' b	                              end)))	                   with	                   | inl a3 =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inl	                                        (fst (fst (fst a3)),	                                        snd (fst (fst a3)), 	                                        snd (fst a3), 	                                        snd a3))))) as p in 	                          (_ = y0)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inr (k1 * k2) :: y) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inr (k1 * k2) :: y) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inr (k1 * k2) :: y) ++	                              fst (fst (fst a3)) ++	                              inl (snd (fst (fst a3)) * snd (fst a3))	                              :: snd a3)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ inr (k1 * k2) :: y)	                                   (fst (fst (fst a3)))	                                   (inl (snd (fst (fst a3)))	                                    :: inl (snd (fst a3)) :: snd a3)) @	                              amal_mu_H	                                ((x ++ inr (k1 * k2) :: y) ++	                                 fst (fst (fst a3))) 	                                (snd a3) (snd (fst (fst a3))) 	                                (snd (fst a3))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inr (k1 * k2) :: y)	                                  (fst (fst (fst a3)))	                                  (inl (snd (fst (fst a3)) * snd (fst a3))	                                   :: snd a3))^))	                   | inr b =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inr	                                        (fst (fst (fst b)),	                                        snd (fst (fst b)), 	                                        snd (fst b), 	                                        snd b))))) as p in 	                          (_ = y0)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inr (k1 * k2) :: y) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inr (k1 * k2) :: y) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inr (k1 * k2) :: y) ++	                              fst (fst (fst b)) ++	                              inr (snd (fst (fst b)) * snd (fst b)) :: snd b)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ inr (k1 * k2) :: y)	                                   (fst (fst (fst b)))	                                   (inr (snd (fst (fst b)))	                                    :: inr (snd (fst b)) :: snd b)) @	                              amal_mu_K	                                ((x ++ inr (k1 * k2) :: y) ++	                                 fst (fst (fst b))) 	                                (snd b) (snd (fst (fst b))) 	                                (snd (fst b))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inr (k1 * k2) :: y)	                                  (fst (fst (fst b)))	                                  (inr (snd (fst (fst b)) * snd (fst b))	                                   :: snd b))^))	                   end	               | inr b =>	                   (match	                      cglue	                        (inl (inl (inr (fst (fst b), snd (fst b), snd b))))	                      as p in (_ = y0)	                      return	                        (forall v : Trunc 0 (Coeq map1 map2),	                         DPath	                           (fun _ : Coeq map1 map2 =>	                            Trunc 0 (Coeq map1 map2)) p	                           (amal_eta	                              ((x ++ inr (k1 * k2) :: y) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v <~>	                         DPath	                           (fun _ : Trunc 0 (Coeq map1 map2) =>	                            Trunc 0 (Coeq map1 map2)) 	                           (ap tr p)	                           (amal_eta	                              ((x ++ inr (k1 * k2) :: y) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v)	                    with	                    | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                    end	                      (amal_eta	                         ((x ++ inr (k1 * k2) :: y) ++	                          fst (fst b) ++ inr (g (snd (fst b))) :: snd b)))^-1	                     (dp_const	                        ((ap amal_eta	                            (word_concat_w_ww (x ++ inr (k1 * k2) :: y)	                               (fst (fst b)) (inl (f (snd (fst b))) :: snd b)) @	                          amal_tau ((x ++ inr (k1 * k2) :: y) ++ fst (fst b))	                            (snd b) (snd (fst b))) @	                         ap amal_eta	                           (word_concat_w_ww (x ++ inr (k1 * k2) :: y)	                              (fst (fst b)) (inr (g (snd (fst b))) :: snd b))^))	               end	           | inr b =>	               (match	                  cglue (inl (inr (fst b, snd b))) as p in (_ = y0)	                  return	                    (forall v : Trunc 0 (Coeq map1 map2),	                     DPath	                       (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                       (amal_eta	                          ((x ++ inr (k1 * k2) :: y) ++	                           fst b ++ inl mon_unit :: snd b)) v <~>	                     DPath	                       (fun _ : Trunc 0 (Coeq map1 map2) =>	                        Trunc 0 (Coeq map1 map2)) 	                       (ap tr p)	                       (amal_eta	                          ((x ++ inr (k1 * k2) :: y) ++	                           fst b ++ inl mon_unit :: snd b)) v)	                with	                | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                end (amal_eta ((x ++ inr (k1 * k2) :: y) ++ fst b ++ snd b)))^-1	                 (dp_const	                    ((ap amal_eta	                        (word_concat_w_ww (x ++ inr (k1 * k2) :: y) 	                           (fst b) (inl mon_unit :: snd b)) @	                      amal_omega_H ((x ++ inr (k1 * k2) :: y) ++ fst b)	                        (snd b)) @	                     ap amal_eta	                       (word_concat_w_ww (x ++ inr (k1 * k2) :: y) 	                          (fst b) (snd b))^))	           end	       | inr b =>	           (match	              cglue (inr (fst b, snd b)) as p in (_ = y0)	              return	                (forall v : Trunc 0 (Coeq map1 map2),	                 DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                   (amal_eta	                      ((x ++ inr (k1 * k2) :: y) ++	                       fst b ++ inr mon_unit :: snd b)) v <~>	                 DPath	                   (fun _ : Trunc 0 (Coeq map1 map2) =>	                    Trunc 0 (Coeq map1 map2)) (ap tr p)	                   (amal_eta	                      ((x ++ inr (k1 * k2) :: y) ++	                       fst b ++ inr mon_unit :: snd b)) v)	            with	            | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	            end (amal_eta ((x ++ inr (k1 * k2) :: y) ++ fst b ++ snd b)))^-1	             (dp_const	                ((ap amal_eta	                    (word_concat_w_ww (x ++ inr (k1 * k2) :: y) 	                       (fst b) (inr mon_unit :: snd b)) @	                  amal_omega_K ((x ++ inr (k1 * k2) :: y) ++ fst b) (snd b)) @	                 ap amal_eta	                   (word_concat_w_ww (x ++ inr (k1 * k2) :: y) 	                      (fst b) (snd b))^))	       end) (coeq w)	1 goal (ID 2683)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  z : Words	  ============================	  amal_eta ((x ++ (inr k1 :: [inr k2]) ++ y) ++ z) =	  amal_eta ((x ++ [inr (k1 * k2)] ++ y) ++ z)	3 focused goals (shelved: 2) (ID 2710)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  z : Words	  ============================	  ?Goal2 = (x ++ (inr k1 :: [inr k2]) ++ y) ++ z		goal 2 (ID 2711) is:	 amal_eta ?Goal2 = amal_eta ?Goal5	goal 3 (ID 2713) is:	 ?Goal5 = (x ++ [inr (k1 * k2)] ++ y) ++ z	1 goal (ID 2711)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  z : Words	  ============================	  amal_eta (x ++ ((inr k1 :: [inr k2]) ++ y) ++ z) =	  amal_eta (x ++ ([inr (k1 * k2)] ++ y) ++ z)	";
            responses[i]=data;
          

            i = 356;
            data = "3 focused goals (shelved: 2) (ID 2750)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  z : Words	  ============================	  ?Goal2 = ((inr k1 :: [inr k2]) ++ y) ++ z		goal 2 (ID 2751) is:	 amal_eta (x ++ ?Goal2) = amal_eta (x ++ ?Goal5)	goal 3 (ID 2753) is:	 ?Goal5 = ([inr (k1 * k2)] ++ y) ++ z	";
            responses[i]=data;
          

            i = 357;
            data = "1 goal (ID 2751)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  z : Words	  ============================	  amal_eta (x ++ (inr k1 :: [inr k2]) ++ y ++ z) =	  amal_eta (x ++ [inr (k1 * k2)] ++ y ++ z)	";
            responses[i]=data;
          

            i = 358;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 goals		goal 1 (ID 1300) is:	 forall (y : amal_type) (y0 : Words) (z : G),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	      amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	      amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    y) (x ++ [inl (f z)] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z0 : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	      amal_mu_H (x0 ++ y1) z0 h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	    (fun (y1 z0 : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	      amal_mu_K (x0 ++ y1) z0 k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	    (fun (y1 w : Words) (z0 : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	      amal_tau (x0 ++ y1) w z0) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	      amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    (fun y1 z0 : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	      amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	    y) (x ++ [inr (g z)] ++ y0)	goal 2 (ID 1302) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inl mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	goal 3 (ID 1304) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inr mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	3 goals (ID 1300)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  forall (y : amal_type) (y0 : Words) (z : G),	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z0 : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	       amal_mu_H (x0 ++ y1) z0 h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	     (fun (y1 z0 : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	       amal_mu_K (x0 ++ y1) z0 k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	     (fun (y1 w : Words) (z0 : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	       amal_tau (x0 ++ y1) w z0) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	     (fun y1 z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	       amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	     (fun y1 z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	       amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	     y) (x ++ [inl (f z)] ++ y0) =	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z0 : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	       amal_mu_H (x0 ++ y1) z0 h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	     (fun (y1 z0 : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	       amal_mu_K (x0 ++ y1) z0 k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	     (fun (y1 w : Words) (z0 : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	       amal_tau (x0 ++ y1) w z0) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	     (fun y1 z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	       amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	     (fun y1 z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	       amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	     y) (x ++ [inr (g z)] ++ y0)		goal 2 (ID 1302) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inl mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	goal 3 (ID 1304) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inr mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	1 goal (ID 1300)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  forall (y : amal_type) (y0 : Words) (z : G),	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z0 : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	       amal_mu_H (x0 ++ y1) z0 h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	     (fun (y1 z0 : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	       amal_mu_K (x0 ++ y1) z0 k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	     (fun (y1 w : Words) (z0 : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	       amal_tau (x0 ++ y1) w z0) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	     (fun y1 z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	       amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	     (fun y1 z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	       amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	     y) (x ++ [inl (f z)] ++ y0) =	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z0 : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z0)) @	       amal_mu_H (x0 ++ y1) z0 h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z0))^)	     (fun (y1 z0 : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z0)) @	       amal_mu_K (x0 ++ y1) z0 k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z0))^)	     (fun (y1 w : Words) (z0 : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z0)] ++ w)) @	       amal_tau (x0 ++ y1) w z0) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z0)] ++ w))^)	     (fun y1 z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z0)) @	       amal_omega_H (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	     (fun y1 z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z0)) @	       amal_omega_K (x0 ++ y1) z0) @ ap amal_eta (word_concat_w_ww x0 y1 z0)^)	     y) (x ++ [inr (g z)] ++ y0)	1 goal (ID 2758)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  ============================	  forall r : amal_type,	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y0 : Words => amal_eta (x0 ++ y0))	     (fun (y0 z0 : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ((inl h1 :: [inl h2]) ++ z0)) @	       amal_mu_H (x0 ++ y0) z0 h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inl (h1 * h2)] ++ z0))^)	     (fun (y0 z0 : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ((inr k1 :: [inr k2]) ++ z0)) @	       amal_mu_K (x0 ++ y0) z0 k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inr (k1 * k2)] ++ z0))^)	     (fun (y0 w : Words) (z0 : G) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inl (f z0)] ++ w)) @	       amal_tau (x0 ++ y0) w z0) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inr (g z0)] ++ w))^)	     (fun y0 z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inl mon_unit] ++ z0)) @	       amal_omega_H (x0 ++ y0) z0) @ ap amal_eta (word_concat_w_ww x0 y0 z0)^)	     (fun y0 z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inr mon_unit] ++ z0)) @	       amal_omega_K (x0 ++ y0) z0) @ ap amal_eta (word_concat_w_ww x0 y0 z0)^)	     r) (x ++ [inl (f z)] ++ y) =	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y0 : Words => amal_eta (x0 ++ y0))	     (fun (y0 z0 : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ((inl h1 :: [inl h2]) ++ z0)) @	       amal_mu_H (x0 ++ y0) z0 h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inl (h1 * h2)] ++ z0))^)	     (fun (y0 z0 : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ((inr k1 :: [inr k2]) ++ z0)) @	       amal_mu_K (x0 ++ y0) z0 k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inr (k1 * k2)] ++ z0))^)	     (fun (y0 w : Words) (z0 : G) =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inl (f z0)] ++ w)) @	       amal_tau (x0 ++ y0) w z0) @	      ap amal_eta (word_concat_w_ww x0 y0 ([inr (g z0)] ++ w))^)	     (fun y0 z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inl mon_unit] ++ z0)) @	       amal_omega_H (x0 ++ y0) z0) @ ap amal_eta (word_concat_w_ww x0 y0 z0)^)	     (fun y0 z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y0 ([inr mon_unit] ++ z0)) @	       amal_omega_K (x0 ++ y0) z0) @ ap amal_eta (word_concat_w_ww x0 y0 z0)^)	     r) (x ++ [inr (g z)] ++ y)	";
            responses[i]=data;
          

            i = 359;
            data = "";
            responses[i]=data;
          

            i = 360;
            data = "";
            responses[i]=data;
          

            i = 361;
            data = "";
            responses[i]=data;
          

            i = 362;
            data = "";
            responses[i]=data;
          

            i = 363;
            data = "1 goal (ID 2830)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  ============================	  forall w : Words,	  Coeq_ind (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	    (fun y0 : Words => amal_eta ((x ++ inl (f z) :: y) ++ y0))	    (fun a : pc1 + pc2 + pc3 + pc4 + pc5 =>	     dp_path_transport^-1	       match	         a as s	         return	           (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	              (cglue s) (amal_eta ((x ++ inl (f z) :: y) ++ map1 s))	              (amal_eta ((x ++ inl (f z) :: y) ++ map2 s)))	       with	       | inl a0 =>	           match	             a0 as s	             return	               (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                  (cglue (inl s))	                  (amal_eta	                     ((x ++ inl (f z) :: y) ++	                      match s with	                      | inl (inl (inl a3)) => m1 a3	                      | inl (inl (inr b)) => m2 b	                      | inl (inr b) => m3 b	                      | inr b => m4 b	                      end))	                  (amal_eta	                     ((x ++ inl (f z) :: y) ++	                      match s with	                      | inl (inl (inl a3)) => m1' a3	                      | inl (inl (inr b)) => m2' b	                      | inl (inr b) => m3' b	                      | inr b => m4' b	                      end)))	           with	           | inl a1 =>	               match	                 a1 as s	                 return	                   (DPath	                      (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                      (cglue (inl (inl s)))	                      (amal_eta	                         ((x ++ inl (f z) :: y) ++	                          match s with	                          | inl (inl a3) => m1 a3	                          | inl (inr b) => m2 b	                          | inr b => m3 b	                          end))	                      (amal_eta	                         ((x ++ inl (f z) :: y) ++	                          match s with	                          | inl (inl a3) => m1' a3	                          | inl (inr b) => m2' b	                          | inr b => m3' b	                          end)))	               with	               | inl a2 =>	                   match	                     a2 as s	                     return	                       (DPath	                          (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                          (cglue (inl (inl (inl s))))	                          (amal_eta	                             ((x ++ inl (f z) :: y) ++	                              match s with	                              | inl a3 => m1 a3	                              | inr b => m2 b	                              end))	                          (amal_eta	                             ((x ++ inl (f z) :: y) ++	                              match s with	                              | inl a3 => m1' a3	                              | inr b => m2' b	                              end)))	                   with	                   | inl a3 =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inl	                                        (fst (fst (fst a3)),	                                        snd (fst (fst a3)), 	                                        snd (fst a3), 	                                        snd a3))))) as p in 	                          (_ = y0)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inl (f z) :: y) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inl (f z) :: y) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inl (f z) :: y) ++	                              fst (fst (fst a3)) ++	                              inl (snd (fst (fst a3)) * snd (fst a3))	                              :: snd a3)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ inl (f z) :: y) 	                                   (fst (fst (fst a3)))	                                   (inl (snd (fst (fst a3)))	                                    :: inl (snd (fst a3)) :: snd a3)) @	                              amal_mu_H	                                ((x ++ inl (f z) :: y) ++ fst (fst (fst a3)))	                                (snd a3) (snd (fst (fst a3))) 	                                (snd (fst a3))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inl (f z) :: y)	                                  (fst (fst (fst a3)))	                                  (inl (snd (fst (fst a3)) * snd (fst a3))	                                   :: snd a3))^))	                   | inr b =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inr	                                        (fst (fst (fst b)),	                                        snd (fst (fst b)), 	                                        snd (fst b), 	                                        snd b))))) as p in 	                          (_ = y0)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inl (f z) :: y) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inl (f z) :: y) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inl (f z) :: y) ++	                              fst (fst (fst b)) ++	                              inr (snd (fst (fst b)) * snd (fst b)) :: snd b)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ inl (f z) :: y) 	                                   (fst (fst (fst b)))	                                   (inr (snd (fst (fst b)))	                                    :: inr (snd (fst b)) :: snd b)) @	                              amal_mu_K	                                ((x ++ inl (f z) :: y) ++ fst (fst (fst b)))	                                (snd b) (snd (fst (fst b))) 	                                (snd (fst b))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inl (f z) :: y)	                                  (fst (fst (fst b)))	                                  (inr (snd (fst (fst b)) * snd (fst b))	                                   :: snd b))^))	                   end	               | inr b =>	                   (match	                      cglue	                        (inl (inl (inr (fst (fst b), snd (fst b), snd b))))	                      as p in (_ = y0)	                      return	                        (forall v : Trunc 0 (Coeq map1 map2),	                         DPath	                           (fun _ : Coeq map1 map2 =>	                            Trunc 0 (Coeq map1 map2)) p	                           (amal_eta	                              ((x ++ inl (f z) :: y) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v <~>	                         DPath	                           (fun _ : Trunc 0 (Coeq map1 map2) =>	                            Trunc 0 (Coeq map1 map2)) 	                           (ap tr p)	                           (amal_eta	                              ((x ++ inl (f z) :: y) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v)	                    with	                    | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                    end	                      (amal_eta	                         ((x ++ inl (f z) :: y) ++	                          fst (fst b) ++ inr (g (snd (fst b))) :: snd b)))^-1	                     (dp_const	                        ((ap amal_eta	                            (word_concat_w_ww (x ++ inl (f z) :: y)	                               (fst (fst b)) (inl (f (snd (fst b))) :: snd b)) @	                          amal_tau ((x ++ inl (f z) :: y) ++ fst (fst b))	                            (snd b) (snd (fst b))) @	                         ap amal_eta	                           (word_concat_w_ww (x ++ inl (f z) :: y)	                              (fst (fst b)) (inr (g (snd (fst b))) :: snd b))^))	               end	           | inr b =>	               (match	                  cglue (inl (inr (fst b, snd b))) as p in (_ = y0)	                  return	                    (forall v : Trunc 0 (Coeq map1 map2),	                     DPath	                       (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                       (amal_eta	                          ((x ++ inl (f z) :: y) ++	                           fst b ++ inl mon_unit :: snd b)) v <~>	                     DPath	                       (fun _ : Trunc 0 (Coeq map1 map2) =>	                        Trunc 0 (Coeq map1 map2)) 	                       (ap tr p)	                       (amal_eta	                          ((x ++ inl (f z) :: y) ++	                           fst b ++ inl mon_unit :: snd b)) v)	                with	                | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                end (amal_eta ((x ++ inl (f z) :: y) ++ fst b ++ snd b)))^-1	                 (dp_const	                    ((ap amal_eta	                        (word_concat_w_ww (x ++ inl (f z) :: y) 	                           (fst b) (inl mon_unit :: snd b)) @	                      amal_omega_H ((x ++ inl (f z) :: y) ++ fst b) (snd b)) @	                     ap amal_eta	                       (word_concat_w_ww (x ++ inl (f z) :: y) 	                          (fst b) (snd b))^))	           end	       | inr b =>	           (match	              cglue (inr (fst b, snd b)) as p in (_ = y0)	              return	                (forall v : Trunc 0 (Coeq map1 map2),	                 DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                   (amal_eta	                      ((x ++ inl (f z) :: y) ++	                       fst b ++ inr mon_unit :: snd b)) v <~>	                 DPath	                   (fun _ : Trunc 0 (Coeq map1 map2) =>	                    Trunc 0 (Coeq map1 map2)) (ap tr p)	                   (amal_eta	                      ((x ++ inl (f z) :: y) ++	                       fst b ++ inr mon_unit :: snd b)) v)	            with	            | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	            end (amal_eta ((x ++ inl (f z) :: y) ++ fst b ++ snd b)))^-1	             (dp_const	                ((ap amal_eta	                    (word_concat_w_ww (x ++ inl (f z) :: y) 	                       (fst b) (inr mon_unit :: snd b)) @	                  amal_omega_K ((x ++ inl (f z) :: y) ++ fst b) (snd b)) @	                 ap amal_eta	                   (word_concat_w_ww (x ++ inl (f z) :: y) (fst b) (snd b))^))	       end) (coeq w) =	  Coeq_ind (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	    (fun y0 : Words => amal_eta ((x ++ inr (g z) :: y) ++ y0))	    (fun a : pc1 + pc2 + pc3 + pc4 + pc5 =>	     dp_path_transport^-1	       match	         a as s	         return	           (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	              (cglue s) (amal_eta ((x ++ inr (g z) :: y) ++ map1 s))	              (amal_eta ((x ++ inr (g z) :: y) ++ map2 s)))	       with	       | inl a0 =>	           match	             a0 as s	             return	               (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                  (cglue (inl s))	                  (amal_eta	                     ((x ++ inr (g z) :: y) ++	                      match s with	                      | inl (inl (inl a3)) => m1 a3	                      | inl (inl (inr b)) => m2 b	                      | inl (inr b) => m3 b	                      | inr b => m4 b	                      end))	                  (amal_eta	                     ((x ++ inr (g z) :: y) ++	                      match s with	                      | inl (inl (inl a3)) => m1' a3	                      | inl (inl (inr b)) => m2' b	                      | inl (inr b) => m3' b	                      | inr b => m4' b	                      end)))	           with	           | inl a1 =>	               match	                 a1 as s	                 return	                   (DPath	                      (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                      (cglue (inl (inl s)))	                      (amal_eta	                         ((x ++ inr (g z) :: y) ++	                          match s with	                          | inl (inl a3) => m1 a3	                          | inl (inr b) => m2 b	                          | inr b => m3 b	                          end))	                      (amal_eta	                         ((x ++ inr (g z) :: y) ++	                          match s with	                          | inl (inl a3) => m1' a3	                          | inl (inr b) => m2' b	                          | inr b => m3' b	                          end)))	               with	               | inl a2 =>	                   match	                     a2 as s	                     return	                       (DPath	                          (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                          (cglue (inl (inl (inl s))))	                          (amal_eta	                             ((x ++ inr (g z) :: y) ++	                              match s with	                              | inl a3 => m1 a3	                              | inr b => m2 b	                              end))	                          (amal_eta	                             ((x ++ inr (g z) :: y) ++	                              match s with	                              | inl a3 => m1' a3	                              | inr b => m2' b	                              end)))	                   with	                   | inl a3 =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inl	                                        (fst (fst (fst a3)),	                                        snd (fst (fst a3)), 	                                        snd (fst a3), 	                                        snd a3))))) as p in 	                          (_ = y0)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inr (g z) :: y) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inr (g z) :: y) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inr (g z) :: y) ++	                              fst (fst (fst a3)) ++	                              inl (snd (fst (fst a3)) * snd (fst a3))	                              :: snd a3)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ inr (g z) :: y) 	                                   (fst (fst (fst a3)))	                                   (inl (snd (fst (fst a3)))	                                    :: inl (snd (fst a3)) :: snd a3)) @	                              amal_mu_H	                                ((x ++ inr (g z) :: y) ++ fst (fst (fst a3)))	                                (snd a3) (snd (fst (fst a3))) 	                                (snd (fst a3))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inr (g z) :: y)	                                  (fst (fst (fst a3)))	                                  (inl (snd (fst (fst a3)) * snd (fst a3))	                                   :: snd a3))^))	                   | inr b =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inr	                                        (fst (fst (fst b)),	                                        snd (fst (fst b)), 	                                        snd (fst b), 	                                        snd b))))) as p in 	                          (_ = y0)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inr (g z) :: y) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inr (g z) :: y) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inr (g z) :: y) ++	                              fst (fst (fst b)) ++	                              inr (snd (fst (fst b)) * snd (fst b)) :: snd b)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ inr (g z) :: y) 	                                   (fst (fst (fst b)))	                                   (inr (snd (fst (fst b)))	                                    :: inr (snd (fst b)) :: snd b)) @	                              amal_mu_K	                                ((x ++ inr (g z) :: y) ++ fst (fst (fst b)))	                                (snd b) (snd (fst (fst b))) 	                                (snd (fst b))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inr (g z) :: y)	                                  (fst (fst (fst b)))	                                  (inr (snd (fst (fst b)) * snd (fst b))	                                   :: snd b))^))	                   end	               | inr b =>	                   (match	                      cglue	                        (inl (inl (inr (fst (fst b), snd (fst b), snd b))))	                      as p in (_ = y0)	                      return	                        (forall v : Trunc 0 (Coeq map1 map2),	                         DPath	                           (fun _ : Coeq map1 map2 =>	                            Trunc 0 (Coeq map1 map2)) p	                           (amal_eta	                              ((x ++ inr (g z) :: y) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v <~>	                         DPath	                           (fun _ : Trunc 0 (Coeq map1 map2) =>	                            Trunc 0 (Coeq map1 map2)) 	                           (ap tr p)	                           (amal_eta	                              ((x ++ inr (g z) :: y) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v)	                    with	                    | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                    end	                      (amal_eta	                         ((x ++ inr (g z) :: y) ++	                          fst (fst b) ++ inr (g (snd (fst b))) :: snd b)))^-1	                     (dp_const	                        ((ap amal_eta	                            (word_concat_w_ww (x ++ inr (g z) :: y)	                               (fst (fst b)) (inl (f (snd (fst b))) :: snd b)) @	                          amal_tau ((x ++ inr (g z) :: y) ++ fst (fst b))	                            (snd b) (snd (fst b))) @	                         ap amal_eta	                           (word_concat_w_ww (x ++ inr (g z) :: y)	                              (fst (fst b)) (inr (g (snd (fst b))) :: snd b))^))	               end	           | inr b =>	               (match	                  cglue (inl (inr (fst b, snd b))) as p in (_ = y0)	                  return	                    (forall v : Trunc 0 (Coeq map1 map2),	                     DPath	                       (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                       (amal_eta	                          ((x ++ inr (g z) :: y) ++	                           fst b ++ inl mon_unit :: snd b)) v <~>	                     DPath	                       (fun _ : Trunc 0 (Coeq map1 map2) =>	                        Trunc 0 (Coeq map1 map2)) 	                       (ap tr p)	                       (amal_eta	                          ((x ++ inr (g z) :: y) ++	                           fst b ++ inl mon_unit :: snd b)) v)	                with	                | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                end (amal_eta ((x ++ inr (g z) :: y) ++ fst b ++ snd b)))^-1	                 (dp_const	                    ((ap amal_eta	                        (word_concat_w_ww (x ++ inr (g z) :: y) 	                           (fst b) (inl mon_unit :: snd b)) @	                      amal_omega_H ((x ++ inr (g z) :: y) ++ fst b) (snd b)) @	                     ap amal_eta	                       (word_concat_w_ww (x ++ inr (g z) :: y) 	                          (fst b) (snd b))^))	           end	       | inr b =>	           (match	              cglue (inr (fst b, snd b)) as p in (_ = y0)	              return	                (forall v : Trunc 0 (Coeq map1 map2),	                 DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                   (amal_eta	                      ((x ++ inr (g z) :: y) ++	                       fst b ++ inr mon_unit :: snd b)) v <~>	                 DPath	                   (fun _ : Trunc 0 (Coeq map1 map2) =>	                    Trunc 0 (Coeq map1 map2)) (ap tr p)	                   (amal_eta	                      ((x ++ inr (g z) :: y) ++	                       fst b ++ inr mon_unit :: snd b)) v)	            with	            | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	            end (amal_eta ((x ++ inr (g z) :: y) ++ fst b ++ snd b)))^-1	             (dp_const	                ((ap amal_eta	                    (word_concat_w_ww (x ++ inr (g z) :: y) 	                       (fst b) (inr mon_unit :: snd b)) @	                  amal_omega_K ((x ++ inr (g z) :: y) ++ fst b) (snd b)) @	                 ap amal_eta	                   (word_concat_w_ww (x ++ inr (g z) :: y) (fst b) (snd b))^))	       end) (coeq w)	1 goal (ID 2852)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  w : Words	  ============================	  amal_eta ((x ++ [inl (f z)] ++ y) ++ w) =	  amal_eta ((x ++ [inr (g z)] ++ y) ++ w)	3 focused goals (shelved: 2) (ID 2879)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  w : Words	  ============================	  ?Goal1 = (x ++ [inl (f z)] ++ y) ++ w		goal 2 (ID 2880) is:	 amal_eta ?Goal1 = amal_eta ?Goal4	goal 3 (ID 2882) is:	 ?Goal4 = (x ++ [inr (g z)] ++ y) ++ w	1 goal (ID 2880)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  w : Words	  ============================	  amal_eta (x ++ ([inl (f z)] ++ y) ++ w) =	  amal_eta (x ++ ([inr (g z)] ++ y) ++ w)	3 focused goals (shelved: 2) (ID 2919)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  w : Words	  ============================	  ?Goal1 = ([inl (f z)] ++ y) ++ w		goal 2 (ID 2920) is:	 amal_eta (x ++ ?Goal1) = amal_eta (x ++ ?Goal4)	goal 3 (ID 2922) is:	 ?Goal4 = ([inr (g z)] ++ y) ++ w	";
            responses[i]=data;
          

            i = 364;
            data = "1 goal (ID 2920)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  w : Words	  ============================	  amal_eta (x ++ [inl (f z)] ++ y ++ w) =	  amal_eta (x ++ [inr (g z)] ++ y ++ w)	";
            responses[i]=data;
          

            i = 365;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 goals		goal 1 (ID 1302) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inl mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	goal 2 (ID 1304) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inr mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	2 goals (ID 1302)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  forall (y : amal_type) (y0 : Words),	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	     (fun (y1 z : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ [inl mon_unit] ++ y0) =	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	     (fun (y1 z : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ y0)		goal 2 (ID 1304) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inr mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	1 goal (ID 1302)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  forall (y : amal_type) (y0 : Words),	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	     (fun (y1 z : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ [inl mon_unit] ++ y0) =	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	     (fun (y1 z : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ y0)	1 goal (ID 2926)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  forall r : amal_type,	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y : Words => amal_eta (x0 ++ y))	     (fun (y z0 : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y ((inl h1 :: [inl h2]) ++ z0)) @	       amal_mu_H (x0 ++ y) z0 h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y ([inl (h1 * h2)] ++ z0))^)	     (fun (y z0 : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y ((inr k1 :: [inr k2]) ++ z0)) @	       amal_mu_K (x0 ++ y) z0 k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y ([inr (k1 * k2)] ++ z0))^)	     (fun (y w : Words) (z0 : G) =>	      (ap amal_eta (word_concat_w_ww x0 y ([inl (f z0)] ++ w)) @	       amal_tau (x0 ++ y) w z0) @	      ap amal_eta (word_concat_w_ww x0 y ([inr (g z0)] ++ w))^)	     (fun y z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y ([inl mon_unit] ++ z0)) @	       amal_omega_H (x0 ++ y) z0) @ ap amal_eta (word_concat_w_ww x0 y z0)^)	     (fun y z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y ([inr mon_unit] ++ z0)) @	       amal_omega_K (x0 ++ y) z0) @ ap amal_eta (word_concat_w_ww x0 y z0)^)	     r) (x ++ [inl mon_unit] ++ z) =	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y : Words => amal_eta (x0 ++ y))	     (fun (y z0 : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y ((inl h1 :: [inl h2]) ++ z0)) @	       amal_mu_H (x0 ++ y) z0 h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y ([inl (h1 * h2)] ++ z0))^)	     (fun (y z0 : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y ((inr k1 :: [inr k2]) ++ z0)) @	       amal_mu_K (x0 ++ y) z0 k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y ([inr (k1 * k2)] ++ z0))^)	     (fun (y w : Words) (z0 : G) =>	      (ap amal_eta (word_concat_w_ww x0 y ([inl (f z0)] ++ w)) @	       amal_tau (x0 ++ y) w z0) @	      ap amal_eta (word_concat_w_ww x0 y ([inr (g z0)] ++ w))^)	     (fun y z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y ([inl mon_unit] ++ z0)) @	       amal_omega_H (x0 ++ y) z0) @ ap amal_eta (word_concat_w_ww x0 y z0)^)	     (fun y z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y ([inr mon_unit] ++ z0)) @	       amal_omega_K (x0 ++ y) z0) @ ap amal_eta (word_concat_w_ww x0 y z0)^)	     r) (x ++ z)	";
            responses[i]=data;
          

            i = 366;
            data = "";
            responses[i]=data;
          

            i = 367;
            data = "";
            responses[i]=data;
          

            i = 368;
            data = "";
            responses[i]=data;
          

            i = 369;
            data = "1 goal (ID 2998)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  forall w : Words,	  Coeq_ind (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	    (fun y : Words => amal_eta ((x ++ inl mon_unit :: z) ++ y))	    (fun a : pc1 + pc2 + pc3 + pc4 + pc5 =>	     dp_path_transport^-1	       match	         a as s	         return	           (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	              (cglue s) (amal_eta ((x ++ inl mon_unit :: z) ++ map1 s))	              (amal_eta ((x ++ inl mon_unit :: z) ++ map2 s)))	       with	       | inl a0 =>	           match	             a0 as s	             return	               (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                  (cglue (inl s))	                  (amal_eta	                     ((x ++ inl mon_unit :: z) ++	                      match s with	                      | inl (inl (inl a3)) => m1 a3	                      | inl (inl (inr b)) => m2 b	                      | inl (inr b) => m3 b	                      | inr b => m4 b	                      end))	                  (amal_eta	                     ((x ++ inl mon_unit :: z) ++	                      match s with	                      | inl (inl (inl a3)) => m1' a3	                      | inl (inl (inr b)) => m2' b	                      | inl (inr b) => m3' b	                      | inr b => m4' b	                      end)))	           with	           | inl a1 =>	               match	                 a1 as s	                 return	                   (DPath	                      (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                      (cglue (inl (inl s)))	                      (amal_eta	                         ((x ++ inl mon_unit :: z) ++	                          match s with	                          | inl (inl a3) => m1 a3	                          | inl (inr b) => m2 b	                          | inr b => m3 b	                          end))	                      (amal_eta	                         ((x ++ inl mon_unit :: z) ++	                          match s with	                          | inl (inl a3) => m1' a3	                          | inl (inr b) => m2' b	                          | inr b => m3' b	                          end)))	               with	               | inl a2 =>	                   match	                     a2 as s	                     return	                       (DPath	                          (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                          (cglue (inl (inl (inl s))))	                          (amal_eta	                             ((x ++ inl mon_unit :: z) ++	                              match s with	                              | inl a3 => m1 a3	                              | inr b => m2 b	                              end))	                          (amal_eta	                             ((x ++ inl mon_unit :: z) ++	                              match s with	                              | inl a3 => m1' a3	                              | inr b => m2' b	                              end)))	                   with	                   | inl a3 =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inl	                                        (fst (fst (fst a3)),	                                        snd (fst (fst a3)), 	                                        snd (fst a3), 	                                        snd a3))))) as p in 	                          (_ = y)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inl mon_unit :: z) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inl mon_unit :: z) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inl mon_unit :: z) ++	                              fst (fst (fst a3)) ++	                              inl (snd (fst (fst a3)) * snd (fst a3))	                              :: snd a3)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ inl mon_unit :: z)	                                   (fst (fst (fst a3)))	                                   (inl (snd (fst (fst a3)))	                                    :: inl (snd (fst a3)) :: snd a3)) @	                              amal_mu_H	                                ((x ++ inl mon_unit :: z) ++	                                 fst (fst (fst a3))) 	                                (snd a3) (snd (fst (fst a3))) 	                                (snd (fst a3))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inl mon_unit :: z)	                                  (fst (fst (fst a3)))	                                  (inl (snd (fst (fst a3)) * snd (fst a3))	                                   :: snd a3))^))	                   | inr b =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inr	                                        (fst (fst (fst b)),	                                        snd (fst (fst b)), 	                                        snd (fst b), 	                                        snd b))))) as p in 	                          (_ = y)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inl mon_unit :: z) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inl mon_unit :: z) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inl mon_unit :: z) ++	                              fst (fst (fst b)) ++	                              inr (snd (fst (fst b)) * snd (fst b)) :: snd b)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ inl mon_unit :: z)	                                   (fst (fst (fst b)))	                                   (inr (snd (fst (fst b)))	                                    :: inr (snd (fst b)) :: snd b)) @	                              amal_mu_K	                                ((x ++ inl mon_unit :: z) ++	                                 fst (fst (fst b))) 	                                (snd b) (snd (fst (fst b))) 	                                (snd (fst b))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inl mon_unit :: z)	                                  (fst (fst (fst b)))	                                  (inr (snd (fst (fst b)) * snd (fst b))	                                   :: snd b))^))	                   end	               | inr b =>	                   (match	                      cglue	                        (inl (inl (inr (fst (fst b), snd (fst b), snd b))))	                      as p in (_ = y)	                      return	                        (forall v : Trunc 0 (Coeq map1 map2),	                         DPath	                           (fun _ : Coeq map1 map2 =>	                            Trunc 0 (Coeq map1 map2)) p	                           (amal_eta	                              ((x ++ inl mon_unit :: z) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v <~>	                         DPath	                           (fun _ : Trunc 0 (Coeq map1 map2) =>	                            Trunc 0 (Coeq map1 map2)) 	                           (ap tr p)	                           (amal_eta	                              ((x ++ inl mon_unit :: z) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v)	                    with	                    | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                    end	                      (amal_eta	                         ((x ++ inl mon_unit :: z) ++	                          fst (fst b) ++ inr (g (snd (fst b))) :: snd b)))^-1	                     (dp_const	                        ((ap amal_eta	                            (word_concat_w_ww (x ++ inl mon_unit :: z)	                               (fst (fst b)) (inl (f (snd (fst b))) :: snd b)) @	                          amal_tau ((x ++ inl mon_unit :: z) ++ fst (fst b))	                            (snd b) (snd (fst b))) @	                         ap amal_eta	                           (word_concat_w_ww (x ++ inl mon_unit :: z)	                              (fst (fst b)) (inr (g (snd (fst b))) :: snd b))^))	               end	           | inr b =>	               (match	                  cglue (inl (inr (fst b, snd b))) as p in (_ = y)	                  return	                    (forall v : Trunc 0 (Coeq map1 map2),	                     DPath	                       (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                       (amal_eta	                          ((x ++ inl mon_unit :: z) ++	                           fst b ++ inl mon_unit :: snd b)) v <~>	                     DPath	                       (fun _ : Trunc 0 (Coeq map1 map2) =>	                        Trunc 0 (Coeq map1 map2)) 	                       (ap tr p)	                       (amal_eta	                          ((x ++ inl mon_unit :: z) ++	                           fst b ++ inl mon_unit :: snd b)) v)	                with	                | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                end (amal_eta ((x ++ inl mon_unit :: z) ++ fst b ++ snd b)))^-1	                 (dp_const	                    ((ap amal_eta	                        (word_concat_w_ww (x ++ inl mon_unit :: z) 	                           (fst b) (inl mon_unit :: snd b)) @	                      amal_omega_H ((x ++ inl mon_unit :: z) ++ fst b)	                        (snd b)) @	                     ap amal_eta	                       (word_concat_w_ww (x ++ inl mon_unit :: z) 	                          (fst b) (snd b))^))	           end	       | inr b =>	           (match	              cglue (inr (fst b, snd b)) as p in (_ = y)	              return	                (forall v : Trunc 0 (Coeq map1 map2),	                 DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                   (amal_eta	                      ((x ++ inl mon_unit :: z) ++	                       fst b ++ inr mon_unit :: snd b)) v <~>	                 DPath	                   (fun _ : Trunc 0 (Coeq map1 map2) =>	                    Trunc 0 (Coeq map1 map2)) (ap tr p)	                   (amal_eta	                      ((x ++ inl mon_unit :: z) ++	                       fst b ++ inr mon_unit :: snd b)) v)	            with	            | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	            end (amal_eta ((x ++ inl mon_unit :: z) ++ fst b ++ snd b)))^-1	             (dp_const	                ((ap amal_eta	                    (word_concat_w_ww (x ++ inl mon_unit :: z) 	                       (fst b) (inr mon_unit :: snd b)) @	                  amal_omega_K ((x ++ inl mon_unit :: z) ++ fst b) (snd b)) @	                 ap amal_eta	                   (word_concat_w_ww (x ++ inl mon_unit :: z) (fst b) (snd b))^))	       end) (coeq w) =	  Coeq_ind (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	    (fun y : Words => amal_eta ((x ++ z) ++ y))	    (fun a : pc1 + pc2 + pc3 + pc4 + pc5 =>	     dp_path_transport^-1	       match	         a as s	         return	           (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	              (cglue s) (amal_eta ((x ++ z) ++ map1 s))	              (amal_eta ((x ++ z) ++ map2 s)))	       with	       | inl a0 =>	           match	             a0 as s	             return	               (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                  (cglue (inl s))	                  (amal_eta	                     ((x ++ z) ++	                      match s with	                      | inl (inl (inl a3)) => m1 a3	                      | inl (inl (inr b)) => m2 b	                      | inl (inr b) => m3 b	                      | inr b => m4 b	                      end))	                  (amal_eta	                     ((x ++ z) ++	                      match s with	                      | inl (inl (inl a3)) => m1' a3	                      | inl (inl (inr b)) => m2' b	                      | inl (inr b) => m3' b	                      | inr b => m4' b	                      end)))	           with	           | inl a1 =>	               match	                 a1 as s	                 return	                   (DPath	                      (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                      (cglue (inl (inl s)))	                      (amal_eta	                         ((x ++ z) ++	                          match s with	                          | inl (inl a3) => m1 a3	                          | inl (inr b) => m2 b	                          | inr b => m3 b	                          end))	                      (amal_eta	                         ((x ++ z) ++	                          match s with	                          | inl (inl a3) => m1' a3	                          | inl (inr b) => m2' b	                          | inr b => m3' b	                          end)))	               with	               | inl a2 =>	                   match	                     a2 as s	                     return	                       (DPath	                          (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                          (cglue (inl (inl (inl s))))	                          (amal_eta	                             ((x ++ z) ++	                              match s with	                              | inl a3 => m1 a3	                              | inr b => m2 b	                              end))	                          (amal_eta	                             ((x ++ z) ++	                              match s with	                              | inl a3 => m1' a3	                              | inr b => m2' b	                              end)))	                   with	                   | inl a3 =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inl	                                        (fst (fst (fst a3)),	                                        snd (fst (fst a3)), 	                                        snd (fst a3), 	                                        snd a3))))) as p in 	                          (_ = y)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ z) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ z) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ z) ++	                              fst (fst (fst a3)) ++	                              inl (snd (fst (fst a3)) * snd (fst a3))	                              :: snd a3)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ z) (fst (fst (fst a3)))	                                   (inl (snd (fst (fst a3)))	                                    :: inl (snd (fst a3)) :: snd a3)) @	                              amal_mu_H ((x ++ z) ++ fst (fst (fst a3)))	                                (snd a3) (snd (fst (fst a3))) 	                                (snd (fst a3))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ z)	                                  (fst (fst (fst a3)))	                                  (inl (snd (fst (fst a3)) * snd (fst a3))	                                   :: snd a3))^))	                   | inr b =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inr	                                        (fst (fst (fst b)),	                                        snd (fst (fst b)), 	                                        snd (fst b), 	                                        snd b))))) as p in 	                          (_ = y)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ z) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ z) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ z) ++	                              fst (fst (fst b)) ++	                              inr (snd (fst (fst b)) * snd (fst b)) :: snd b)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ z) (fst (fst (fst b)))	                                   (inr (snd (fst (fst b)))	                                    :: inr (snd (fst b)) :: snd b)) @	                              amal_mu_K ((x ++ z) ++ fst (fst (fst b)))	                                (snd b) (snd (fst (fst b))) 	                                (snd (fst b))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ z) 	                                  (fst (fst (fst b)))	                                  (inr (snd (fst (fst b)) * snd (fst b))	                                   :: snd b))^))	                   end	               | inr b =>	                   (match	                      cglue	                        (inl (inl (inr (fst (fst b), snd (fst b), snd b))))	                      as p in (_ = y)	                      return	                        (forall v : Trunc 0 (Coeq map1 map2),	                         DPath	                           (fun _ : Coeq map1 map2 =>	                            Trunc 0 (Coeq map1 map2)) p	                           (amal_eta	                              ((x ++ z) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v <~>	                         DPath	                           (fun _ : Trunc 0 (Coeq map1 map2) =>	                            Trunc 0 (Coeq map1 map2)) 	                           (ap tr p)	                           (amal_eta	                              ((x ++ z) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v)	                    with	                    | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                    end	                      (amal_eta	                         ((x ++ z) ++	                          fst (fst b) ++ inr (g (snd (fst b))) :: snd b)))^-1	                     (dp_const	                        ((ap amal_eta	                            (word_concat_w_ww (x ++ z) 	                               (fst (fst b)) (inl (f (snd (fst b))) :: snd b)) @	                          amal_tau ((x ++ z) ++ fst (fst b)) 	                            (snd b) (snd (fst b))) @	                         ap amal_eta	                           (word_concat_w_ww (x ++ z) 	                              (fst (fst b)) (inr (g (snd (fst b))) :: snd b))^))	               end	           | inr b =>	               (match	                  cglue (inl (inr (fst b, snd b))) as p in (_ = y)	                  return	                    (forall v : Trunc 0 (Coeq map1 map2),	                     DPath	                       (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                       (amal_eta ((x ++ z) ++ fst b ++ inl mon_unit :: snd b))	                       v <~>	                     DPath	                       (fun _ : Trunc 0 (Coeq map1 map2) =>	                        Trunc 0 (Coeq map1 map2)) 	                       (ap tr p)	                       (amal_eta ((x ++ z) ++ fst b ++ inl mon_unit :: snd b))	                       v)	                with	                | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                end (amal_eta ((x ++ z) ++ fst b ++ snd b)))^-1	                 (dp_const	                    ((ap amal_eta	                        (word_concat_w_ww (x ++ z) 	                           (fst b) (inl mon_unit :: snd b)) @	                      amal_omega_H ((x ++ z) ++ fst b) (snd b)) @	                     ap amal_eta (word_concat_w_ww (x ++ z) (fst b) (snd b))^))	           end	       | inr b =>	           (match	              cglue (inr (fst b, snd b)) as p in (_ = y)	              return	                (forall v : Trunc 0 (Coeq map1 map2),	                 DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                   (amal_eta ((x ++ z) ++ fst b ++ inr mon_unit :: snd b)) v <~>	                 DPath	                   (fun _ : Trunc 0 (Coeq map1 map2) =>	                    Trunc 0 (Coeq map1 map2)) (ap tr p)	                   (amal_eta ((x ++ z) ++ fst b ++ inr mon_unit :: snd b)) v)	            with	            | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	            end (amal_eta ((x ++ z) ++ fst b ++ snd b)))^-1	             (dp_const	                ((ap amal_eta	                    (word_concat_w_ww (x ++ z) (fst b)	                       (inr mon_unit :: snd b)) @	                  amal_omega_K ((x ++ z) ++ fst b) (snd b)) @	                 ap amal_eta (word_concat_w_ww (x ++ z) (fst b) (snd b))^))	       end) (coeq w)	1 goal (ID 3013)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  w : Words	  ============================	  amal_eta ((x ++ [inl mon_unit] ++ z) ++ w) = amal_eta ((x ++ z) ++ w)	3 focused goals (shelved: 2) (ID 3040)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  w : Words	  ============================	  ?Goal0 = (x ++ [inl mon_unit] ++ z) ++ w		goal 2 (ID 3041) is:	 amal_eta ?Goal0 = amal_eta ?Goal3	goal 3 (ID 3043) is:	 ?Goal3 = (x ++ z) ++ w	1 goal (ID 3041)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  w : Words	  ============================	  amal_eta (x ++ ([inl mon_unit] ++ z) ++ w) = amal_eta (x ++ z ++ w)	";
            responses[i]=data;
          

            i = 370;
            data = "2 focused goals (shelved: 1) (ID 3065)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  w : Words	  ============================	  ?Goal0 = ([inl mon_unit] ++ z) ++ w		goal 2 (ID 3066) is:	 amal_eta (x ++ ?Goal0) = amal_eta (x ++ z ++ w)	";
            responses[i]=data;
          

            i = 371;
            data = "1 goal (ID 3066)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  w : Words	  ============================	  amal_eta (x ++ [inl mon_unit] ++ z ++ w) = amal_eta (x ++ z ++ w)	";
            responses[i]=data;
          

            i = 372;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 1304) is:	 forall (y : amal_type) (y0 : Words),	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ [inr mon_unit] ++ y0) =	 (fun x0 : Words =>	  amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	    (fun (y1 z : Words) (h1 h2 : H) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	      amal_mu_H (x0 ++ y1) z h1 h2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	    (fun (y1 z : Words) (k1 k2 : K) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	      amal_mu_K (x0 ++ y1) z k1 k2) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	    (fun (y1 w : Words) (z : G) =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	      amal_tau (x0 ++ y1) w z) @	     ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	      amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	    (fun y1 z : Words =>	     (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	      amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^) y)	   (x ++ y0)	1 goal (ID 1304)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  forall (y : amal_type) (y0 : Words),	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	     (fun (y1 z : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ [inr mon_unit] ++ y0) =	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	     (fun (y1 z : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ y0)	1 goal (ID 1304)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  forall (y : amal_type) (y0 : Words),	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	     (fun (y1 z : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ [inr mon_unit] ++ y0) =	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y1 : Words => amal_eta (x0 ++ y1))	     (fun (y1 z : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inl h1 :: [inl h2]) ++ z)) @	       amal_mu_H (x0 ++ y1) z h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inl (h1 * h2)] ++ z))^)	     (fun (y1 z : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ((inr k1 :: [inr k2]) ++ z)) @	       amal_mu_K (x0 ++ y1) z k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (k1 * k2)] ++ z))^)	     (fun (y1 w : Words) (z : G) =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl (f z)] ++ w)) @	       amal_tau (x0 ++ y1) w z) @	      ap amal_eta (word_concat_w_ww x0 y1 ([inr (g z)] ++ w))^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inl mon_unit] ++ z)) @	       amal_omega_H (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     (fun y1 z : Words =>	      (ap amal_eta (word_concat_w_ww x0 y1 ([inr mon_unit] ++ z)) @	       amal_omega_K (x0 ++ y1) z) @ ap amal_eta (word_concat_w_ww x0 y1 z)^)	     y) (x ++ y0)	1 goal (ID 3070)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  forall r : amal_type,	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y : Words => amal_eta (x0 ++ y))	     (fun (y z0 : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y ((inl h1 :: [inl h2]) ++ z0)) @	       amal_mu_H (x0 ++ y) z0 h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y ([inl (h1 * h2)] ++ z0))^)	     (fun (y z0 : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y ((inr k1 :: [inr k2]) ++ z0)) @	       amal_mu_K (x0 ++ y) z0 k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y ([inr (k1 * k2)] ++ z0))^)	     (fun (y w : Words) (z0 : G) =>	      (ap amal_eta (word_concat_w_ww x0 y ([inl (f z0)] ++ w)) @	       amal_tau (x0 ++ y) w z0) @	      ap amal_eta (word_concat_w_ww x0 y ([inr (g z0)] ++ w))^)	     (fun y z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y ([inl mon_unit] ++ z0)) @	       amal_omega_H (x0 ++ y) z0) @ ap amal_eta (word_concat_w_ww x0 y z0)^)	     (fun y z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y ([inr mon_unit] ++ z0)) @	       amal_omega_K (x0 ++ y) z0) @ ap amal_eta (word_concat_w_ww x0 y z0)^)	     r) (x ++ [inr mon_unit] ++ z) =	  (fun x0 : Words =>	   amal_type_rec amal_type (fun y : Words => amal_eta (x0 ++ y))	     (fun (y z0 : Words) (h1 h2 : H) =>	      (ap amal_eta (word_concat_w_ww x0 y ((inl h1 :: [inl h2]) ++ z0)) @	       amal_mu_H (x0 ++ y) z0 h1 h2) @	      ap amal_eta (word_concat_w_ww x0 y ([inl (h1 * h2)] ++ z0))^)	     (fun (y z0 : Words) (k1 k2 : K) =>	      (ap amal_eta (word_concat_w_ww x0 y ((inr k1 :: [inr k2]) ++ z0)) @	       amal_mu_K (x0 ++ y) z0 k1 k2) @	      ap amal_eta (word_concat_w_ww x0 y ([inr (k1 * k2)] ++ z0))^)	     (fun (y w : Words) (z0 : G) =>	      (ap amal_eta (word_concat_w_ww x0 y ([inl (f z0)] ++ w)) @	       amal_tau (x0 ++ y) w z0) @	      ap amal_eta (word_concat_w_ww x0 y ([inr (g z0)] ++ w))^)	     (fun y z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y ([inl mon_unit] ++ z0)) @	       amal_omega_H (x0 ++ y) z0) @ ap amal_eta (word_concat_w_ww x0 y z0)^)	     (fun y z0 : Words =>	      (ap amal_eta (word_concat_w_ww x0 y ([inr mon_unit] ++ z0)) @	       amal_omega_K (x0 ++ y) z0) @ ap amal_eta (word_concat_w_ww x0 y z0)^)	     r) (x ++ z)	";
            responses[i]=data;
          

            i = 373;
            data = "";
            responses[i]=data;
          

            i = 374;
            data = "";
            responses[i]=data;
          

            i = 375;
            data = "";
            responses[i]=data;
          

            i = 376;
            data = "1 goal (ID 3142)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  forall w : Words,	  Coeq_ind (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	    (fun y : Words => amal_eta ((x ++ inr mon_unit :: z) ++ y))	    (fun a : pc1 + pc2 + pc3 + pc4 + pc5 =>	     dp_path_transport^-1	       match	         a as s	         return	           (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	              (cglue s) (amal_eta ((x ++ inr mon_unit :: z) ++ map1 s))	              (amal_eta ((x ++ inr mon_unit :: z) ++ map2 s)))	       with	       | inl a0 =>	           match	             a0 as s	             return	               (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                  (cglue (inl s))	                  (amal_eta	                     ((x ++ inr mon_unit :: z) ++	                      match s with	                      | inl (inl (inl a3)) => m1 a3	                      | inl (inl (inr b)) => m2 b	                      | inl (inr b) => m3 b	                      | inr b => m4 b	                      end))	                  (amal_eta	                     ((x ++ inr mon_unit :: z) ++	                      match s with	                      | inl (inl (inl a3)) => m1' a3	                      | inl (inl (inr b)) => m2' b	                      | inl (inr b) => m3' b	                      | inr b => m4' b	                      end)))	           with	           | inl a1 =>	               match	                 a1 as s	                 return	                   (DPath	                      (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                      (cglue (inl (inl s)))	                      (amal_eta	                         ((x ++ inr mon_unit :: z) ++	                          match s with	                          | inl (inl a3) => m1 a3	                          | inl (inr b) => m2 b	                          | inr b => m3 b	                          end))	                      (amal_eta	                         ((x ++ inr mon_unit :: z) ++	                          match s with	                          | inl (inl a3) => m1' a3	                          | inl (inr b) => m2' b	                          | inr b => m3' b	                          end)))	               with	               | inl a2 =>	                   match	                     a2 as s	                     return	                       (DPath	                          (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                          (cglue (inl (inl (inl s))))	                          (amal_eta	                             ((x ++ inr mon_unit :: z) ++	                              match s with	                              | inl a3 => m1 a3	                              | inr b => m2 b	                              end))	                          (amal_eta	                             ((x ++ inr mon_unit :: z) ++	                              match s with	                              | inl a3 => m1' a3	                              | inr b => m2' b	                              end)))	                   with	                   | inl a3 =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inl	                                        (fst (fst (fst a3)),	                                        snd (fst (fst a3)), 	                                        snd (fst a3), 	                                        snd a3))))) as p in 	                          (_ = y)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inr mon_unit :: z) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inr mon_unit :: z) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inr mon_unit :: z) ++	                              fst (fst (fst a3)) ++	                              inl (snd (fst (fst a3)) * snd (fst a3))	                              :: snd a3)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ inr mon_unit :: z)	                                   (fst (fst (fst a3)))	                                   (inl (snd (fst (fst a3)))	                                    :: inl (snd (fst a3)) :: snd a3)) @	                              amal_mu_H	                                ((x ++ inr mon_unit :: z) ++	                                 fst (fst (fst a3))) 	                                (snd a3) (snd (fst (fst a3))) 	                                (snd (fst a3))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inr mon_unit :: z)	                                  (fst (fst (fst a3)))	                                  (inl (snd (fst (fst a3)) * snd (fst a3))	                                   :: snd a3))^))	                   | inr b =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inr	                                        (fst (fst (fst b)),	                                        snd (fst (fst b)), 	                                        snd (fst b), 	                                        snd b))))) as p in 	                          (_ = y)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ inr mon_unit :: z) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ inr mon_unit :: z) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ inr mon_unit :: z) ++	                              fst (fst (fst b)) ++	                              inr (snd (fst (fst b)) * snd (fst b)) :: snd b)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ inr mon_unit :: z)	                                   (fst (fst (fst b)))	                                   (inr (snd (fst (fst b)))	                                    :: inr (snd (fst b)) :: snd b)) @	                              amal_mu_K	                                ((x ++ inr mon_unit :: z) ++	                                 fst (fst (fst b))) 	                                (snd b) (snd (fst (fst b))) 	                                (snd (fst b))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ inr mon_unit :: z)	                                  (fst (fst (fst b)))	                                  (inr (snd (fst (fst b)) * snd (fst b))	                                   :: snd b))^))	                   end	               | inr b =>	                   (match	                      cglue	                        (inl (inl (inr (fst (fst b), snd (fst b), snd b))))	                      as p in (_ = y)	                      return	                        (forall v : Trunc 0 (Coeq map1 map2),	                         DPath	                           (fun _ : Coeq map1 map2 =>	                            Trunc 0 (Coeq map1 map2)) p	                           (amal_eta	                              ((x ++ inr mon_unit :: z) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v <~>	                         DPath	                           (fun _ : Trunc 0 (Coeq map1 map2) =>	                            Trunc 0 (Coeq map1 map2)) 	                           (ap tr p)	                           (amal_eta	                              ((x ++ inr mon_unit :: z) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v)	                    with	                    | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                    end	                      (amal_eta	                         ((x ++ inr mon_unit :: z) ++	                          fst (fst b) ++ inr (g (snd (fst b))) :: snd b)))^-1	                     (dp_const	                        ((ap amal_eta	                            (word_concat_w_ww (x ++ inr mon_unit :: z)	                               (fst (fst b)) (inl (f (snd (fst b))) :: snd b)) @	                          amal_tau ((x ++ inr mon_unit :: z) ++ fst (fst b))	                            (snd b) (snd (fst b))) @	                         ap amal_eta	                           (word_concat_w_ww (x ++ inr mon_unit :: z)	                              (fst (fst b)) (inr (g (snd (fst b))) :: snd b))^))	               end	           | inr b =>	               (match	                  cglue (inl (inr (fst b, snd b))) as p in (_ = y)	                  return	                    (forall v : Trunc 0 (Coeq map1 map2),	                     DPath	                       (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                       (amal_eta	                          ((x ++ inr mon_unit :: z) ++	                           fst b ++ inl mon_unit :: snd b)) v <~>	                     DPath	                       (fun _ : Trunc 0 (Coeq map1 map2) =>	                        Trunc 0 (Coeq map1 map2)) 	                       (ap tr p)	                       (amal_eta	                          ((x ++ inr mon_unit :: z) ++	                           fst b ++ inl mon_unit :: snd b)) v)	                with	                | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                end (amal_eta ((x ++ inr mon_unit :: z) ++ fst b ++ snd b)))^-1	                 (dp_const	                    ((ap amal_eta	                        (word_concat_w_ww (x ++ inr mon_unit :: z) 	                           (fst b) (inl mon_unit :: snd b)) @	                      amal_omega_H ((x ++ inr mon_unit :: z) ++ fst b)	                        (snd b)) @	                     ap amal_eta	                       (word_concat_w_ww (x ++ inr mon_unit :: z) 	                          (fst b) (snd b))^))	           end	       | inr b =>	           (match	              cglue (inr (fst b, snd b)) as p in (_ = y)	              return	                (forall v : Trunc 0 (Coeq map1 map2),	                 DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                   (amal_eta	                      ((x ++ inr mon_unit :: z) ++	                       fst b ++ inr mon_unit :: snd b)) v <~>	                 DPath	                   (fun _ : Trunc 0 (Coeq map1 map2) =>	                    Trunc 0 (Coeq map1 map2)) (ap tr p)	                   (amal_eta	                      ((x ++ inr mon_unit :: z) ++	                       fst b ++ inr mon_unit :: snd b)) v)	            with	            | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	            end (amal_eta ((x ++ inr mon_unit :: z) ++ fst b ++ snd b)))^-1	             (dp_const	                ((ap amal_eta	                    (word_concat_w_ww (x ++ inr mon_unit :: z) 	                       (fst b) (inr mon_unit :: snd b)) @	                  amal_omega_K ((x ++ inr mon_unit :: z) ++ fst b) (snd b)) @	                 ap amal_eta	                   (word_concat_w_ww (x ++ inr mon_unit :: z) (fst b) (snd b))^))	       end) (coeq w) =	  Coeq_ind (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	    (fun y : Words => amal_eta ((x ++ z) ++ y))	    (fun a : pc1 + pc2 + pc3 + pc4 + pc5 =>	     dp_path_transport^-1	       match	         a as s	         return	           (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	              (cglue s) (amal_eta ((x ++ z) ++ map1 s))	              (amal_eta ((x ++ z) ++ map2 s)))	       with	       | inl a0 =>	           match	             a0 as s	             return	               (DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                  (cglue (inl s))	                  (amal_eta	                     ((x ++ z) ++	                      match s with	                      | inl (inl (inl a3)) => m1 a3	                      | inl (inl (inr b)) => m2 b	                      | inl (inr b) => m3 b	                      | inr b => m4 b	                      end))	                  (amal_eta	                     ((x ++ z) ++	                      match s with	                      | inl (inl (inl a3)) => m1' a3	                      | inl (inl (inr b)) => m2' b	                      | inl (inr b) => m3' b	                      | inr b => m4' b	                      end)))	           with	           | inl a1 =>	               match	                 a1 as s	                 return	                   (DPath	                      (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                      (cglue (inl (inl s)))	                      (amal_eta	                         ((x ++ z) ++	                          match s with	                          | inl (inl a3) => m1 a3	                          | inl (inr b) => m2 b	                          | inr b => m3 b	                          end))	                      (amal_eta	                         ((x ++ z) ++	                          match s with	                          | inl (inl a3) => m1' a3	                          | inl (inr b) => m2' b	                          | inr b => m3' b	                          end)))	               with	               | inl a2 =>	                   match	                     a2 as s	                     return	                       (DPath	                          (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2))	                          (cglue (inl (inl (inl s))))	                          (amal_eta	                             ((x ++ z) ++	                              match s with	                              | inl a3 => m1 a3	                              | inr b => m2 b	                              end))	                          (amal_eta	                             ((x ++ z) ++	                              match s with	                              | inl a3 => m1' a3	                              | inr b => m2' b	                              end)))	                   with	                   | inl a3 =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inl	                                        (fst (fst (fst a3)),	                                        snd (fst (fst a3)), 	                                        snd (fst a3), 	                                        snd a3))))) as p in 	                          (_ = y)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ z) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ z) ++	                                   fst (fst (fst a3)) ++	                                   inl (snd (fst (fst a3)))	                                   :: inl (snd (fst a3)) :: snd a3)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ z) ++	                              fst (fst (fst a3)) ++	                              inl (snd (fst (fst a3)) * snd (fst a3))	                              :: snd a3)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ z) (fst (fst (fst a3)))	                                   (inl (snd (fst (fst a3)))	                                    :: inl (snd (fst a3)) :: snd a3)) @	                              amal_mu_H ((x ++ z) ++ fst (fst (fst a3)))	                                (snd a3) (snd (fst (fst a3))) 	                                (snd (fst a3))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ z)	                                  (fst (fst (fst a3)))	                                  (inl (snd (fst (fst a3)) * snd (fst a3))	                                   :: snd a3))^))	                   | inr b =>	                       (match	                          cglue	                            (inl	                               (inl	                                  (inl	                                     (inr	                                        (fst (fst (fst b)),	                                        snd (fst (fst b)), 	                                        snd (fst b), 	                                        snd b))))) as p in 	                          (_ = y)	                          return	                            (forall v : Trunc 0 (Coeq map1 map2),	                             DPath	                               (fun _ : Coeq map1 map2 =>	                                Trunc 0 (Coeq map1 map2)) p	                               (amal_eta	                                  ((x ++ z) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v <~>	                             DPath	                               (fun _ : Trunc 0 (Coeq map1 map2) =>	                                Trunc 0 (Coeq map1 map2)) 	                               (ap tr p)	                               (amal_eta	                                  ((x ++ z) ++	                                   fst (fst (fst b)) ++	                                   inr (snd (fst (fst b)))	                                   :: inr (snd (fst b)) :: snd b)) v)	                        with	                        | 1%path =>	                            fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                        end	                          (amal_eta	                             ((x ++ z) ++	                              fst (fst (fst b)) ++	                              inr (snd (fst (fst b)) * snd (fst b)) :: snd b)))^-1	                         (dp_const	                            ((ap amal_eta	                                (word_concat_w_ww 	                                   (x ++ z) (fst (fst (fst b)))	                                   (inr (snd (fst (fst b)))	                                    :: inr (snd (fst b)) :: snd b)) @	                              amal_mu_K ((x ++ z) ++ fst (fst (fst b)))	                                (snd b) (snd (fst (fst b))) 	                                (snd (fst b))) @	                             ap amal_eta	                               (word_concat_w_ww (x ++ z) 	                                  (fst (fst (fst b)))	                                  (inr (snd (fst (fst b)) * snd (fst b))	                                   :: snd b))^))	                   end	               | inr b =>	                   (match	                      cglue	                        (inl (inl (inr (fst (fst b), snd (fst b), snd b))))	                      as p in (_ = y)	                      return	                        (forall v : Trunc 0 (Coeq map1 map2),	                         DPath	                           (fun _ : Coeq map1 map2 =>	                            Trunc 0 (Coeq map1 map2)) p	                           (amal_eta	                              ((x ++ z) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v <~>	                         DPath	                           (fun _ : Trunc 0 (Coeq map1 map2) =>	                            Trunc 0 (Coeq map1 map2)) 	                           (ap tr p)	                           (amal_eta	                              ((x ++ z) ++	                               fst (fst b) ++ inl (f (snd (fst b))) :: snd b))	                           v)	                    with	                    | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                    end	                      (amal_eta	                         ((x ++ z) ++	                          fst (fst b) ++ inr (g (snd (fst b))) :: snd b)))^-1	                     (dp_const	                        ((ap amal_eta	                            (word_concat_w_ww (x ++ z) 	                               (fst (fst b)) (inl (f (snd (fst b))) :: snd b)) @	                          amal_tau ((x ++ z) ++ fst (fst b)) 	                            (snd b) (snd (fst b))) @	                         ap amal_eta	                           (word_concat_w_ww (x ++ z) 	                              (fst (fst b)) (inr (g (snd (fst b))) :: snd b))^))	               end	           | inr b =>	               (match	                  cglue (inl (inr (fst b, snd b))) as p in (_ = y)	                  return	                    (forall v : Trunc 0 (Coeq map1 map2),	                     DPath	                       (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                       (amal_eta ((x ++ z) ++ fst b ++ inl mon_unit :: snd b))	                       v <~>	                     DPath	                       (fun _ : Trunc 0 (Coeq map1 map2) =>	                        Trunc 0 (Coeq map1 map2)) 	                       (ap tr p)	                       (amal_eta ((x ++ z) ++ fst b ++ inl mon_unit :: snd b))	                       v)	                with	                | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	                end (amal_eta ((x ++ z) ++ fst b ++ snd b)))^-1	                 (dp_const	                    ((ap amal_eta	                        (word_concat_w_ww (x ++ z) 	                           (fst b) (inl mon_unit :: snd b)) @	                      amal_omega_H ((x ++ z) ++ fst b) (snd b)) @	                     ap amal_eta (word_concat_w_ww (x ++ z) (fst b) (snd b))^))	           end	       | inr b =>	           (match	              cglue (inr (fst b, snd b)) as p in (_ = y)	              return	                (forall v : Trunc 0 (Coeq map1 map2),	                 DPath (fun _ : Coeq map1 map2 => Trunc 0 (Coeq map1 map2)) p	                   (amal_eta ((x ++ z) ++ fst b ++ inr mon_unit :: snd b)) v <~>	                 DPath	                   (fun _ : Trunc 0 (Coeq map1 map2) =>	                    Trunc 0 (Coeq map1 map2)) (ap tr p)	                   (amal_eta ((x ++ z) ++ fst b ++ inr mon_unit :: snd b)) v)	            with	            | 1%path => fun v : Trunc 0 (Coeq map1 map2) => 1%equiv	            end (amal_eta ((x ++ z) ++ fst b ++ snd b)))^-1	             (dp_const	                ((ap amal_eta	                    (word_concat_w_ww (x ++ z) (fst b)	                       (inr mon_unit :: snd b)) @	                  amal_omega_K ((x ++ z) ++ fst b) (snd b)) @	                 ap amal_eta (word_concat_w_ww (x ++ z) (fst b) (snd b))^))	       end) (coeq w)	1 goal (ID 3157)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  w : Words	  ============================	  amal_eta ((x ++ [inr mon_unit] ++ z) ++ w) = amal_eta ((x ++ z) ++ w)	3 focused goals (shelved: 2) (ID 3184)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  w : Words	  ============================	  ?Goal = (x ++ [inr mon_unit] ++ z) ++ w		goal 2 (ID 3185) is:	 amal_eta ?Goal = amal_eta ?Goal2	goal 3 (ID 3187) is:	 ?Goal2 = (x ++ z) ++ w	1 goal (ID 3185)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  w : Words	  ============================	  amal_eta (x ++ ([inr mon_unit] ++ z) ++ w) = amal_eta (x ++ z ++ w)	";
            responses[i]=data;
          

            i = 377;
            data = "2 focused goals (shelved: 1) (ID 3209)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  w : Words	  ============================	  ?Goal = ([inr mon_unit] ++ z) ++ w		goal 2 (ID 3210) is:	 amal_eta (x ++ ?Goal) = amal_eta (x ++ z ++ w)	";
            responses[i]=data;
          

            i = 378;
            data = "1 goal (ID 3210)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  w : Words	  ============================	  amal_eta (x ++ [inr mon_unit] ++ z ++ w) = amal_eta (x ++ z ++ w)	";
            responses[i]=data;
          

            i = 379;
            data = "No more goals.	No more goals.	";
            responses[i]=data;
          

            i = 380;
            data = "";
            responses[i]=data;
          

            i = 381;
            data = "";
            responses[i]=data;
          

            i = 382;
            data = "";
            responses[i]=data;
          

            i = 383;
            data = "";
            responses[i]=data;
          

            i = 384;
            data = "";
            responses[i]=data;
          

            i = 385;
            data = "1 goal (ID 382)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  MonUnit amal_type	";
            responses[i]=data;
          

            i = 386;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 387;
            data = "";
            responses[i]=data;
          

            i = 388;
            data = "1 goal (ID 383)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  Negate amal_type	";
            responses[i]=data;
          

            i = 389;
            data = "";
            responses[i]=data;
          

            i = 390;
            data = "6 goals (ID 1273)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  Words -> amal_type		goal 2 (ID 1275) is:	 forall (x y : Words) (h1 h2 : H),	 ?e (x ++ (inl h1 :: [inl h2]) ++ y) = ?e (x ++ [inl (h1 * h2)] ++ y)	goal 3 (ID 1277) is:	 forall (x y : Words) (k1 k2 : K),	 ?e (x ++ (inr k1 :: [inr k2]) ++ y) = ?e (x ++ [inr (k1 * k2)] ++ y)	goal 4 (ID 1279) is:	 forall (x y : Words) (z : G),	 ?e (x ++ [inl (f z)] ++ y) = ?e (x ++ [inr (g z)] ++ y)	goal 5 (ID 1281) is:	 forall x y : Words, ?e (x ++ [inl mon_unit] ++ y) = ?e (x ++ y)	goal 6 (ID 1283) is:	 forall x y : Words, ?e (x ++ [inr mon_unit] ++ y) = ?e (x ++ y)	";
            responses[i]=data;
          

            i = 391;
            data = "1 goal (ID 1273)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  Words -> amal_type	1 goal (ID 1284)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  w : Words	  ============================	  amal_type	";
            responses[i]=data;
          

            i = 392;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	5 goals		goal 1 (ID 1275) is:	 forall (x y : Words) (h1 h2 : H),	 (fun w : Words => amal_eta (word_inverse w))	   (x ++ (inl h1 :: [inl h2]) ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl (h1 * h2)] ++ y)	goal 2 (ID 1277) is:	 forall (x y : Words) (k1 k2 : K),	 (fun w : Words => amal_eta (word_inverse w))	   (x ++ (inr k1 :: [inr k2]) ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr (k1 * k2)] ++ y)	goal 3 (ID 1279) is:	 forall (x y : Words) (z : G),	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl (f z)] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr (g z)] ++ y)	goal 4 (ID 1281) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	goal 5 (ID 1283) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	";
            responses[i]=data;
          

            i = 393;
            data = "5 goals (ID 1275)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  forall (x y : Words) (h1 h2 : H),	  (fun w : Words => amal_eta (word_inverse w))	    (x ++ (inl h1 :: [inl h2]) ++ y) =	  (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl (h1 * h2)] ++ y)		goal 2 (ID 1277) is:	 forall (x y : Words) (k1 k2 : K),	 (fun w : Words => amal_eta (word_inverse w))	   (x ++ (inr k1 :: [inr k2]) ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr (k1 * k2)] ++ y)	goal 3 (ID 1279) is:	 forall (x y : Words) (z : G),	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl (f z)] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr (g z)] ++ y)	goal 4 (ID 1281) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	goal 5 (ID 1283) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	1 goal (ID 1275)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  forall (x y : Words) (h1 h2 : H),	  (fun w : Words => amal_eta (word_inverse w))	    (x ++ (inl h1 :: [inl h2]) ++ y) =	  (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl (h1 * h2)] ++ y)	1 goal (ID 1289)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  amal_eta (word_inverse (x ++ (inl h1 :: [inl h2]) ++ y)) =	  amal_eta (word_inverse (x ++ [inl (h1 * h2)] ++ y))	";
            responses[i]=data;
          

            i = 394;
            data = "3 focused goals (shelved: 2) (ID 1316)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  word_inverse (x ++ (inl h1 :: [inl h2]) ++ y) = ?Goal		goal 2 (ID 1317) is:	 amal_eta ?Goal = amal_eta ?Goal2	goal 3 (ID 1319) is:	 word_inverse (x ++ [inl (h1 * h2)] ++ y) = ?Goal2	";
            responses[i]=data;
          

            i = 395;
            data = "3 focused goals (shelved: 2) (ID 1341)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  word_inverse ((inl h1 :: [inl h2]) ++ y) = ?Goal0		goal 2 (ID 1363) is:	 word_inverse ([inl (h1 * h2)] ++ y) = ?Goal2	goal 3 (ID 1317) is:	 amal_eta (?Goal0 ++ word_inverse x) = amal_eta (?Goal2 ++ word_inverse x)	";
            responses[i]=data;
          

            i = 396;
            data = "2 focused goals (shelved: 1) (ID 1363)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  word_inverse ([inl (h1 * h2)] ++ y) = ?Goal0		goal 2 (ID 1317) is:	 amal_eta	   ((word_inverse y ++ word_inverse (inl h1 :: [inl h2])) ++ word_inverse x) =	 amal_eta (?Goal0 ++ word_inverse x)	";
            responses[i]=data;
          

            i = 397;
            data = "1 focused goal (shelved: 1) (ID 1363)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  word_inverse ([inl (h1 * h2)] ++ y) = ?Goal0	1 focused goal (shelved: 1) (ID 1374)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  word_inverse y ++ word_inverse [inl (h1 * h2)] = ?Goal0	";
            responses[i]=data;
          

            i = 398;
            data = "1 focused goal (shelved: 1) (ID 1384)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  [inl (- (h1 * h2))] = ?y	";
            responses[i]=data;
          

            i = 399;
            data = "1 focused goal (shelved: 1) (ID 1404)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  inl (- (h1 * h2)) = ?Goal0	";
            responses[i]=data;
          

            i = 400;
            data = "1 focused goal (shelved: 1) (ID 1408)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  - (h1 * h2) = ?y	";
            responses[i]=data;
          

            i = 401;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	5 goals		goal 1 (ID 1317) is:	 amal_eta	   ((word_inverse y ++ word_inverse (inl h1 :: [inl h2])) ++ word_inverse x) =	 amal_eta ((word_inverse y ++ [inl (- h2 * - h1)]) ++ word_inverse x)	goal 2 (ID 1277) is:	 forall (x y : Words) (k1 k2 : K),	 (fun w : Words => amal_eta (word_inverse w))	   (x ++ (inr k1 :: [inr k2]) ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr (k1 * k2)] ++ y)	goal 3 (ID 1279) is:	 forall (x y : Words) (z : G),	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl (f z)] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr (g z)] ++ y)	goal 4 (ID 1281) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	goal 5 (ID 1283) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	1 goal (ID 1317)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  amal_eta	    ((word_inverse y ++ word_inverse (inl h1 :: [inl h2])) ++ word_inverse x) =	  amal_eta ((word_inverse y ++ [inl (- h2 * - h1)]) ++ word_inverse x)	1 goal (ID 1423)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  amal_eta ((word_inverse y ++ inl (- h2) :: [inl (- h1)]) ++ word_inverse x) =	  amal_eta ((word_inverse y ++ [inl (- h2 * - h1)]) ++ word_inverse x)	";
            responses[i]=data;
          

            i = 402;
            data = "3 focused goals (shelved: 2) (ID 1450)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  ?Goal = (word_inverse y ++ inl (- h2) :: [inl (- h1)]) ++ word_inverse x		goal 2 (ID 1451) is:	 amal_eta ?Goal = amal_eta ?Goal2	goal 3 (ID 1453) is:	 ?Goal2 = (word_inverse y ++ [inl (- h2 * - h1)]) ++ word_inverse x	";
            responses[i]=data;
          

            i = 403;
            data = "1 goal (ID 1451)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  h1, h2 : H	  ============================	  amal_eta (word_inverse y ++ (inl (- h2) :: [inl (- h1)]) ++ word_inverse x) =	  amal_eta (word_inverse y ++ [inl (- h2 * - h1)] ++ word_inverse x)	";
            responses[i]=data;
          

            i = 404;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	4 goals		goal 1 (ID 1277) is:	 forall (x y : Words) (k1 k2 : K),	 (fun w : Words => amal_eta (word_inverse w))	   (x ++ (inr k1 :: [inr k2]) ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr (k1 * k2)] ++ y)	goal 2 (ID 1279) is:	 forall (x y : Words) (z : G),	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl (f z)] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr (g z)] ++ y)	goal 3 (ID 1281) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	goal 4 (ID 1283) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	4 goals (ID 1277)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  forall (x y : Words) (k1 k2 : K),	  (fun w : Words => amal_eta (word_inverse w))	    (x ++ (inr k1 :: [inr k2]) ++ y) =	  (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr (k1 * k2)] ++ y)		goal 2 (ID 1279) is:	 forall (x y : Words) (z : G),	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl (f z)] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr (g z)] ++ y)	goal 3 (ID 1281) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	goal 4 (ID 1283) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	1 goal (ID 1277)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  forall (x y : Words) (k1 k2 : K),	  (fun w : Words => amal_eta (word_inverse w))	    (x ++ (inr k1 :: [inr k2]) ++ y) =	  (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr (k1 * k2)] ++ y)	1 goal (ID 1458)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  amal_eta (word_inverse (x ++ (inr k1 :: [inr k2]) ++ y)) =	  amal_eta (word_inverse (x ++ [inr (k1 * k2)] ++ y))	";
            responses[i]=data;
          

            i = 405;
            data = "3 focused goals (shelved: 2) (ID 1485)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  word_inverse (x ++ (inr k1 :: [inr k2]) ++ y) = ?Goal		goal 2 (ID 1486) is:	 amal_eta ?Goal = amal_eta ?Goal2	goal 3 (ID 1488) is:	 word_inverse (x ++ [inr (k1 * k2)] ++ y) = ?Goal2	";
            responses[i]=data;
          

            i = 406;
            data = "3 focused goals (shelved: 2) (ID 1510)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  word_inverse ((inr k1 :: [inr k2]) ++ y) = ?Goal0		goal 2 (ID 1532) is:	 word_inverse ([inr (k1 * k2)] ++ y) = ?Goal2	goal 3 (ID 1486) is:	 amal_eta (?Goal0 ++ word_inverse x) = amal_eta (?Goal2 ++ word_inverse x)	";
            responses[i]=data;
          

            i = 407;
            data = "2 focused goals (shelved: 1) (ID 1532)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  word_inverse ([inr (k1 * k2)] ++ y) = ?Goal0		goal 2 (ID 1486) is:	 amal_eta	   ((word_inverse y ++ word_inverse (inr k1 :: [inr k2])) ++ word_inverse x) =	 amal_eta (?Goal0 ++ word_inverse x)	";
            responses[i]=data;
          

            i = 408;
            data = "1 focused goal (shelved: 1) (ID 1532)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  word_inverse ([inr (k1 * k2)] ++ y) = ?Goal0	1 focused goal (shelved: 1) (ID 1543)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  word_inverse y ++ word_inverse [inr (k1 * k2)] = ?Goal0	";
            responses[i]=data;
          

            i = 409;
            data = "1 focused goal (shelved: 1) (ID 1553)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  [inr (- (k1 * k2))] = ?y	";
            responses[i]=data;
          

            i = 410;
            data = "1 focused goal (shelved: 1) (ID 1573)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  inr (- (k1 * k2)) = ?Goal0	";
            responses[i]=data;
          

            i = 411;
            data = "1 focused goal (shelved: 1) (ID 1577)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  - (k1 * k2) = ?y	";
            responses[i]=data;
          

            i = 412;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	4 goals		goal 1 (ID 1486) is:	 amal_eta	   ((word_inverse y ++ word_inverse (inr k1 :: [inr k2])) ++ word_inverse x) =	 amal_eta ((word_inverse y ++ [inr (- k2 * - k1)]) ++ word_inverse x)	goal 2 (ID 1279) is:	 forall (x y : Words) (z : G),	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl (f z)] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr (g z)] ++ y)	goal 3 (ID 1281) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	goal 4 (ID 1283) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	1 goal (ID 1486)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  amal_eta	    ((word_inverse y ++ word_inverse (inr k1 :: [inr k2])) ++ word_inverse x) =	  amal_eta ((word_inverse y ++ [inr (- k2 * - k1)]) ++ word_inverse x)	1 goal (ID 1592)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  amal_eta ((word_inverse y ++ inr (- k2) :: [inr (- k1)]) ++ word_inverse x) =	  amal_eta ((word_inverse y ++ [inr (- k2 * - k1)]) ++ word_inverse x)	";
            responses[i]=data;
          

            i = 413;
            data = "3 focused goals (shelved: 2) (ID 1619)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  ?Goal = (word_inverse y ++ inr (- k2) :: [inr (- k1)]) ++ word_inverse x		goal 2 (ID 1620) is:	 amal_eta ?Goal = amal_eta ?Goal2	goal 3 (ID 1622) is:	 ?Goal2 = (word_inverse y ++ [inr (- k2 * - k1)]) ++ word_inverse x	";
            responses[i]=data;
          

            i = 414;
            data = "1 goal (ID 1620)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  k1, k2 : K	  ============================	  amal_eta (word_inverse y ++ (inr (- k2) :: [inr (- k1)]) ++ word_inverse x) =	  amal_eta (word_inverse y ++ [inr (- k2 * - k1)] ++ word_inverse x)	";
            responses[i]=data;
          

            i = 415;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 goals		goal 1 (ID 1279) is:	 forall (x y : Words) (z : G),	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl (f z)] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr (g z)] ++ y)	goal 2 (ID 1281) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	goal 3 (ID 1283) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	3 goals (ID 1279)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  forall (x y : Words) (z : G),	  (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl (f z)] ++ y) =	  (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr (g z)] ++ y)		goal 2 (ID 1281) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	goal 3 (ID 1283) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	1 goal (ID 1279)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  forall (x y : Words) (z : G),	  (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl (f z)] ++ y) =	  (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr (g z)] ++ y)	1 goal (ID 1626)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  ============================	  amal_eta (word_inverse (x ++ [inl (f z)] ++ y)) =	  amal_eta (word_inverse (x ++ [inr (g z)] ++ y))	";
            responses[i]=data;
          

            i = 416;
            data = "3 focused goals (shelved: 2) (ID 1653)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  ============================	  word_inverse (x ++ [inl (f z)] ++ y) = ?Goal		goal 2 (ID 1654) is:	 amal_eta ?Goal = amal_eta ?Goal2	goal 3 (ID 1656) is:	 word_inverse (x ++ [inr (g z)] ++ y) = ?Goal2	";
            responses[i]=data;
          

            i = 417;
            data = "3 focused goals (shelved: 2) (ID 1678)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  ============================	  word_inverse ([inl (f z)] ++ y) = ?Goal0		goal 2 (ID 1700) is:	 word_inverse ([inr (g z)] ++ y) = ?Goal2	goal 3 (ID 1654) is:	 amal_eta (?Goal0 ++ word_inverse x) = amal_eta (?Goal2 ++ word_inverse x)	";
            responses[i]=data;
          

            i = 418;
            data = "3 focused goals (shelved: 2) (ID 1712)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  ============================	  [inl (- f z)] = ?Goal0		goal 2 (ID 1722) is:	 [inr (- g z)] = ?Goal2	goal 3 (ID 1654) is:	 amal_eta ((word_inverse y ++ ?Goal0) ++ word_inverse x) =	 amal_eta ((word_inverse y ++ ?Goal2) ++ word_inverse x)	";
            responses[i]=data;
          

            i = 419;
            data = "3 focused goals (shelved: 2) (ID 1742)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  ============================	  inl (- f z) = ?Goal0		goal 2 (ID 1762) is:	 inr (- g z) = ?Goal2	goal 3 (ID 1654) is:	 amal_eta ((word_inverse y ++ [?Goal0]) ++ word_inverse x) =	 amal_eta ((word_inverse y ++ [?Goal2]) ++ word_inverse x)	";
            responses[i]=data;
          

            i = 420;
            data = "3 focused goals (shelved: 2) (ID 1766)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  ============================	  - f z = ?y		goal 2 (ID 1770) is:	 - g z = ?y0	goal 3 (ID 1654) is:	 amal_eta ((word_inverse y ++ [inl ?y]) ++ word_inverse x) =	 amal_eta ((word_inverse y ++ [inr ?y0]) ++ word_inverse x)	";
            responses[i]=data;
          

            i = 421;
            data = "1 goal (ID 1654)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  ============================	  amal_eta ((word_inverse y ++ [inl (f (- z))]) ++ word_inverse x) =	  amal_eta ((word_inverse y ++ [inr (g (- z))]) ++ word_inverse x)	";
            responses[i]=data;
          

            i = 422;
            data = "3 focused goals (shelved: 2) (ID 1821)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  ============================	  ?Goal = (word_inverse y ++ [inl (f (- z))]) ++ word_inverse x		goal 2 (ID 1822) is:	 amal_eta ?Goal = amal_eta ?Goal2	goal 3 (ID 1824) is:	 ?Goal2 = (word_inverse y ++ [inr (g (- z))]) ++ word_inverse x	";
            responses[i]=data;
          

            i = 423;
            data = "1 goal (ID 1822)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : Words	  z : G	  ============================	  amal_eta (word_inverse y ++ [inl (f (- z))] ++ word_inverse x) =	  amal_eta (word_inverse y ++ [inr (g (- z))] ++ word_inverse x)	";
            responses[i]=data;
          

            i = 424;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 goals		goal 1 (ID 1281) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	goal 2 (ID 1283) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	2 goals (ID 1281)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  forall x y : Words,	  (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl mon_unit] ++ y) =	  (fun w : Words => amal_eta (word_inverse w)) (x ++ y)		goal 2 (ID 1283) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	1 goal (ID 1281)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  forall x y : Words,	  (fun w : Words => amal_eta (word_inverse w)) (x ++ [inl mon_unit] ++ y) =	  (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	1 goal (ID 1827)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  amal_eta (word_inverse (x ++ [inl mon_unit] ++ z)) =	  amal_eta (word_inverse (x ++ z))	";
            responses[i]=data;
          

            i = 425;
            data = "3 focused goals (shelved: 2) (ID 1854)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  word_inverse (x ++ [inl mon_unit] ++ z) = ?Goal		goal 2 (ID 1855) is:	 amal_eta ?Goal = amal_eta ?Goal2	goal 3 (ID 1857) is:	 word_inverse (x ++ z) = ?Goal2	";
            responses[i]=data;
          

            i = 426;
            data = "1 goal (ID 1855)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  amal_eta (word_inverse ([inl mon_unit] ++ z) ++ word_inverse x) =	  amal_eta (word_inverse z ++ word_inverse x)	";
            responses[i]=data;
          

            i = 427;
            data = "2 focused goals (shelved: 1) (ID 1871)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  word_inverse ([inl mon_unit] ++ z) ++ word_inverse x = ?Goal		goal 2 (ID 1872) is:	 amal_eta ?Goal = amal_eta (word_inverse z ++ word_inverse x)	";
            responses[i]=data;
          

            i = 428;
            data = "1 focused goal (shelved: 1) (ID 1871)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  word_inverse ([inl mon_unit] ++ z) ++ word_inverse x = ?Goal	1 focused goal (shelved: 1) (ID 1884)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  word_inverse ([inl mon_unit] ++ z) = ?Goal0	";
            responses[i]=data;
          

            i = 429;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 goals		goal 1 (ID 1872) is:	 amal_eta ((word_inverse z ++ word_inverse [inl mon_unit]) ++ word_inverse x) =	 amal_eta (word_inverse z ++ word_inverse x)	goal 2 (ID 1283) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	1 goal (ID 1872)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  amal_eta	    ((word_inverse z ++ word_inverse [inl mon_unit]) ++ word_inverse x) =	  amal_eta (word_inverse z ++ word_inverse x)	2 focused goals (shelved: 1) (ID 1901)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  ?Goal = (word_inverse z ++ word_inverse [inl mon_unit]) ++ word_inverse x		goal 2 (ID 1902) is:	 amal_eta ?Goal = amal_eta (word_inverse z ++ word_inverse x)	";
            responses[i]=data;
          

            i = 430;
            data = "1 goal (ID 1902)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  amal_eta (word_inverse z ++ word_inverse [inl mon_unit] ++ word_inverse x) =	  amal_eta (word_inverse z ++ word_inverse x)	";
            responses[i]=data;
          

            i = 431;
            data = "1 goal (ID 1910)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  amal_eta (word_inverse z ++ inl (- mon_unit) :: word_inverse x) =	  amal_eta (word_inverse z ++ word_inverse x)	";
            responses[i]=data;
          

            i = 432;
            data = "1 goal (ID 1916)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  amal_eta (word_inverse z ++ inl mon_unit :: word_inverse x) =	  amal_eta (word_inverse z ++ word_inverse x)	";
            responses[i]=data;
          

            i = 433;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 1283) is:	 forall x y : Words,	 (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	1 goal (ID 1283)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  forall x y : Words,	  (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr mon_unit] ++ y) =	  (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	1 goal (ID 1283)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  forall x y : Words,	  (fun w : Words => amal_eta (word_inverse w)) (x ++ [inr mon_unit] ++ y) =	  (fun w : Words => amal_eta (word_inverse w)) (x ++ y)	1 goal (ID 1924)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  amal_eta (word_inverse (x ++ [inr mon_unit] ++ z)) =	  amal_eta (word_inverse (x ++ z))	";
            responses[i]=data;
          

            i = 434;
            data = "3 focused goals (shelved: 2) (ID 1951)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  word_inverse (x ++ [inr mon_unit] ++ z) = ?Goal		goal 2 (ID 1952) is:	 amal_eta ?Goal = amal_eta ?Goal2	goal 3 (ID 1954) is:	 word_inverse (x ++ z) = ?Goal2	";
            responses[i]=data;
          

            i = 435;
            data = "1 goal (ID 1952)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  amal_eta (word_inverse ([inr mon_unit] ++ z) ++ word_inverse x) =	  amal_eta (word_inverse z ++ word_inverse x)	";
            responses[i]=data;
          

            i = 436;
            data = "2 focused goals (shelved: 1) (ID 1968)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  word_inverse ([inr mon_unit] ++ z) ++ word_inverse x = ?Goal		goal 2 (ID 1969) is:	 amal_eta ?Goal = amal_eta (word_inverse z ++ word_inverse x)	";
            responses[i]=data;
          

            i = 437;
            data = "1 focused goal (shelved: 1) (ID 1968)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  word_inverse ([inr mon_unit] ++ z) ++ word_inverse x = ?Goal	1 focused goal (shelved: 1) (ID 1981)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  word_inverse ([inr mon_unit] ++ z) = ?Goal0	";
            responses[i]=data;
          

            i = 438;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 1969) is:	 amal_eta ((word_inverse z ++ word_inverse [inr mon_unit]) ++ word_inverse x) =	 amal_eta (word_inverse z ++ word_inverse x)	1 goal (ID 1969)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  amal_eta	    ((word_inverse z ++ word_inverse [inr mon_unit]) ++ word_inverse x) =	  amal_eta (word_inverse z ++ word_inverse x)	2 focused goals (shelved: 1) (ID 1998)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  ?Goal = (word_inverse z ++ word_inverse [inr mon_unit]) ++ word_inverse x		goal 2 (ID 1999) is:	 amal_eta ?Goal = amal_eta (word_inverse z ++ word_inverse x)	";
            responses[i]=data;
          

            i = 439;
            data = "1 goal (ID 1999)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  amal_eta (word_inverse z ++ word_inverse [inr mon_unit] ++ word_inverse x) =	  amal_eta (word_inverse z ++ word_inverse x)	";
            responses[i]=data;
          

            i = 440;
            data = "1 goal (ID 2007)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  amal_eta (word_inverse z ++ inr (- mon_unit) :: word_inverse x) =	  amal_eta (word_inverse z ++ word_inverse x)	";
            responses[i]=data;
          

            i = 441;
            data = "1 goal (ID 2013)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, z : Words	  ============================	  amal_eta (word_inverse z ++ inr mon_unit :: word_inverse x) =	  amal_eta (word_inverse z ++ word_inverse x)	";
            responses[i]=data;
          

            i = 442;
            data = "No more goals.	No more goals.	";
            responses[i]=data;
          

            i = 443;
            data = "1 goal (ID 387)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  Associative sg_op	";
            responses[i]=data;
          

            i = 444;
            data = "";
            responses[i]=data;
          

            i = 445;
            data = "1 goal (ID 390)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : amal_type	  ============================	  forall z : amal_type, x * (y * z) = x * y * z	";
            responses[i]=data;
          

            i = 446;
            data = "1 goal (ID 464)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : amal_type	  z : Words	  ============================	  forall y : amal_type, x * (y * amal_eta z) = x * y * amal_eta z	";
            responses[i]=data;
          

            i = 447;
            data = "1 goal (ID 538)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  z : Words	  y : Words	  ============================	  forall x : amal_type,	  x * (amal_eta y * amal_eta z) = x * amal_eta y * amal_eta z	";
            responses[i]=data;
          

            i = 448;
            data = "1 goal (ID 610)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  z : Words	  y : Words	  x : Words	  ============================	  amal_eta x * (amal_eta y * amal_eta z) =	  amal_eta x * amal_eta y * amal_eta z	";
            responses[i]=data;
          

            i = 449;
            data = "";
            responses[i]=data;
          

            i = 450;
            data = "1 goal (ID 621)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  z : Words	  y : Words	  x : Words	  ============================	  x ++ y ++ z = (x ++ y) ++ z	No more goals.	";
            responses[i]=data;
          

            i = 451;
            data = "";
            responses[i]=data;
          

            i = 452;
            data = "1 goal (ID 394)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  LeftIdentity sg_op mon_unit	";
            responses[i]=data;
          

            i = 453;
            data = "";
            responses[i]=data;
          

            i = 454;
            data = "1 goal (ID 466)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  mon_unit * amal_eta x = amal_eta x	";
            responses[i]=data;
          

            i = 455;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 456;
            data = "";
            responses[i]=data;
          

            i = 457;
            data = "1 goal (ID 401)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  RightIdentity sg_op mon_unit	";
            responses[i]=data;
          

            i = 458;
            data = "";
            responses[i]=data;
          

            i = 459;
            data = "1 goal (ID 473)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  amal_eta x * mon_unit = amal_eta x	";
            responses[i]=data;
          

            i = 460;
            data = "1 goal (ID 484)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  x ++ nil = x	";
            responses[i]=data;
          

            i = 461;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 462;
            data = "";
            responses[i]=data;
          

            i = 463;
            data = "1 goal (ID 408)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  amal_eta (word_inverse x ++ x) = mon_unit	";
            responses[i]=data;
          

            i = 464;
            data = "";
            responses[i]=data;
          

            i = 465;
            data = "2 goals (ID 412)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  amal_eta (word_inverse nil ++ nil) = mon_unit		goal 2 (ID 416) is:	 amal_eta (word_inverse (x :: xs) ++ x :: xs) = mon_unit	";
            responses[i]=data;
          

            i = 466;
            data = "1 goal (ID 416)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : H + K	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta (word_inverse (x :: xs) ++ x :: xs) = mon_unit	";
            responses[i]=data;
          

            i = 467;
            data = "2 goals (ID 424)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta (word_inverse (inl h :: xs) ++ inl h :: xs) = mon_unit		goal 2 (ID 426) is:	 amal_eta (word_inverse (inr k :: xs) ++ inr k :: xs) = mon_unit	";
            responses[i]=data;
          

            i = 468;
            data = "1 goal (ID 424)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta (word_inverse (inl h :: xs) ++ inl h :: xs) = mon_unit	1 goal (ID 442)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta (word_inverse ([inl h] ++ xs) ++ [inl h] ++ xs) = mon_unit	";
            responses[i]=data;
          

            i = 469;
            data = "1 goal (ID 443)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta ((word_inverse xs ++ word_inverse [inl h]) ++ [inl h] ++ xs) =	  mon_unit	";
            responses[i]=data;
          

            i = 470;
            data = "1 goal (ID 444)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta (word_inverse xs ++ word_inverse [inl h] ++ [inl h] ++ xs) =	  mon_unit	";
            responses[i]=data;
          

            i = 471;
            data = "1 goal (ID 459)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta (word_inverse xs ++ [inl (- h * h)] ++ xs) = mon_unit	";
            responses[i]=data;
          

            i = 472;
            data = "1 goal (ID 472)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta (word_inverse xs ++ [inl mon_unit] ++ xs) = mon_unit	";
            responses[i]=data;
          

            i = 473;
            data = "1 goal (ID 480)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta (word_inverse xs ++ xs) = mon_unit	";
            responses[i]=data;
          

            i = 474;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 426) is:	 amal_eta (word_inverse (inr k :: xs) ++ inr k :: xs) = mon_unit	";
            responses[i]=data;
          

            i = 475;
            data = "1 goal (ID 426)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta (word_inverse (inr k :: xs) ++ inr k :: xs) = mon_unit	1 goal (ID 496)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta (word_inverse ([inr k] ++ xs) ++ [inr k] ++ xs) = mon_unit	";
            responses[i]=data;
          

            i = 476;
            data = "1 goal (ID 497)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta ((word_inverse xs ++ word_inverse [inr k]) ++ [inr k] ++ xs) =	  mon_unit	";
            responses[i]=data;
          

            i = 477;
            data = "1 goal (ID 498)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta (word_inverse xs ++ word_inverse [inr k] ++ [inr k] ++ xs) =	  mon_unit	";
            responses[i]=data;
          

            i = 478;
            data = "1 goal (ID 513)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta (word_inverse xs ++ [inr (- k * k)] ++ xs) = mon_unit	";
            responses[i]=data;
          

            i = 479;
            data = "1 goal (ID 526)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta (word_inverse xs ++ [inr mon_unit] ++ xs) = mon_unit	";
            responses[i]=data;
          

            i = 480;
            data = "1 goal (ID 534)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (word_inverse xs ++ xs) = mon_unit	  ============================	  amal_eta (word_inverse xs ++ xs) = mon_unit	";
            responses[i]=data;
          

            i = 481;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 482;
            data = "";
            responses[i]=data;
          

            i = 483;
            data = "1 goal (ID 415)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  amal_eta (x ++ word_inverse x) = mon_unit	";
            responses[i]=data;
          

            i = 484;
            data = "";
            responses[i]=data;
          

            i = 485;
            data = "2 goals (ID 419)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  amal_eta (nil ++ word_inverse nil) = mon_unit		goal 2 (ID 423) is:	 amal_eta ((x :: xs) ++ word_inverse (x :: xs)) = mon_unit	";
            responses[i]=data;
          

            i = 486;
            data = "1 goal (ID 423)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : H + K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta ((x :: xs) ++ word_inverse (x :: xs)) = mon_unit	";
            responses[i]=data;
          

            i = 487;
            data = "2 goals (ID 431)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta ((inl h :: xs) ++ word_inverse (inl h :: xs)) = mon_unit		goal 2 (ID 433) is:	 amal_eta ((inr k :: xs) ++ word_inverse (inr k :: xs)) = mon_unit	";
            responses[i]=data;
          

            i = 488;
            data = "1 goal (ID 431)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta ((inl h :: xs) ++ word_inverse (inl h :: xs)) = mon_unit	1 goal (ID 434)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (inl h :: xs ++ word_inverse xs ++ [inl (- h)]) = mon_unit	";
            responses[i]=data;
          

            i = 489;
            data = "1 goal (ID 435)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (inl h :: (xs ++ word_inverse xs) ++ [inl (- h)]) = mon_unit	";
            responses[i]=data;
          

            i = 490;
            data = "1 goal (ID 455)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta [inl h] * amal_eta (xs ++ word_inverse xs) * amal_eta [inl (- h)] =	  mon_unit	";
            responses[i]=data;
          

            i = 491;
            data = "1 goal (ID 456)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta [inl h] * mon_unit * amal_eta [inl (- h)] = mon_unit	";
            responses[i]=data;
          

            i = 492;
            data = "1 goal (ID 458)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta [inl h] * amal_eta [inl (- h)] = mon_unit	";
            responses[i]=data;
          

            i = 493;
            data = "1 goal (ID 462)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta ([inl h] ++ nil) * amal_eta [inl (- h)] = mon_unit	";
            responses[i]=data;
          

            i = 494;
            data = "1 goal (ID 483)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (([inl h] ++ [inl (- h)]) ++ nil) = mon_unit	";
            responses[i]=data;
          

            i = 495;
            data = "1 goal (ID 484)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta ([inl h] ++ [inl (- h)] ++ nil) = mon_unit	";
            responses[i]=data;
          

            i = 496;
            data = "1 goal (ID 504)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (nil ++ [inl h] ++ [inl (- h)] ++ nil) = mon_unit	";
            responses[i]=data;
          

            i = 497;
            data = "1 goal (ID 519)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (nil ++ [inl (h * - h)] ++ nil) = mon_unit	";
            responses[i]=data;
          

            i = 498;
            data = "2 focused goals (shelved: 1) (ID 529)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (nil ++ [inl (h * - h)] ++ nil) = ?Goal0		goal 2 (ID 530) is:	 ?Goal0 = mon_unit	";
            responses[i]=data;
          

            i = 499;
            data = "1 focused goal (shelved: 1) (ID 529)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (nil ++ [inl (h * - h)] ++ nil) = ?Goal0	1 focused goal (shelved: 1) (ID 538)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  [inl (h * - h)] ++ nil = ?y	";
            responses[i]=data;
          

            i = 500;
            data = "1 focused goal (shelved: 1) (ID 558)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  [inl (h * - h)] = ?Goal1	";
            responses[i]=data;
          

            i = 501;
            data = "1 focused goal (shelved: 1) (ID 578)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  inl (h * - h) = ?Goal1	";
            responses[i]=data;
          

            i = 502;
            data = "1 focused goal (shelved: 1) (ID 582)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  h * - h = ?y	";
            responses[i]=data;
          

            i = 503;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 goals		goal 1 (ID 530) is:	 amal_eta (nil ++ [inl mon_unit] ++ nil) = mon_unit	goal 2 (ID 433) is:	 amal_eta ((inr k :: xs) ++ word_inverse (inr k :: xs)) = mon_unit	1 goal (ID 530)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  h : H	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (nil ++ [inl mon_unit] ++ nil) = mon_unit	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	1 goal		goal 1 (ID 433) is:	 amal_eta ((inr k :: xs) ++ word_inverse (inr k :: xs)) = mon_unit	";
            responses[i]=data;
          

            i = 504;
            data = "1 goal (ID 433)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta ((inr k :: xs) ++ word_inverse (inr k :: xs)) = mon_unit	1 goal (ID 595)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (inr k :: xs ++ word_inverse xs ++ [inr (- k)]) = mon_unit	";
            responses[i]=data;
          

            i = 505;
            data = "1 goal (ID 596)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (inr k :: (xs ++ word_inverse xs) ++ [inr (- k)]) = mon_unit	";
            responses[i]=data;
          

            i = 506;
            data = "1 goal (ID 616)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta [inr k] * amal_eta (xs ++ word_inverse xs) * amal_eta [inr (- k)] =	  mon_unit	";
            responses[i]=data;
          

            i = 507;
            data = "1 goal (ID 617)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta [inr k] * mon_unit * amal_eta [inr (- k)] = mon_unit	";
            responses[i]=data;
          

            i = 508;
            data = "1 goal (ID 619)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta [inr k] * amal_eta [inr (- k)] = mon_unit	";
            responses[i]=data;
          

            i = 509;
            data = "1 goal (ID 623)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta ([inr k] ++ nil) * amal_eta [inr (- k)] = mon_unit	";
            responses[i]=data;
          

            i = 510;
            data = "1 goal (ID 644)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (([inr k] ++ [inr (- k)]) ++ nil) = mon_unit	";
            responses[i]=data;
          

            i = 511;
            data = "1 goal (ID 645)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta ([inr k] ++ [inr (- k)] ++ nil) = mon_unit	";
            responses[i]=data;
          

            i = 512;
            data = "1 goal (ID 665)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (nil ++ [inr k] ++ [inr (- k)] ++ nil) = mon_unit	";
            responses[i]=data;
          

            i = 513;
            data = "1 goal (ID 680)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (nil ++ [inr (k * - k)] ++ nil) = mon_unit	";
            responses[i]=data;
          

            i = 514;
            data = "2 focused goals (shelved: 1) (ID 690)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (nil ++ [inr (k * - k)] ++ nil) = ?Goal		goal 2 (ID 691) is:	 ?Goal = mon_unit	";
            responses[i]=data;
          

            i = 515;
            data = "1 focused goal (shelved: 1) (ID 690)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (nil ++ [inr (k * - k)] ++ nil) = ?Goal	1 focused goal (shelved: 1) (ID 699)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  [inr (k * - k)] ++ nil = ?y	";
            responses[i]=data;
          

            i = 516;
            data = "1 focused goal (shelved: 1) (ID 719)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  [inr (k * - k)] = ?Goal0	";
            responses[i]=data;
          

            i = 517;
            data = "1 focused goal (shelved: 1) (ID 739)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  inr (k * - k) = ?Goal0	";
            responses[i]=data;
          

            i = 518;
            data = "1 focused goal (shelved: 1) (ID 743)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  k * - k = ?y	";
            responses[i]=data;
          

            i = 519;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 691) is:	 amal_eta (nil ++ [inr mon_unit] ++ nil) = mon_unit	1 goal (ID 691)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  k : K	  xs : list (H + K)	  IHxs : amal_eta (xs ++ word_inverse xs) = mon_unit	  ============================	  amal_eta (nil ++ [inr mon_unit] ++ nil) = mon_unit	No more goals.	";
            responses[i]=data;
          

            i = 520;
            data = "";
            responses[i]=data;
          

            i = 521;
            data = "1 goal (ID 425)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  LeftInverse sg_op negate mon_unit	";
            responses[i]=data;
          

            i = 522;
            data = "";
            responses[i]=data;
          

            i = 523;
            data = "1 goal (ID 497)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  - amal_eta x * amal_eta x = mon_unit	";
            responses[i]=data;
          

            i = 524;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 525;
            data = "";
            responses[i]=data;
          

            i = 526;
            data = "1 goal (ID 435)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  RightInverse sg_op negate mon_unit	";
            responses[i]=data;
          

            i = 527;
            data = "";
            responses[i]=data;
          

            i = 528;
            data = "1 goal (ID 507)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : Words	  ============================	  amal_eta x * - amal_eta x = mon_unit	";
            responses[i]=data;
          

            i = 529;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 530;
            data = "";
            responses[i]=data;
          

            i = 531;
            data = "1 goal (ID 436)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  Group	";
            responses[i]=data;
          

            i = 532;
            data = "";
            responses[i]=data;
          

            i = 533;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 534;
            data = "";
            responses[i]=data;
          

            i = 535;
            data = "";
            responses[i]=data;
          

            i = 536;
            data = "";
            responses[i]=data;
          

            i = 537;
            data = "";
            responses[i]=data;
          

            i = 538;
            data = "";
            responses[i]=data;
          

            i = 539;
            data = "1 goal (ID 461)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  AmalgamatedFreeProduct -> X	";
            responses[i]=data;
          

            i = 540;
            data = "";
            responses[i]=data;
          

            i = 541;
            data = "6 goals (ID 1351)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  Words -> X		goal 2 (ID 1353) is:	 forall (x y : Words) (h1 h2 : H),	 ?e (x ++ (inl h1 :: [inl h2]) ++ y) = ?e (x ++ [inl (h1 * h2)] ++ y)	goal 3 (ID 1355) is:	 forall (x y : Words) (k1 k2 : K),	 ?e (x ++ (inr k1 :: [inr k2]) ++ y) = ?e (x ++ [inr (k1 * k2)] ++ y)	goal 4 (ID 1357) is:	 forall (x y : Words) (z : G),	 ?e (x ++ [inl (f z)] ++ y) = ?e (x ++ [inr (g z)] ++ y)	goal 5 (ID 1359) is:	 forall x y : Words, ?e (x ++ [inl mon_unit] ++ y) = ?e (x ++ y)	goal 6 (ID 1361) is:	 forall x y : Words, ?e (x ++ [inr mon_unit] ++ y) = ?e (x ++ y)	";
            responses[i]=data;
          

            i = 542;
            data = "1 goal (ID 1351)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  Words -> X	1 goal (ID 1499)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  w : Words	  ============================	  X	";
            responses[i]=data;
          

            i = 543;
            data = "2 goals (ID 1508)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  w : Words	  ============================	  H + K -> X -> X		goal 2 (ID 1509) is:	 X	";
            responses[i]=data;
          

            i = 544;
            data = "1 goal (ID 1508)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  w : Words	  ============================	  H + K -> X -> X	2 goals (ID 1516)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  w : Words	  l : H	  x : X	  ============================	  X		goal 2 (ID 1518) is:	 X	";
            responses[i]=data;
          

            i = 545;
            data = "1 goal (ID 1516)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  w : Words	  l : H	  x : X	  ============================	  X	<infomsg>	This subproof is complete, but there are some unfocused goals.	Focus next goal with bullet +.	</infomsg>	7 goals		goal 1 (ID 1518) is:	 X	goal 2 (ID 1509) is:	 X	goal 3 (ID 1353) is:	 forall (x y : Words) (h1 h2 : H),	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => ?Goal0@{x:=x0}) b	     end) ?Goal w) (x ++ (inl h1 :: [inl h2]) ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => ?Goal0@{x:=x0}) b	     end) ?Goal w) (x ++ [inl (h1 * h2)] ++ y)	goal 4 (ID 1355) is:	 forall (x y : Words) (k1 k2 : K),	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => ?Goal0@{x:=x0}) b	     end) ?Goal w) (x ++ (inr k1 :: [inr k2]) ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => ?Goal0@{x:=x0}) b	     end) ?Goal w) (x ++ [inr (k1 * k2)] ++ y)	goal 5 (ID 1357) is:	 forall (x y : Words) (z : G),	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => ?Goal0@{x:=x0}) b	     end) ?Goal w) (x ++ [inl (f z)] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => ?Goal0@{x:=x0}) b	     end) ?Goal w) (x ++ [inr (g z)] ++ y)	goal 6 (ID 1359) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => ?Goal0@{x:=x0}) b	     end) ?Goal w) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => ?Goal0@{x:=x0}) b	     end) ?Goal w) (x ++ y)	goal 7 (ID 1361) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => ?Goal0@{x:=x0}) b	     end) ?Goal w) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => ?Goal0@{x:=x0}) b	     end) ?Goal w) (x ++ y)	";
            responses[i]=data;
          

            i = 546;
            data = "1 goal (ID 1518)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  w : Words	  r : K	  x : X	  ============================	  X	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	6 goals		goal 1 (ID 1509) is:	 X	goal 2 (ID 1353) is:	 forall (x y : Words) (h1 h2 : H),	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) ?Goal w) (x ++ (inl h1 :: [inl h2]) ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) ?Goal w) (x ++ [inl (h1 * h2)] ++ y)	goal 3 (ID 1355) is:	 forall (x y : Words) (k1 k2 : K),	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) ?Goal w) (x ++ (inr k1 :: [inr k2]) ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) ?Goal w) (x ++ [inr (k1 * k2)] ++ y)	goal 4 (ID 1357) is:	 forall (x y : Words) (z : G),	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) ?Goal w) (x ++ [inl (f z)] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) ?Goal w) (x ++ [inr (g z)] ++ y)	goal 5 (ID 1359) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) ?Goal w) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) ?Goal w) (x ++ y)	goal 6 (ID 1361) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) ?Goal w) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) ?Goal w) (x ++ y)	";
            responses[i]=data;
          

            i = 547;
            data = "1 goal (ID 1509)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  w : Words	  ============================	  X	<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	5 goals		goal 1 (ID 1353) is:	 forall (x y : Words) (h1 h2 : H),	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ (inl h1 :: [inl h2]) ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inl (h1 * h2)] ++ y)	goal 2 (ID 1355) is:	 forall (x y : Words) (k1 k2 : K),	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ (inr k1 :: [inr k2]) ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr (k1 * k2)] ++ y)	goal 3 (ID 1357) is:	 forall (x y : Words) (z : G),	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inl (f z)] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr (g z)] ++ y)	goal 4 (ID 1359) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	goal 5 (ID 1361) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	5 goals (ID 1353)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  forall (x y : Words) (h1 h2 : H),	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ (inl h1 :: [inl h2]) ++ y) =	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ [inl (h1 * h2)] ++ y)		goal 2 (ID 1355) is:	 forall (x y : Words) (k1 k2 : K),	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ (inr k1 :: [inr k2]) ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr (k1 * k2)] ++ y)	goal 3 (ID 1357) is:	 forall (x y : Words) (z : G),	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inl (f z)] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr (g z)] ++ y)	goal 4 (ID 1359) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	goal 5 (ID 1361) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	1 goal (ID 1353)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  forall (x y : Words) (h1 h2 : H),	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ (inl h1 :: [inl h2]) ++ y) =	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ [inl (h1 * h2)] ++ y)	1 goal (ID 1533)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  h1, h2 : H	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit (x ++ (inl h1 :: [inl h2]) ++ y) =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit (x ++ [inl (h1 * h2)] ++ y)	";
            responses[i]=data;
          

            i = 548;
            data = "1 goal (ID 1537)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  h1, h2 : H	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end)	       (fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x0 : X => h a * x0	           | inr b => fun x0 : X => k b * x0	           end) mon_unit y) (inl h1 :: [inl h2])) x =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end)	       (fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x0 : X => h a * x0	           | inr b => fun x0 : X => k b * x0	           end) mon_unit y) [inl (h1 * h2)]) x	";
            responses[i]=data;
          

            i = 549;
            data = "1 goal (ID 1567)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  h1, h2 : H	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end) mon_unit y) (inl h1 :: [inl h2]) =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end) mon_unit y) [inl (h1 * h2)]	";
            responses[i]=data;
          

            i = 550;
            data = "1 goal (ID 1573)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  h1, h2 : H	  ============================	  h h1 *	  (h h2 *	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => fun x0 : X => h a * x0	      | inr b => fun x0 : X => k b * x0	      end) mon_unit y) =	  h (h1 * h2) *	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y	";
            responses[i]=data;
          

            i = 551;
            data = "1 goal (ID 1771)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  h1, h2 : H	  ============================	  h h1 * h h2 *	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y =	  h (h1 * h2) *	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y	";
            responses[i]=data;
          

            i = 552;
            data = "1 goal (ID 1804)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  h1, h2 : H	  ============================	  h h1 * h h2 = h (h1 * h2)	";
            responses[i]=data;
          

            i = 553;
            data = "1 goal (ID 1814)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  h1, h2 : H	  ============================	  h (h1 * h2) = h h1 * h h2	";
            responses[i]=data;
          

            i = 554;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	4 goals		goal 1 (ID 1355) is:	 forall (x y : Words) (k1 k2 : K),	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ (inr k1 :: [inr k2]) ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr (k1 * k2)] ++ y)	goal 2 (ID 1357) is:	 forall (x y : Words) (z : G),	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inl (f z)] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr (g z)] ++ y)	goal 3 (ID 1359) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	goal 4 (ID 1361) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	";
            responses[i]=data;
          

            i = 555;
            data = "4 goals (ID 1355)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  forall (x y : Words) (k1 k2 : K),	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ (inr k1 :: [inr k2]) ++ y) =	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ [inr (k1 * k2)] ++ y)		goal 2 (ID 1357) is:	 forall (x y : Words) (z : G),	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inl (f z)] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr (g z)] ++ y)	goal 3 (ID 1359) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	goal 4 (ID 1361) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	1 goal (ID 1355)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  forall (x y : Words) (k1 k2 : K),	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ (inr k1 :: [inr k2]) ++ y) =	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ [inr (k1 * k2)] ++ y)	1 goal (ID 1821)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  k1, k2 : K	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit (x ++ (inr k1 :: [inr k2]) ++ y) =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit (x ++ [inr (k1 * k2)] ++ y)	";
            responses[i]=data;
          

            i = 556;
            data = "1 goal (ID 1825)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  k1, k2 : K	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end)	       (fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x0 : X => h a * x0	           | inr b => fun x0 : X => k b * x0	           end) mon_unit y) (inr k1 :: [inr k2])) x =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end)	       (fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x0 : X => h a * x0	           | inr b => fun x0 : X => k b * x0	           end) mon_unit y) [inr (k1 * k2)]) x	";
            responses[i]=data;
          

            i = 557;
            data = "1 goal (ID 1855)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  k1, k2 : K	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end) mon_unit y) (inr k1 :: [inr k2]) =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end) mon_unit y) [inr (k1 * k2)]	";
            responses[i]=data;
          

            i = 558;
            data = "1 goal (ID 1861)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  k1, k2 : K	  ============================	  k k1 *	  (k k2 *	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => fun x0 : X => h a * x0	      | inr b => fun x0 : X => k b * x0	      end) mon_unit y) =	  k (k1 * k2) *	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y	";
            responses[i]=data;
          

            i = 559;
            data = "1 goal (ID 2059)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  k1, k2 : K	  ============================	  k k1 * k k2 *	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y =	  k (k1 * k2) *	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y	";
            responses[i]=data;
          

            i = 560;
            data = "1 goal (ID 2092)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  k1, k2 : K	  ============================	  k k1 * k k2 = k (k1 * k2)	";
            responses[i]=data;
          

            i = 561;
            data = "1 goal (ID 2102)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  k1, k2 : K	  ============================	  k (k1 * k2) = k k1 * k k2	";
            responses[i]=data;
          

            i = 562;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	3 goals		goal 1 (ID 1357) is:	 forall (x y : Words) (z : G),	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inl (f z)] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr (g z)] ++ y)	goal 2 (ID 1359) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	goal 3 (ID 1361) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	";
            responses[i]=data;
          

            i = 563;
            data = "3 goals (ID 1357)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  forall (x y : Words) (z : G),	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ [inl (f z)] ++ y) =	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ [inr (g z)] ++ y)		goal 2 (ID 1359) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	goal 3 (ID 1361) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	1 goal (ID 1357)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  forall (x y : Words) (z : G),	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ [inl (f z)] ++ y) =	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ [inr (g z)] ++ y)	1 goal (ID 2108)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  z : G	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit (x ++ [inl (f z)] ++ y) =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit (x ++ [inr (g z)] ++ y)	";
            responses[i]=data;
          

            i = 564;
            data = "1 goal (ID 2112)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  z : G	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end)	       (fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x0 : X => h a * x0	           | inr b => fun x0 : X => k b * x0	           end) mon_unit y) [inl (f z)]) x =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end)	       (fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x0 : X => h a * x0	           | inr b => fun x0 : X => k b * x0	           end) mon_unit y) [inr (g z)]) x	";
            responses[i]=data;
          

            i = 565;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 goals		goal 1 (ID 1359) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inl mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	goal 2 (ID 1361) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	2 goals (ID 1359)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  forall x y : Words,	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ [inl mon_unit] ++ y) =	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ y)		goal 2 (ID 1361) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	1 goal (ID 1359)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  forall x y : Words,	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ [inl mon_unit] ++ y) =	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ y)	1 goal (ID 2180)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit (x ++ [inl mon_unit] ++ y) =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit (x ++ y)	";
            responses[i]=data;
          

            i = 566;
            data = "1 goal (ID 2183)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end)	       (fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x0 : X => h a * x0	           | inr b => fun x0 : X => k b * x0	           end) mon_unit y) [inl mon_unit]) x =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end) mon_unit y) x	";
            responses[i]=data;
          

            i = 567;
            data = "1 goal (ID 2213)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end) mon_unit y) [inl mon_unit] =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y	";
            responses[i]=data;
          

            i = 568;
            data = "1 goal (ID 2216)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  ============================	  h mon_unit *	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y	";
            responses[i]=data;
          

            i = 569;
            data = "1 goal (ID 2219)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  ============================	  mon_unit *	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y	";
            responses[i]=data;
          

            i = 570;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 1361) is:	 forall x y : Words,	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ [inr mon_unit] ++ y) =	 (fun w : Words =>	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => (fun (l : H) (x0 : X) => h l * x0) a	     | inr b => (fun (r : K) (x0 : X) => k r * x0) b	     end) mon_unit w) (x ++ y)	1 goal (ID 1361)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  forall x y : Words,	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ [inr mon_unit] ++ y) =	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ y)	1 goal (ID 1361)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  forall x y : Words,	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ [inr mon_unit] ++ y) =	  (fun w : Words =>	   fold_right X (H + K)	     (fun X0 : H + K =>	      match X0 with	      | inl a => (fun (l : H) (x0 : X) => h l * x0) a	      | inr b => (fun (r : K) (x0 : X) => k r * x0) b	      end) mon_unit w) (x ++ y)	1 goal (ID 2293)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit (x ++ [inr mon_unit] ++ y) =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit (x ++ y)	";
            responses[i]=data;
          

            i = 571;
            data = "1 goal (ID 2296)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end)	       (fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x0 : X => h a * x0	           | inr b => fun x0 : X => k b * x0	           end) mon_unit y) [inr mon_unit]) x =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end) mon_unit y) x	";
            responses[i]=data;
          

            i = 572;
            data = "1 goal (ID 2326)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end) mon_unit y) [inr mon_unit] =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y	";
            responses[i]=data;
          

            i = 573;
            data = "1 goal (ID 2329)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  ============================	  k mon_unit *	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y	";
            responses[i]=data;
          

            i = 574;
            data = "1 goal (ID 2332)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  x, y : Words	  ============================	  mon_unit *	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y	";
            responses[i]=data;
          

            i = 575;
            data = "No more goals.	No more goals.	";
            responses[i]=data;
          

            i = 576;
            data = "1 goal (ID 490)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  IsSemiGroupPreserving (AmalgamatedFreeProduct_rec' X h k p)	";
            responses[i]=data;
          

            i = 577;
            data = "";
            responses[i]=data;
          

            i = 578;
            data = "";
            responses[i]=data;
          

            i = 579;
            data = "1 goal (ID 911)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  y : Words	  x : Words	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit (x ++ y) =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit x *	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y	1 goal (ID 912)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  y : Words	  x : Words	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end)	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a => fun x0 : X => h a * x0	        | inr b => fun x0 : X => k b * x0	        end) mon_unit y) x =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit x *	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit y	";
            responses[i]=data;
          

            i = 580;
            data = "1 goal (ID 924)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  y : Words	  x : Words	  s := fold_right X (H + K)	         (fun X0 : H + K =>	          match X0 with	          | inl l => fun x0 : X => h l * x0	          | inr r => fun x0 : X => k r * x0	          end) mon_unit y : X	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) s x =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x0 : X => h a * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit x * s	";
            responses[i]=data;
          

            i = 581;
            data = "2 goals (ID 928)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  y : Words	  s := fold_right X (H + K)	         (fun X0 : H + K =>	          match X0 with	          | inl l => fun x0 : X => h l * x0	          | inr r => fun x0 : X => k r * x0	          end) mon_unit y : X	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x : X => h a * x	     | inr b => fun x : X => k b * x	     end) s nil =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a => fun x : X => h a * x	     | inr b => fun x : X => k b * x	     end) mon_unit nil * s		goal 2 (ID 934) is:	 fold_right X (H + K)	   (fun X0 : H + K =>	    match X0 with	    | inl a0 => fun x0 : X => h a0 * x0	    | inr b => fun x0 : X => k b * x0	    end) s (a :: x) =	 fold_right X (H + K)	   (fun X0 : H + K =>	    match X0 with	    | inl a0 => fun x0 : X => h a0 * x0	    | inr b => fun x0 : X => k b * x0	    end) mon_unit (a :: x) * s	";
            responses[i]=data;
          

            i = 582;
            data = "1 goal (ID 934)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  y : Words	  a : H + K	  x : list (H + K)	  s := fold_right X (H + K)	         (fun X0 : H + K =>	          match X0 with	          | inl l => fun x0 : X => h l * x0	          | inr r => fun x0 : X => k r * x0	          end) mon_unit y : X	  IHx : fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x : X => h a * x	           | inr b => fun x : X => k b * x	           end) s x =	        fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x : X => h a * x	           | inr b => fun x : X => k b * x	           end) mon_unit x * s	  ============================	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a0 => fun x0 : X => h a0 * x0	     | inr b => fun x0 : X => k b * x0	     end) s (a :: x) =	  fold_right X (H + K)	    (fun X0 : H + K =>	     match X0 with	     | inl a0 => fun x0 : X => h a0 * x0	     | inr b => fun x0 : X => k b * x0	     end) mon_unit (a :: x) * s	";
            responses[i]=data;
          

            i = 583;
            data = "1 goal (ID 1009)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  y : Words	  a : H + K	  x : list (H + K)	  s := fold_right X (H + K)	         (fun X0 : H + K =>	          match X0 with	          | inl l => fun x0 : X => h l * x0	          | inr r => fun x0 : X => k r * x0	          end) mon_unit y : X	  IHx : fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x : X => h a * x	           | inr b => fun x : X => k b * x	           end) s x =	        fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x : X => h a * x	           | inr b => fun x : X => k b * x	           end) mon_unit x * s	  ============================	  match a with	  | inl a0 => fun x0 : X => h a0 * x0	  | inr b => fun x0 : X => k b * x0	  end	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a0 => fun x0 : X => h a0 * x0	        | inr b => fun x0 : X => k b * x0	        end) s x) =	  match a with	  | inl a0 => fun x0 : X => h a0 * x0	  | inr b => fun x0 : X => k b * x0	  end	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a0 => fun x0 : X => h a0 * x0	        | inr b => fun x0 : X => k b * x0	        end) mon_unit x) * s	";
            responses[i]=data;
          

            i = 584;
            data = "1 goal (ID 1010)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  y : Words	  a : H + K	  x : list (H + K)	  s := fold_right X (H + K)	         (fun X0 : H + K =>	          match X0 with	          | inl l => fun x0 : X => h l * x0	          | inr r => fun x0 : X => k r * x0	          end) mon_unit y : X	  IHx : fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x : X => h a * x	           | inr b => fun x : X => k b * x	           end) s x =	        fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x : X => h a * x	           | inr b => fun x : X => k b * x	           end) mon_unit x * s	  ============================	  match a with	  | inl a0 => fun x0 : X => h a0 * x0	  | inr b => fun x0 : X => k b * x0	  end	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a0 => fun x0 : X => h a0 * x0	        | inr b => fun x0 : X => k b * x0	        end) mon_unit x * s) =	  match a with	  | inl a0 => fun x0 : X => h a0 * x0	  | inr b => fun x0 : X => k b * x0	  end	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a0 => fun x0 : X => h a0 * x0	        | inr b => fun x0 : X => k b * x0	        end) mon_unit x) * s	";
            responses[i]=data;
          

            i = 585;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 586;
            data = "";
            responses[i]=data;
          

            i = 587;
            data = "1 goal (ID 515)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  GroupHomomorphism AmalgamatedFreeProduct X	";
            responses[i]=data;
          

            i = 588;
            data = "";
            responses[i]=data;
          

            i = 589;
            data = "2 goals (ID 525)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  AmalgamatedFreeProduct -> X		goal 2 (ID 527) is:	 IsSemiGroupPreserving ?f	";
            responses[i]=data;
          

            i = 590;
            data = "1 goal (ID 527)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : h o f == k o g	  ============================	  IsSemiGroupPreserving (AmalgamatedFreeProduct_rec' X h k p)	";
            responses[i]=data;
          

            i = 591;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 592;
            data = "";
            responses[i]=data;
          

            i = 593;
            data = "1 goal (ID 516)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  GroupHomomorphism H AmalgamatedFreeProduct	";
            responses[i]=data;
          

            i = 594;
            data = "";
            responses[i]=data;
          

            i = 595;
            data = "2 goals (ID 526)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  H -> AmalgamatedFreeProduct		goal 2 (ID 528) is:	 IsSemiGroupPreserving ?f	";
            responses[i]=data;
          

            i = 596;
            data = "1 goal (ID 526)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  H -> AmalgamatedFreeProduct	1 goal (ID 535)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : H	  ============================	  AmalgamatedFreeProduct	";
            responses[i]=data;
          

            i = 597;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 528) is:	 IsSemiGroupPreserving (fun x : H => amal_eta [inl x])	";
            responses[i]=data;
          

            i = 598;
            data = "1 goal (ID 528)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  IsSemiGroupPreserving (fun x : H => amal_eta [inl x])	1 goal (ID 542)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : H	  ============================	  amal_eta [inl (x * y)] = amal_eta [inl x] * amal_eta [inl y]	";
            responses[i]=data;
          

            i = 599;
            data = "1 goal (ID 549)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : H	  ============================	  amal_eta ([inl (x * y)] ++ nil) = amal_eta [inl x] * amal_eta [inl y]	";
            responses[i]=data;
          

            i = 600;
            data = "1 goal (ID 558)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : H	  ============================	  amal_eta (nil ++ (inl x :: [inl y]) ++ nil) =	  amal_eta [inl x] * amal_eta [inl y]	";
            responses[i]=data;
          

            i = 601;
            data = "1 goal (ID 561)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : H	  ============================	  amal_eta (nil ++ inl x :: [inl y]) = amal_eta [inl x] * amal_eta [inl y]	";
            responses[i]=data;
          

            i = 602;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 603;
            data = "";
            responses[i]=data;
          

            i = 604;
            data = "1 goal (ID 517)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  GroupHomomorphism K AmalgamatedFreeProduct	";
            responses[i]=data;
          

            i = 605;
            data = "";
            responses[i]=data;
          

            i = 606;
            data = "2 goals (ID 527)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  K -> AmalgamatedFreeProduct		goal 2 (ID 529) is:	 IsSemiGroupPreserving ?f	";
            responses[i]=data;
          

            i = 607;
            data = "1 goal (ID 527)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  K -> AmalgamatedFreeProduct	1 goal (ID 536)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x : K	  ============================	  AmalgamatedFreeProduct	";
            responses[i]=data;
          

            i = 608;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 529) is:	 IsSemiGroupPreserving (fun x : K => amal_eta [inr x])	";
            responses[i]=data;
          

            i = 609;
            data = "1 goal (ID 529)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  ============================	  IsSemiGroupPreserving (fun x : K => amal_eta [inr x])	1 goal (ID 543)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : K	  ============================	  amal_eta [inr (x * y)] = amal_eta [inr x] * amal_eta [inr y]	";
            responses[i]=data;
          

            i = 610;
            data = "1 goal (ID 550)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : K	  ============================	  amal_eta ([inr (x * y)] ++ nil) = amal_eta [inr x] * amal_eta [inr y]	";
            responses[i]=data;
          

            i = 611;
            data = "1 goal (ID 559)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : K	  ============================	  amal_eta (nil ++ (inr x :: [inr y]) ++ nil) =	  amal_eta [inr x] * amal_eta [inr y]	";
            responses[i]=data;
          

            i = 612;
            data = "1 goal (ID 562)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  x, y : K	  ============================	  amal_eta (nil ++ inr x :: [inr y]) = amal_eta [inr x] * amal_eta [inr y]	";
            responses[i]=data;
          

            i = 613;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 614;
            data = "";
            responses[i]=data;
          

            i = 615;
            data = "1 goal (ID 542)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  ============================	  {h : GroupHomomorphism H X & {k : GroupHomomorphism K X & h o f == k o g}} <~>	  GroupHomomorphism AmalgamatedFreeProduct X	";
            responses[i]=data;
          

            i = 616;
            data = "";
            responses[i]=data;
          

            i = 617;
            data = "4 goals (ID 566)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  ============================	  {h : GroupHomomorphism H X & {k : GroupHomomorphism K X & h o f == k o g}} ->	  GroupHomomorphism AmalgamatedFreeProduct X		goal 2 (ID 568) is:	 GroupHomomorphism AmalgamatedFreeProduct X ->	 {h : GroupHomomorphism H X & {k : GroupHomomorphism K X & h o f == k o g}}	goal 3 (ID 570) is:	 ?f o ?g == idmap	goal 4 (ID 572) is:	 ?g o ?f == idmap	";
            responses[i]=data;
          

            i = 618;
            data = "3 goals (ID 568)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  ============================	  GroupHomomorphism AmalgamatedFreeProduct X ->	  {h : GroupHomomorphism H X & {k : GroupHomomorphism K X & h o f == k o g}}		goal 2 (ID 570) is:	 (fun	    X0 : {h : GroupHomomorphism H X &	         {k : GroupHomomorphism K X & h o f == k o g}} =>	  (fun (h : GroupHomomorphism H X)	     (proj2 : {k : GroupHomomorphism K X &	              (fun x : G => h (f x)) == (fun x : G => k (g x))}) =>	   (fun (k : GroupHomomorphism K X)	      (p : (fun x : G => h (f x)) == (fun x : G => k (g x))) =>	    AmalgamatedFreeProduct_rec X h k p) proj2.1 proj2.2) X0.1 X0.2) o 	 ?g == idmap	goal 3 (ID 572) is:	 ?g	 o (fun	      X0 : {h : GroupHomomorphism H X &	           {k : GroupHomomorphism K X & h o f == k o g}} =>	    (fun (h : GroupHomomorphism H X)	       (proj2 : {k : GroupHomomorphism K X &	                (fun x : G => h (f x)) == (fun x : G => k (g x))}) =>	     (fun (k : GroupHomomorphism K X)	        (p : (fun x : G => h (f x)) == (fun x : G => k (g x))) =>	      AmalgamatedFreeProduct_rec X h k p) proj2.1 proj2.2) X0.1 X0.2) ==	 idmap	";
            responses[i]=data;
          

            i = 619;
            data = "1 goal (ID 568)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  ============================	  GroupHomomorphism AmalgamatedFreeProduct X ->	  {h : GroupHomomorphism H X & {k : GroupHomomorphism K X & h o f == k o g}}	1 goal (ID 594)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  ============================	  {h : GroupHomomorphism H X & {k : GroupHomomorphism K X & h o f == k o g}}	";
            responses[i]=data;
          

            i = 620;
            data = "1 goal (ID 599)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  ============================	  {k : GroupHomomorphism K X &	  (fun x : G => grp_homo_compose r amal_inl (f x)) == (fun x : G => k (g x))}	";
            responses[i]=data;
          

            i = 621;
            data = "1 goal (ID 604)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  ============================	  (fun x : G => grp_homo_compose r amal_inl (f x)) ==	  (fun x : G => grp_homo_compose r amal_inr (g x))	";
            responses[i]=data;
          

            i = 622;
            data = "1 goal (ID 606)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  x : G	  ============================	  grp_homo_compose r amal_inl (f x) = grp_homo_compose r amal_inr (g x)	";
            responses[i]=data;
          

            i = 623;
            data = "1 goal (ID 611)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  x : G	  ============================	  amal_inl (f x) = amal_inr (g x)	";
            responses[i]=data;
          

            i = 624;
            data = "1 goal (ID 612)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  x : G	  ============================	  amal_eta [inl (f x)] = amal_eta [inr (g x)]	";
            responses[i]=data;
          

            i = 625;
            data = "1 goal (ID 619)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  x : G	  ============================	  amal_eta ([inl (f x)] ++ nil) = amal_eta [inr (g x)]	";
            responses[i]=data;
          

            i = 626;
            data = "1 goal (ID 632)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  x : G	  ============================	  amal_eta ([inl (f x)] ++ nil) = amal_eta ([inr (g x)] ++ nil)	";
            responses[i]=data;
          

            i = 627;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	2 goals		goal 1 (ID 570) is:	 (fun	    X0 : {h : GroupHomomorphism H X &	         {k : GroupHomomorphism K X & h o f == k o g}} =>	  (fun (h : GroupHomomorphism H X)	     (proj2 : {k : GroupHomomorphism K X &	              (fun x : G => h (f x)) == (fun x : G => k (g x))}) =>	   (fun (k : GroupHomomorphism K X)	      (p : (fun x : G => h (f x)) == (fun x : G => k (g x))) =>	    AmalgamatedFreeProduct_rec X h k p) proj2.1 proj2.2) X0.1 X0.2)	 o (fun r : GroupHomomorphism AmalgamatedFreeProduct X =>	    (grp_homo_compose r amal_inl; grp_homo_compose r amal_inr;	    (fun x : G =>	     ap r	       (internal_paths_rew (list (H + K)) ([inl (f x)] ++ nil)	          (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x)])	          (internal_paths_rew (list (H + K)) ([inr (g x)] ++ nil)	             (fun l : list (H + K) =>	              amal_eta ([inl (f x)] ++ nil) = amal_eta l)	             (amal_tau nil nil x) [inr (g x)] (word_concat_w_nil [inr (g x)]))	          [inl (f x)] (word_concat_w_nil [inl (f x)])	        :	        amal_inl (f x) = amal_inr (g x)))	    :	    (fun x : G => grp_homo_compose r amal_inl (f x)) ==	    (fun x : G => grp_homo_compose r amal_inr (g x)))) == idmap	goal 2 (ID 572) is:	 (fun r : GroupHomomorphism AmalgamatedFreeProduct X =>	  (grp_homo_compose r amal_inl; grp_homo_compose r amal_inr;	  (fun x : G =>	   ap r	     (internal_paths_rew (list (H + K)) ([inl (f x)] ++ nil)	        (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x)])	        (internal_paths_rew (list (H + K)) ([inr (g x)] ++ nil)	           (fun l : list (H + K) =>	            amal_eta ([inl (f x)] ++ nil) = amal_eta l) 	           (amal_tau nil nil x) [inr (g x)] (word_concat_w_nil [inr (g x)]))	        [inl (f x)] (word_concat_w_nil [inl (f x)])	      :	      amal_inl (f x) = amal_inr (g x)))	  :	  (fun x : G => grp_homo_compose r amal_inl (f x)) ==	  (fun x : G => grp_homo_compose r amal_inr (g x))))	 o (fun	      X0 : {h : GroupHomomorphism H X &	           {k : GroupHomomorphism K X & h o f == k o g}} =>	    (fun (h : GroupHomomorphism H X)	       (proj2 : {k : GroupHomomorphism K X &	                (fun x : G => h (f x)) == (fun x : G => k (g x))}) =>	     (fun (k : GroupHomomorphism K X)	        (p : (fun x : G => h (f x)) == (fun x : G => k (g x))) =>	      AmalgamatedFreeProduct_rec X h k p) proj2.1 proj2.2) X0.1 X0.2) ==	 idmap	";
            responses[i]=data;
          

            i = 628;
            data = "2 goals (ID 570)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  ============================	  (fun	     X0 : {h : GroupHomomorphism H X &	          {k : GroupHomomorphism K X & h o f == k o g}} =>	   (fun (h : GroupHomomorphism H X)	      (proj2 : {k : GroupHomomorphism K X &	               (fun x : G => h (f x)) == (fun x : G => k (g x))}) =>	    (fun (k : GroupHomomorphism K X)	       (p : (fun x : G => h (f x)) == (fun x : G => k (g x))) =>	     AmalgamatedFreeProduct_rec X h k p) proj2.1 proj2.2) X0.1 X0.2)	  o (fun r : GroupHomomorphism AmalgamatedFreeProduct X =>	     (grp_homo_compose r amal_inl; grp_homo_compose r amal_inr;	     (fun x : G =>	      ap r	        (internal_paths_rew (list (H + K)) ([inl (f x)] ++ nil)	           (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x)])	           (internal_paths_rew (list (H + K)) ([inr (g x)] ++ nil)	              (fun l : list (H + K) =>	               amal_eta ([inl (f x)] ++ nil) = amal_eta l)	              (amal_tau nil nil x) [inr (g x)]	              (word_concat_w_nil [inr (g x)])) [inl (f x)]	           (word_concat_w_nil [inl (f x)])	         :	         amal_inl (f x) = amal_inr (g x)))	     :	     (fun x : G => grp_homo_compose r amal_inl (f x)) ==	     (fun x : G => grp_homo_compose r amal_inr (g x)))) == idmap		goal 2 (ID 572) is:	 (fun r : GroupHomomorphism AmalgamatedFreeProduct X =>	  (grp_homo_compose r amal_inl; grp_homo_compose r amal_inr;	  (fun x : G =>	   ap r	     (internal_paths_rew (list (H + K)) ([inl (f x)] ++ nil)	        (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x)])	        (internal_paths_rew (list (H + K)) ([inr (g x)] ++ nil)	           (fun l : list (H + K) =>	            amal_eta ([inl (f x)] ++ nil) = amal_eta l) 	           (amal_tau nil nil x) [inr (g x)] (word_concat_w_nil [inr (g x)]))	        [inl (f x)] (word_concat_w_nil [inl (f x)])	      :	      amal_inl (f x) = amal_inr (g x)))	  :	  (fun x : G => grp_homo_compose r amal_inl (f x)) ==	  (fun x : G => grp_homo_compose r amal_inr (g x))))	 o (fun	      X0 : {h : GroupHomomorphism H X &	           {k : GroupHomomorphism K X & h o f == k o g}} =>	    (fun (h : GroupHomomorphism H X)	       (proj2 : {k : GroupHomomorphism K X &	                (fun x : G => h (f x)) == (fun x : G => k (g x))}) =>	     (fun (k : GroupHomomorphism K X)	        (p : (fun x : G => h (f x)) == (fun x : G => k (g x))) =>	      AmalgamatedFreeProduct_rec X h k p) proj2.1 proj2.2) X0.1 X0.2) ==	 idmap	1 goal (ID 570)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  ============================	  (fun	     X0 : {h : GroupHomomorphism H X &	          {k : GroupHomomorphism K X & h o f == k o g}} =>	   (fun (h : GroupHomomorphism H X)	      (proj2 : {k : GroupHomomorphism K X &	               (fun x : G => h (f x)) == (fun x : G => k (g x))}) =>	    (fun (k : GroupHomomorphism K X)	       (p : (fun x : G => h (f x)) == (fun x : G => k (g x))) =>	     AmalgamatedFreeProduct_rec X h k p) proj2.1 proj2.2) X0.1 X0.2)	  o (fun r : GroupHomomorphism AmalgamatedFreeProduct X =>	     (grp_homo_compose r amal_inl; grp_homo_compose r amal_inr;	     (fun x : G =>	      ap r	        (internal_paths_rew (list (H + K)) ([inl (f x)] ++ nil)	           (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x)])	           (internal_paths_rew (list (H + K)) ([inr (g x)] ++ nil)	              (fun l : list (H + K) =>	               amal_eta ([inl (f x)] ++ nil) = amal_eta l)	              (amal_tau nil nil x) [inr (g x)]	              (word_concat_w_nil [inr (g x)])) [inl (f x)]	           (word_concat_w_nil [inl (f x)])	         :	         amal_inl (f x) = amal_inr (g x)))	     :	     (fun x : G => grp_homo_compose r amal_inl (f x)) ==	     (fun x : G => grp_homo_compose r amal_inr (g x)))) == idmap	1 goal (ID 642)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  ============================	  AmalgamatedFreeProduct_rec X (grp_homo_compose r amal_inl)	    (grp_homo_compose r amal_inr)	    (fun x : G =>	     ap r	       (internal_paths_rew (list (H + K)) ([inl (f x)] ++ nil)	          (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x)])	          (internal_paths_rew (list (H + K)) ([inr (g x)] ++ nil)	             (fun l : list (H + K) =>	              amal_eta ([inl (f x)] ++ nil) = amal_eta l)	             (amal_tau nil nil x) [inr (g x)] (word_concat_w_nil [inr (g x)]))	          [inl (f x)] (word_concat_w_nil [inl (f x)]))) = r	";
            responses[i]=data;
          

            i = 629;
            data = "1 goal (ID 651)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  ============================	  AmalgamatedFreeProduct_rec X (grp_homo_compose r amal_inl)	    (grp_homo_compose r amal_inr)	    (fun x : G =>	     ap r	       (internal_paths_rew (list (H + K)) ([inl (f x)] ++ nil)	          (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x)])	          (internal_paths_rew (list (H + K)) ([inr (g x)] ++ nil)	             (fun l : list (H + K) =>	              amal_eta ([inl (f x)] ++ nil) = amal_eta l)	             (amal_tau nil nil x) [inr (g x)] (word_concat_w_nil [inr (g x)]))	          [inl (f x)] (word_concat_w_nil [inl (f x)]))) == r	";
            responses[i]=data;
          

            i = 630;
            data = "1 goal (ID 703)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  ============================	  forall w : Words,	  (fun x : amal_type =>	   AmalgamatedFreeProduct_rec X (grp_homo_compose r amal_inl)	     (grp_homo_compose r amal_inr)	     (fun x0 : G =>	      ap r	        (internal_paths_rew (list (H + K)) ([inl (f x0)] ++ nil)	           (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x0)])	           (internal_paths_rew (list (H + K)) ([inr (g x0)] ++ nil)	              (fun l : list (H + K) =>	               amal_eta ([inl (f x0)] ++ nil) = amal_eta l)	              (amal_tau nil nil x0) [inr (g x0)]	              (word_concat_w_nil [inr (g x0)])) [inl (f x0)]	           (word_concat_w_nil [inl (f x0)]))) x = 	   r x) (amal_eta w)	";
            responses[i]=data;
          

            i = 631;
            data = "1 goal (ID 859)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  x : Words	  ============================	  (fun x0 : amal_type =>	   AmalgamatedFreeProduct_rec X (grp_homo_compose r amal_inl)	     (grp_homo_compose r amal_inr)	     (fun x1 : G =>	      ap r	        (internal_paths_rew (list (H + K)) ([inl (f x1)] ++ nil)	           (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x1)])	           (internal_paths_rew (list (H + K)) ([inr (g x1)] ++ nil)	              (fun l : list (H + K) =>	               amal_eta ([inl (f x1)] ++ nil) = amal_eta l)	              (amal_tau nil nil x1) [inr (g x1)]	              (word_concat_w_nil [inr (g x1)])) [inl (f x1)]	           (word_concat_w_nil [inl (f x1)]))) x0 = 	   r x0) (amal_eta x)	";
            responses[i]=data;
          

            i = 632;
            data = "2 goals (ID 863)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  ============================	  AmalgamatedFreeProduct_rec X (grp_homo_compose r amal_inl)	    (grp_homo_compose r amal_inr)	    (fun x : G =>	     ap r	       (internal_paths_rew (list (H + K)) ([inl (f x)] ++ nil)	          (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x)])	          (internal_paths_rew (list (H + K)) ([inr (g x)] ++ nil)	             (fun l : list (H + K) =>	              amal_eta ([inl (f x)] ++ nil) = amal_eta l)	             (amal_tau nil nil x) [inr (g x)] (word_concat_w_nil [inr (g x)]))	          [inl (f x)] (word_concat_w_nil [inl (f x)]))) 	    (amal_eta nil) = r (amal_eta nil)		goal 2 (ID 867) is:	 AmalgamatedFreeProduct_rec X (grp_homo_compose r amal_inl)	   (grp_homo_compose r amal_inr)	   (fun x0 : G =>	    ap r	      (internal_paths_rew (list (H + K)) ([inl (f x0)] ++ nil)	         (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x0)])	         (internal_paths_rew (list (H + K)) ([inr (g x0)] ++ nil)	            (fun l : list (H + K) =>	             amal_eta ([inl (f x0)] ++ nil) = amal_eta l)	            (amal_tau nil nil x0) [inr (g x0)]	            (word_concat_w_nil [inr (g x0)])) [inl (f x0)]	         (word_concat_w_nil [inl (f x0)]))) (amal_eta (a :: x)) =	 r (amal_eta (a :: x))	";
            responses[i]=data;
          

            i = 633;
            data = "1 goal (ID 867)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  a : H + K	  x : list (H + K)	  IHx : AmalgamatedFreeProduct_rec X (grp_homo_compose r amal_inl)	          (grp_homo_compose r amal_inr)	          (fun x : G =>	           ap r	             (internal_paths_rew (list (H + K)) ([inl (f x)] ++ nil)	                (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x)])	                (internal_paths_rew (list (H + K)) 	                   ([inr (g x)] ++ nil)	                   (fun l : list (H + K) =>	                    amal_eta ([inl (f x)] ++ nil) = amal_eta l)	                   (amal_tau nil nil x) [inr (g x)]	                   (word_concat_w_nil [inr (g x)])) [	                inl (f x)] (word_concat_w_nil [inl (f x)]))) 	          (amal_eta x) = r (amal_eta x)	  ============================	  AmalgamatedFreeProduct_rec X (grp_homo_compose r amal_inl)	    (grp_homo_compose r amal_inr)	    (fun x0 : G =>	     ap r	       (internal_paths_rew (list (H + K)) ([inl (f x0)] ++ nil)	          (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x0)])	          (internal_paths_rew (list (H + K)) ([inr (g x0)] ++ nil)	             (fun l : list (H + K) =>	              amal_eta ([inl (f x0)] ++ nil) = amal_eta l)	             (amal_tau nil nil x0) [inr (g x0)]	             (word_concat_w_nil [inr (g x0)])) [inl (f x0)]	          (word_concat_w_nil [inl (f x0)]))) (amal_eta (a :: x)) =	  r (amal_eta (a :: x))	";
            responses[i]=data;
          

            i = 634;
            data = "1 goal (ID 882)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  a : H + K	  x : list (H + K)	  IHx : fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x : X => r (amal_eta [inl a]) * x	           | inr b => fun x : X => r (amal_eta [inr b]) * x	           end) mon_unit x = r (amal_eta x)	  ============================	  match a with	  | inl a0 => fun x0 : X => r (amal_eta [inl a0]) * x0	  | inr b => fun x0 : X => r (amal_eta [inr b]) * x0	  end	    (fold_right X (H + K)	       (fun X0 : H + K =>	        match X0 with	        | inl a0 => fun x0 : X => r (amal_eta [inl a0]) * x0	        | inr b => fun x0 : X => r (amal_eta [inr b]) * x0	        end) mon_unit x) = r (amal_eta (a :: x))	";
            responses[i]=data;
          

            i = 635;
            data = "1 goal (ID 883)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  r : GroupHomomorphism AmalgamatedFreeProduct X	  a : H + K	  x : list (H + K)	  IHx : fold_right X (H + K)	          (fun X0 : H + K =>	           match X0 with	           | inl a => fun x : X => r (amal_eta [inl a]) * x	           | inr b => fun x : X => r (amal_eta [inr b]) * x	           end) mon_unit x = r (amal_eta x)	  ============================	  match a with	  | inl a0 => fun x0 : X => r (amal_eta [inl a0]) * x0	  | inr b => fun x0 : X => r (amal_eta [inr b]) * x0	  end (r (amal_eta x)) = r (amal_eta (a :: x))	";
            responses[i]=data;
          

            i = 636;
            data = "<infomsg>	This subproof is complete, but there are some unfocused goals.	Try unfocusing with \"}\".	</infomsg>	1 goal		goal 1 (ID 572) is:	 (fun r : GroupHomomorphism AmalgamatedFreeProduct X =>	  (grp_homo_compose r amal_inl; grp_homo_compose r amal_inr;	  (fun x : G =>	   ap r	     (internal_paths_rew (list (H + K)) ([inl (f x)] ++ nil)	        (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x)])	        (internal_paths_rew (list (H + K)) ([inr (g x)] ++ nil)	           (fun l : list (H + K) =>	            amal_eta ([inl (f x)] ++ nil) = amal_eta l) 	           (amal_tau nil nil x) [inr (g x)] (word_concat_w_nil [inr (g x)]))	        [inl (f x)] (word_concat_w_nil [inl (f x)])	      :	      amal_inl (f x) = amal_inr (g x)))	  :	  (fun x : G => grp_homo_compose r amal_inl (f x)) ==	  (fun x : G => grp_homo_compose r amal_inr (g x))))	 o (fun	      X0 : {h : GroupHomomorphism H X &	           {k : GroupHomomorphism K X & h o f == k o g}} =>	    (fun (h : GroupHomomorphism H X)	       (proj2 : {k : GroupHomomorphism K X &	                (fun x : G => h (f x)) == (fun x : G => k (g x))}) =>	     (fun (k : GroupHomomorphism K X)	        (p : (fun x : G => h (f x)) == (fun x : G => k (g x))) =>	      AmalgamatedFreeProduct_rec X h k p) proj2.1 proj2.2) X0.1 X0.2) ==	 idmap	";
            responses[i]=data;
          

            i = 637;
            data = "1 goal (ID 572)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  ============================	  (fun r : GroupHomomorphism AmalgamatedFreeProduct X =>	   (grp_homo_compose r amal_inl; grp_homo_compose r amal_inr;	   (fun x : G =>	    ap r	      (internal_paths_rew (list (H + K)) ([inl (f x)] ++ nil)	         (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x)])	         (internal_paths_rew (list (H + K)) ([inr (g x)] ++ nil)	            (fun l : list (H + K) =>	             amal_eta ([inl (f x)] ++ nil) = amal_eta l) 	            (amal_tau nil nil x) [inr (g x)] (word_concat_w_nil [inr (g x)]))	         [inl (f x)] (word_concat_w_nil [inl (f x)])	       :	       amal_inl (f x) = amal_inr (g x)))	   :	   (fun x : G => grp_homo_compose r amal_inl (f x)) ==	   (fun x : G => grp_homo_compose r amal_inr (g x))))	  o (fun	       X0 : {h : GroupHomomorphism H X &	            {k : GroupHomomorphism K X & h o f == k o g}} =>	     (fun (h : GroupHomomorphism H X)	        (proj2 : {k : GroupHomomorphism K X &	                 (fun x : G => h (f x)) == (fun x : G => k (g x))}) =>	      (fun (k : GroupHomomorphism K X)	         (p : (fun x : G => h (f x)) == (fun x : G => k (g x))) =>	       AmalgamatedFreeProduct_rec X h k p) proj2.1 proj2.2) X0.1 X0.2) ==	  idmap	1 goal (ID 924)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  hkp : {h : GroupHomomorphism H X &	        {k : GroupHomomorphism K X &	        (fun x : G => h (f x)) == (fun x : G => k (g x))}}	  ============================	  (grp_homo_compose (AmalgamatedFreeProduct_rec X hkp.1 (hkp.2).1 (hkp.2).2)	     amal_inl;	  grp_homo_compose (AmalgamatedFreeProduct_rec X hkp.1 (hkp.2).1 (hkp.2).2)	    amal_inr;	  fun x : G =>	  ap (AmalgamatedFreeProduct_rec X hkp.1 (hkp.2).1 (hkp.2).2)	    (internal_paths_rew (list (H + K)) ([inl (f x)] ++ nil)	       (fun l : list (H + K) => amal_eta l = amal_eta [inr (g x)])	       (internal_paths_rew (list (H + K)) ([inr (g x)] ++ nil)	          (fun l : list (H + K) => amal_eta ([inl (f x)] ++ nil) = amal_eta l)	          (amal_tau nil nil x) [inr (g x)] (word_concat_w_nil [inr (g x)]))	       [inl (f x)] (word_concat_w_nil [inl (f x)]))) = hkp	";
            responses[i]=data;
          

            i = 638;
            data = "1 goal (ID 935)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  hkp : {h : GroupHomomorphism H X &	        {k : GroupHomomorphism K X &	        (fun x : G => h (f x)) == (fun x : G => k (g x))}}	  ============================	  (grp_homo_compose (AmalgamatedFreeProduct_rec X hkp.1 (hkp.2).1 (hkp.2).2)	     amal_inl;	  grp_homo_compose (AmalgamatedFreeProduct_rec X hkp.1 (hkp.2).1 (hkp.2).2)	    amal_inr;	  fun x : G =>	  ap (AmalgamatedFreeProduct_rec' X hkp.1 (hkp.2).1 (hkp.2).2)	    (amal_tau nil nil x)) = hkp	";
            responses[i]=data;
          

            i = 639;
            data = "1 goal (ID 1011)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  hkp : {h : GroupHomomorphism H X &	        {k : GroupHomomorphism K X &	        (fun x : G => h (f x)) == (fun x : G => k (g x))}}	  ============================	  equiv_sigma_prod	    (fun hk : GroupHomomorphism H X * GroupHomomorphism K X =>	     (fun x : G => fst hk (f x)) == (fun x : G => snd hk (g x)))	    (grp_homo_compose	       (AmalgamatedFreeProduct_rec X hkp.1 (hkp.2).1 (hkp.2).2) amal_inl;	    grp_homo_compose (AmalgamatedFreeProduct_rec X hkp.1 (hkp.2).1 (hkp.2).2)	      amal_inr;	    fun x : G =>	    ap (AmalgamatedFreeProduct_rec' X hkp.1 (hkp.2).1 (hkp.2).2)	      (amal_tau nil nil x)) =	  equiv_sigma_prod	    (fun hk : GroupHomomorphism H X * GroupHomomorphism K X =>	     (fun x : G => fst hk (f x)) == (fun x : G => snd hk (g x))) hkp	";
            responses[i]=data;
          

            i = 640;
            data = "1 goal (ID 1331)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  hkp : {h : GroupHomomorphism H X &	        {k : GroupHomomorphism K X &	        (fun x : G => h (f x)) == (fun x : G => k (g x))}}	  ============================	  (equiv_sigma_prod	     (fun hk : GroupHomomorphism H X * GroupHomomorphism K X =>	      (fun x : G => fst hk (f x)) == (fun x : G => snd hk (g x)))	     (grp_homo_compose	        (AmalgamatedFreeProduct_rec X hkp.1 (hkp.2).1 (hkp.2).2) amal_inl;	     grp_homo_compose	       (AmalgamatedFreeProduct_rec X hkp.1 (hkp.2).1 (hkp.2).2) amal_inr;	     fun x : G =>	     ap (AmalgamatedFreeProduct_rec' X hkp.1 (hkp.2).1 (hkp.2).2)	       (amal_tau nil nil x))).1 =	  (equiv_sigma_prod	     (fun hk : GroupHomomorphism H X * GroupHomomorphism K X =>	      (fun x : G => fst hk (f x)) == (fun x : G => snd hk (g x))) hkp).1	";
            responses[i]=data;
          

            i = 641;
            data = "1 goal (ID 1340)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G H	  g : GroupHomomorphism G K	  H0 : Funext	  X : Group	  h : GroupHomomorphism H X	  k : GroupHomomorphism K X	  p : (fun x : G => h (f x)) == (fun x : G => k (g x))	  ============================	  (equiv_sigma_prod	     (fun hk : GroupHomomorphism H X * GroupHomomorphism K X =>	      (fun x : G => fst hk (f x)) == (fun x : G => snd hk (g x)))	     (grp_homo_compose (AmalgamatedFreeProduct_rec X h k p) amal_inl;	     grp_homo_compose (AmalgamatedFreeProduct_rec X h k p) amal_inr;	     fun x : G =>	     ap (AmalgamatedFreeProduct_rec' X h k p) (amal_tau nil nil x))).1 =	  (equiv_sigma_prod	     (fun hk : GroupHomomorphism H X * GroupHomomorphism K X =>	      (fun x : G => fst hk (f x)) == (fun x : G => snd hk (g x))) 	     (h; k; p)).1	";
            responses[i]=data;
          

            i = 642;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 643;
            data = "";
            responses[i]=data;
          

            i = 644;
            data = "";
            responses[i]=data;
          

            i = 645;
            data = "";
            responses[i]=data;
          

            i = 646;
            data = "<infomsg>FreeProduct is defined</infomsg>	<infomsg>freeproduct_inl is defined</infomsg>	";
            responses[i]=data;
          

            i = 647;
            data = "<infomsg>freeproduct_inr is defined</infomsg>	";
            responses[i]=data;
          

            i = 648;
            data = "1 goal (ID 66)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G K	  g : GroupHomomorphism H K	  ============================	  GroupHomomorphism (FreeProduct G H) K	";
            responses[i]=data;
          

            i = 649;
            data = "";
            responses[i]=data;
          

            i = 650;
            data = "1 goal (ID 92)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G K	  g : GroupHomomorphism H K	  ============================	  f o grp_trivial_rec G == g o grp_trivial_rec H	";
            responses[i]=data;
          

            i = 651;
            data = "1 goal (ID 101)	  	  G : Group	  H : Group	  K : Group	  f : GroupHomomorphism G K	  g : GroupHomomorphism H K	  ============================	  f (grp_trivial_rec G tt) = g (grp_trivial_rec H tt)	";
            responses[i]=data;
          

            i = 652;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 653;
            data = "";
            responses[i]=data;
          

            i = 654;
            data = "1 goal (ID 71)	  	  funext : Funext	  G : Group	  H : Group	  K : Group	  ============================	  GroupHomomorphism G K * GroupHomomorphism H K <~>	  GroupHomomorphism (FreeProduct G H) K	";
            responses[i]=data;
          

            i = 655;
            data = "";
            responses[i]=data;
          

            i = 656;
            data = "1 goal (ID 91)	  	  funext : Funext	  G : Group	  H : Group	  K : Group	  ============================	  {h : GroupHomomorphism G K &	  {k : GroupHomomorphism H K &	  (fun x : grp_trivial => h (grp_trivial_rec G x)) ==	  (fun x : grp_trivial => k (grp_trivial_rec H x))}} <~>	  GroupHomomorphism G K * GroupHomomorphism H K	";
            responses[i]=data;
          

            i = 657;
            data = "1 goal (ID 243)	  	  funext : Funext	  G : Group	  H : Group	  K : Group	  y : GroupHomomorphism G K	  ============================	  forall a : GroupHomomorphism H K,	  Contr	    ((fun x : grp_trivial => y (grp_trivial_rec G x)) ==	     (fun x : grp_trivial => a (grp_trivial_rec H x)))	";
            responses[i]=data;
          

            i = 658;
            data = "1 goal (ID 244)	  	  funext : Funext	  G : Group	  H : Group	  K : Group	  y : GroupHomomorphism G K	  f : GroupHomomorphism H K	  ============================	  Contr	    ((fun x : grp_trivial => y (grp_trivial_rec G x)) ==	     (fun x : grp_trivial => f (grp_trivial_rec H x)))	";
            responses[i]=data;
          

            i = 659;
            data = "1 goal (ID 309)	  	  funext : Funext	  G : Group	  H : Group	  K : Group	  y : GroupHomomorphism G K	  f : GroupHomomorphism H K	  ============================	  forall a : grp_trivial,	  Contr (y (grp_trivial_rec G a) = f (grp_trivial_rec H a))	";
            responses[i]=data;
          

            i = 660;
            data = "1 goal (ID 467)	  	  funext : Funext	  G : Group	  H : Group	  K : Group	  y : GroupHomomorphism G K	  f : GroupHomomorphism H K	  ============================	  merely (y (grp_trivial_rec G tt) = f (grp_trivial_rec H tt))	";
            responses[i]=data;
          

            i = 661;
            data = "1 goal (ID 470)	  	  funext : Funext	  G : Group	  H : Group	  K : Group	  y : GroupHomomorphism G K	  f : GroupHomomorphism H K	  ============================	  y (grp_trivial_rec G tt) = f (grp_trivial_rec H tt)	";
            responses[i]=data;
          

            i = 662;
            data = "No more goals.	";
            responses[i]=data;
          

            i = 663;
            data = "";
            responses[i]=data;
          

            i = 664;
            data = "";
            responses[i]=data;
          

            i = 665;
            data = "";
            responses[i]=data;
          

            i = 666;
            data = "";
            responses[i]=data;
          

            i = 667;
            data = "";
            responses[i]=data;
          

            i = 668;
            data = "";
            responses[i]=data;
          

            i = 669;
            data = "";
            responses[i]=data;
          

            i = 670;
            data = "";
            responses[i]=data;
          

            i = 671;
            data = "";
            responses[i]=data;
          

            i = 672;
            data = "";
            responses[i]=data;
          

            i = 673;
            data = "";
            responses[i]=data;
          

            i = 674;
            data = "";
            responses[i]=data;
          
        };
        
        function get_response(id) {
          return responses[id];
        };

        function set_response(response, scene) {
          goalId = "goal"+scene;
          elById = document.getElementById(goalId);
          if(elById){ 
            goalSpan = elById.getElementsByTagName("span")[0];
            goalSpan.innerHTML = response.replace(/	/g , '\n');
          }
        };
      </script>
</head>
<body onload="set_array()"><div id="page" scenenumber="0" class="doc">
<div id="header" scenenumber="1" class="doc">
</div>
<div id="main" scenenumber="3" class="doc">
<h1 class="libtitle">Library HoTT.Algebra.Groups.FreeProduct</h1>
<div scenenumber="3" class="code">
<span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(6, '0_3_3');
      ">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Basics.html#"><span class="id" title="library">Basics</span></a> <a class="idref" href="HoTT.Types.html#"><span class="id" title="library">Types</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(7, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Cubical.html#"><span class="id" title="library">Cubical</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(8, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Colimits.Coeq.html#"><span class="id" title="library">Colimits.Coeq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(9, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Spaces.List.html#"><span class="id" title="library">Spaces.List</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(10, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Colimits.Pushout.html#"><span class="id" title="library">Colimits.Pushout</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(11, '0_3_3');
      "><br>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#"><span class="id" title="library">Algebra.Groups.Group</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(12, '0_3_3');
      "><br>
<br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">list_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(13, '0_3_3');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">mc_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(14, '0_3_3');
      "><br>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">mc_mult_scope</span>.</span><span class="command" onmouseout="
      mouseout('0_3_3');
      " onmouseover="
      mouseover(15, '0_3_3');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_3"><pre><span></span></pre></div>
<div class="doc" scenenumber="5">
In this file we define the amalgamated free product of a span of group homomorphisms as a HIT. 
<div class="doc" scenenumber="1"> </div>

 We wish to define the amalgamated free product of a span of group homomorphisms f : G -&gt; H, g : G -&gt; K as the following HIT:

<div class="doc" scenenumber="3"> </div>

  HIT M(f,g)
   | amal_eta : list (H + K) -&gt; M(f,g)
   | mu_H : forall (x y : list (H + K)) (h1 h2 : H),
      amal_eta (x ++ <span class="inlinecode"><a class="idref" href="HoTT.Categories.Functor.Sum.html#inl"><span class="id" title="definition">inl</span></a></span> <span class="inlinecode"><span class="id" title="var">h1</span>,</span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.Functor.Sum.html#inl"><span class="id" title="definition">inl</span></a></span> <span class="inlinecode"><span class="id" title="var">h2</span></span> ++ y) = amal_eta (x ++ <span class="inlinecode"><a class="idref" href="HoTT.Categories.Functor.Sum.html#inl"><span class="id" title="definition">inl</span></a></span> <span class="inlinecode">(<span class="id" title="var">h1</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">h2</span>)</span> ++ y)
   | mu_K : forall (x y : list (H + K)) (k1 k2 : K),
      amal_eta (x ++ <span class="inlinecode"><a class="idref" href="HoTT.Categories.Functor.Sum.html#inr"><span class="id" title="definition">inr</span></a></span> <span class="inlinecode"><span class="id" title="var">k1</span>,</span> <span class="inlinecode"><a class="idref" href="HoTT.Categories.Functor.Sum.html#inr"><span class="id" title="definition">inr</span></a></span> <span class="inlinecode"><span class="id" title="var">k2</span></span> ++ y) = amal_eta (x ++ <span class="inlinecode"><a class="idref" href="HoTT.Categories.Functor.Sum.html#inr"><span class="id" title="definition">inr</span></a></span> <span class="inlinecode">(<span class="id" title="var">k1</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">k2</span>)</span> ++ y)
   | tau : forall (x y : list (H + K)) (z : G),
      amal_eta (x ++ <span class="inlinecode"><a class="idref" href="HoTT.Categories.Functor.Sum.html#inl"><span class="id" title="definition">inl</span></a></span> <span class="inlinecode">(<a class="idref" href="HoTT.Types.Bool.html#EquivBoolEquiv.f"><span class="id" title="variable">f</span></a></span> <span class="inlinecode"><span class="id" title="var">z</span>)</span> ++ y) = amal_eta (x ++ <span class="inlinecode"><a class="idref" href="HoTT.Categories.Functor.Sum.html#inr"><span class="id" title="definition">inr</span></a></span> <span class="inlinecode">(<a class="idref" href="HoTT.Types.Bool.html#EquivBoolEquiv.g"><span class="id" title="variable">g</span></a></span> <span class="inlinecode"><span class="id" title="var">z</span>)</span> ++ y)
   | omega_H : forall (x y : list (H + K)),
      amal_eta (x ++ <span class="inlinecode"><a class="idref" href="HoTT.Categories.Functor.Sum.html#inl"><span class="id" title="definition">inl</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="projection">mon_unit</span></a></span> ++ y) = amal_eta (x ++ y)
   | omega_K : forall (x y : list (H + K)),
      amal_eta (x ++ <span class="inlinecode"><a class="idref" href="HoTT.Categories.Functor.Sum.html#inr"><span class="id" title="definition">inr</span></a></span> <span class="inlinecode"><a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="projection">mon_unit</span></a></span> ++ y) = amal_eta (x ++ y).

<div class="doc" scenenumber="57"> </div>

  We will build this HIT up sucessively out of coequalizers. 
<div class="doc" scenenumber="59"> </div>

 We will call M <span class="inlinecode"><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type"><span class="id" title="definition">amal_type</span></a></span> and prefix all the constructors with <span class="inlinecode"><span class="id" title="var">amal_</span></span> (for amalgmated free product). 
</div>
<div scenenumber="7" class="code">
<span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(83, '0_3_7');
      ">
<br>
<span class="id" title="keyword">Section</span> <a id="FreeProduct" class="idref" href="#FreeProduct"><span class="id" title="section">FreeProduct</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(84, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Context</span> (<a id="G:1" class="idref" href="#G:1"><span class="id" title="binder">G</span></a> <a id="H:2" class="idref" href="#H:2"><span class="id" title="binder">H</span></a> <a id="K:3" class="idref" href="#K:3"><span class="id" title="binder">K</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#Group"><span class="id" title="record">Group</span></a>)<br>
    (<a id="f:4" class="idref" href="#f:4"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#G:1"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#H:2"><span class="id" title="variable">H</span></a>) (<a id="g:5" class="idref" href="#g:5"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#G:1"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#K:3"><span class="id" title="variable">K</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(85, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="Words" class="idref" href="#Words"><span class="id" title="definition">Words</span></a> : <span class="id" title="keyword">Type</span> := <a class="idref" href="HoTT.Basics.Datatypes.html#list"><span class="id" title="inductive">list</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.H"><span class="id" title="variable">H</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.K"><span class="id" title="variable">K</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(86, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Notation</span> "[ x ]" := (<a class="idref" href="HoTT.Basics.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(87, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="word_concat_w_nil" class="idref" href="#word_concat_w_nil"><span class="id" title="definition">word_concat_w_nil</span></a> (<a id="x:6" class="idref" href="#x:6"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>) : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:6"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:6"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(88, '0_3_7');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(89, '0_3_7');
      "><br>
    <span class="id" title="tactic">induction</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">trivial</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(90, '0_3_7');
      "><br>
    <span class="id" title="var">cbn</span>; <span class="id" title="var">f_ap</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(91, '0_3_7');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(92, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="word_concat_w_ww" class="idref" href="#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a> (<a id="x:7" class="idref" href="#x:7"><span class="id" title="binder">x</span></a> <a id="y:8" class="idref" href="#y:8"><span class="id" title="binder">y</span></a> <a id="z:9" class="idref" href="#z:9"><span class="id" title="binder">z</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>) : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:7"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:8"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#z:9"><span class="id" title="variable">z</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:7"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:8"><span class="id" title="variable">y</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#z:9"><span class="id" title="variable">z</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(93, '0_3_7');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(94, '0_3_7');
      "><br>
    <span class="id" title="var">revert</span> <span class="id" title="var">x</span> <span class="id" title="var">z</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(95, '0_3_7');
      "><br>
    <span class="id" title="tactic">induction</span> <span class="id" title="var">y</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">z</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(96, '0_3_7');
      "><br>
    { <span class="id" title="var">f_ap</span>; <span class="id" title="tactic">symmetry</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(97, '0_3_7');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_nil"><span class="id" title="definition">word_concat_w_nil</span></a>. }<br>
    <span class="id" title="tactic">simpl</span>; <span class="id" title="var">revert</span> <span class="id" title="var">z</span> <span class="id" title="var">y</span> <span class="id" title="var">IHy</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(98, '0_3_7');
      "><br>
    <span class="id" title="tactic">induction</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">trivial</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(99, '0_3_7');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">y</span> <span class="id" title="var">IHy</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(100, '0_3_7');
      "><br>
    <span class="id" title="tactic">simpl</span>; <span class="id" title="var">f_ap</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(101, '0_3_7');
      "><br>
    <span class="id" title="tactic">apply</span> <span class="id" title="var">IHx</span>, <span class="id" title="var">IHy</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(102, '0_3_7');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(103, '0_3_7');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Fixpoint</span> <a id="word_inverse" class="idref" href="#word_inverse"><span class="id" title="definition">word_inverse</span></a> (<a id="x:10" class="idref" href="#x:10"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>) : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(104, '0_3_7');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(105, '0_3_7');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">x</span> <span class="id" title="var">xs</span>].</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(106, '0_3_7');
      "><br>
    1: <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(107, '0_3_7');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">h</span>|<span class="id" title="var">k</span>].</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(108, '0_3_7');
      "><br>
    + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><span class="id" title="var">word_inverse</span> <span class="id" title="var">xs</span><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#::mc_scope:'-'_x"><span class="id" title="notation">-</span></a> <span class="id" title="var">h</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(109, '0_3_7');
      "><br>
    + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><span class="id" title="var">word_inverse</span> <span class="id" title="var">xs</span><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#::mc_scope:'-'_x"><span class="id" title="notation">-</span></a> <span class="id" title="var">k</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(110, '0_3_7');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_7');
      " onmouseover="
      mouseover(111, '0_3_7');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_7"><pre><span></span></pre></div>
<div class="doc" scenenumber="9">
Inversion changes order of concatenation. 
</div>
<div scenenumber="11" class="code">
<span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(115, '0_3_11');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="word_inverse_ww" class="idref" href="#word_inverse_ww"><span class="id" title="definition">word_inverse_ww</span></a> (<a id="x:12" class="idref" href="#x:12"><span class="id" title="binder">x</span></a> <a id="y:13" class="idref" href="#y:13"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>)<br>
    : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse"><span class="id" title="definition">word_inverse</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:12"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:13"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse"><span class="id" title="definition">word_inverse</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:13"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse"><span class="id" title="definition">word_inverse</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:12"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(116, '0_3_11');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(117, '0_3_11');
      "><br>
    <span class="id" title="tactic">induction</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">x</span> <span class="id" title="var">xs</span>].</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(118, '0_3_11');
      "><br>
    { <span class="id" title="tactic">symmetry</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(119, '0_3_11');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_nil"><span class="id" title="definition">word_concat_w_nil</span></a>. }<br>
    <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(120, '0_3_11');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>); <span class="id" title="var">f_ap</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(121, '0_3_11');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_11');
      " onmouseover="
      mouseover(122, '0_3_11');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_11"><pre><span></span></pre></div>
<div class="doc" scenenumber="13">
There are five source types for the path constructors. We will construct this HIT as the colimit of five forks going into <span class="inlinecode"><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a></span>. We can bundle up this colimit as a single coequalizer. 
<div class="doc" scenenumber="3"> </div>

 Source types of path constructors 
</div>
<div scenenumber="15" class="code">
<span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(130, '0_3_15');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="pc1" class="idref" href="#pc1"><span class="id" title="definition">pc1</span></a> : <span class="id" title="keyword">Type</span> := <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.H"><span class="id" title="variable">H</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.H"><span class="id" title="variable">H</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(131, '0_3_15');
      "><br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="pc2" class="idref" href="#pc2"><span class="id" title="definition">pc2</span></a> : <span class="id" title="keyword">Type</span> := <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.K"><span class="id" title="variable">K</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.K"><span class="id" title="variable">K</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(132, '0_3_15');
      "><br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="pc3" class="idref" href="#pc3"><span class="id" title="definition">pc3</span></a> : <span class="id" title="keyword">Type</span> := <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.G"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(133, '0_3_15');
      "><br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="pc4" class="idref" href="#pc4"><span class="id" title="definition">pc4</span></a> : <span class="id" title="keyword">Type</span> := <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(134, '0_3_15');
      "><br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="pc5" class="idref" href="#pc5"><span class="id" title="definition">pc5</span></a> : <span class="id" title="keyword">Type</span> := <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_15');
      " onmouseover="
      mouseover(135, '0_3_15');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_15"><pre><span></span></pre></div>
<div class="doc" scenenumber="17">
End points of the first path constructor 
</div>
<div scenenumber="19" class="code">
<span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(139, '0_3_19');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="m1" class="idref" href="#m1"><span class="id" title="definition">m1</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc1"><span class="id" title="definition">pc1</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(140, '0_3_19');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(141, '0_3_19');
      "><br>
    <span class="id" title="tactic">intros</span> [[[<span class="id" title="var">x</span> <span class="id" title="var">h1</span>] <span class="id" title="var">h2</span>] <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(142, '0_3_19');
      "><br>
    <span class="id" title="tactic">exact</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">h1</span> <a class="idref" href="HoTT.Basics.Datatypes.html#::list_scope:x_'::'_x"><span class="id" title="notation">::</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">h2</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(143, '0_3_19');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(144, '0_3_19');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="m1'" class="idref" href="#m1'"><span class="id" title="definition">m1'</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc1"><span class="id" title="definition">pc1</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(145, '0_3_19');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(146, '0_3_19');
      "><br>
    <span class="id" title="tactic">intros</span> [[[<span class="id" title="var">x</span> <span class="id" title="var">h1</span>] <span class="id" title="var">h2</span>] <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(147, '0_3_19');
      "><br>
    <span class="id" title="tactic">exact</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<span class="id" title="var">h1</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <span class="id" title="var">h2</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(148, '0_3_19');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_19');
      " onmouseover="
      mouseover(149, '0_3_19');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_19"><pre><span></span></pre></div>
<div class="doc" scenenumber="21">
End points of the second path construct 
</div>
<div scenenumber="23" class="code">
<span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(153, '0_3_23');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="m2" class="idref" href="#m2"><span class="id" title="definition">m2</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc2"><span class="id" title="definition">pc2</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(154, '0_3_23');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(155, '0_3_23');
      "><br>
    <span class="id" title="tactic">intros</span> [[[<span class="id" title="var">x</span> <span class="id" title="var">k1</span>] <span class="id" title="var">k2</span>] <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(156, '0_3_23');
      "><br>
    <span class="id" title="tactic">exact</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">k1</span> <a class="idref" href="HoTT.Basics.Datatypes.html#::list_scope:x_'::'_x"><span class="id" title="notation">::</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">k2</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(157, '0_3_23');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(158, '0_3_23');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="m2'" class="idref" href="#m2'"><span class="id" title="definition">m2'</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc2"><span class="id" title="definition">pc2</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(159, '0_3_23');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(160, '0_3_23');
      "><br>
    <span class="id" title="tactic">intros</span> [[[<span class="id" title="var">x</span> <span class="id" title="var">k1</span>] <span class="id" title="var">k2</span>] <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(161, '0_3_23');
      "><br>
    <span class="id" title="tactic">exact</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<span class="id" title="var">k1</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <span class="id" title="var">k2</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(162, '0_3_23');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_23');
      " onmouseover="
      mouseover(163, '0_3_23');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_23"><pre><span></span></pre></div>
<div class="doc" scenenumber="25">
End points of the third path constructor 
</div>
<div scenenumber="27" class="code">
<span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(167, '0_3_27');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="m3" class="idref" href="#m3"><span class="id" title="definition">m3</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc3"><span class="id" title="definition">pc3</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(168, '0_3_27');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(169, '0_3_27');
      "><br>
    <span class="id" title="tactic">intros</span> [[<span class="id" title="var">x</span> <span class="id" title="var">z</span>] <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(170, '0_3_27');
      "><br>
    <span class="id" title="tactic">exact</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.f"><span class="id" title="variable">f</span></a> <span class="id" title="var">z</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(171, '0_3_27');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(172, '0_3_27');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="m3'" class="idref" href="#m3'"><span class="id" title="definition">m3'</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc3"><span class="id" title="definition">pc3</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(173, '0_3_27');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(174, '0_3_27');
      "><br>
    <span class="id" title="tactic">intros</span> [[<span class="id" title="var">x</span> <span class="id" title="var">z</span>] <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(175, '0_3_27');
      "><br>
    <span class="id" title="tactic">exact</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.g"><span class="id" title="variable">g</span></a> <span class="id" title="var">z</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(176, '0_3_27');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_27');
      " onmouseover="
      mouseover(177, '0_3_27');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_27"><pre><span></span></pre></div>
<div class="doc" scenenumber="29">
End points of the fourth path constructor 
</div>
<div scenenumber="31" class="code">
<span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(181, '0_3_31');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="m4" class="idref" href="#m4"><span class="id" title="definition">m4</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc4"><span class="id" title="definition">pc4</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(182, '0_3_31');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(183, '0_3_31');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">x</span> <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(184, '0_3_31');
      "><br>
    <span class="id" title="tactic">exact</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(185, '0_3_31');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(186, '0_3_31');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="m4'" class="idref" href="#m4'"><span class="id" title="definition">m4'</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc4"><span class="id" title="definition">pc4</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(187, '0_3_31');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(188, '0_3_31');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">x</span> <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(189, '0_3_31');
      "><br>
    <span class="id" title="tactic">exact</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(190, '0_3_31');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_31');
      " onmouseover="
      mouseover(191, '0_3_31');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_31"><pre><span></span></pre></div>
<div class="doc" scenenumber="33">
End points of the fifth path constructor 
</div>
<div scenenumber="35" class="code">
<span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(195, '0_3_35');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="m5" class="idref" href="#m5"><span class="id" title="definition">m5</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc5"><span class="id" title="definition">pc5</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(196, '0_3_35');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(197, '0_3_35');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">x</span> <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(198, '0_3_35');
      "><br>
    <span class="id" title="tactic">exact</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(199, '0_3_35');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(200, '0_3_35');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="m5'" class="idref" href="#m5'"><span class="id" title="definition">m5'</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc5"><span class="id" title="definition">pc5</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(201, '0_3_35');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(202, '0_3_35');
      "><br>
    <span class="id" title="tactic">intros</span> [<span class="id" title="var">x</span> <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(203, '0_3_35');
      "><br>
    <span class="id" title="tactic">exact</span> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(204, '0_3_35');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_35');
      " onmouseover="
      mouseover(205, '0_3_35');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_35"><pre><span></span></pre></div>
<div class="doc" scenenumber="37">
We can then define maps going into words consisting of the corresponding endpoints of the path constructors. 
</div>
<div scenenumber="39" class="code">
<span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(209, '0_3_39');
      ">
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="map1" class="idref" href="#map1"><span class="id" title="definition">map1</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc1"><span class="id" title="definition">pc1</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc2"><span class="id" title="definition">pc2</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc3"><span class="id" title="definition">pc3</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc4"><span class="id" title="definition">pc4</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc5"><span class="id" title="definition">pc5</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(210, '0_3_39');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(211, '0_3_39');
      "><br>
    <span class="id" title="tactic">intros</span> [[[[<span class="id" title="var">x</span>|<span class="id" title="var">x</span>]|<span class="id" title="var">x</span>]|<span class="id" title="var">x</span>]|<span class="id" title="var">x</span>].</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(212, '0_3_39');
      "><br>
    + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#m1"><span class="id" title="definition">m1</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(213, '0_3_39');
      "><br>
    + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#m2"><span class="id" title="definition">m2</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(214, '0_3_39');
      "><br>
    + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#m3"><span class="id" title="definition">m3</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(215, '0_3_39');
      "><br>
    + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#m4"><span class="id" title="definition">m4</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(216, '0_3_39');
      "><br>
    + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#m5"><span class="id" title="definition">m5</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(217, '0_3_39');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(218, '0_3_39');
      "><br>
<br>
  <span class="id" title="keyword">Local</span> <span class="id" title="keyword">Definition</span> <a id="map2" class="idref" href="#map2"><span class="id" title="definition">map2</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc1"><span class="id" title="definition">pc1</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc2"><span class="id" title="definition">pc2</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc3"><span class="id" title="definition">pc3</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc4"><span class="id" title="definition">pc4</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#pc5"><span class="id" title="definition">pc5</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(219, '0_3_39');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(220, '0_3_39');
      "><br>
    <span class="id" title="tactic">intros</span> [[[[<span class="id" title="var">x</span>|<span class="id" title="var">x</span>]|<span class="id" title="var">x</span>]|<span class="id" title="var">x</span>]|<span class="id" title="var">x</span>].</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(221, '0_3_39');
      "><br>
    + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#m1'"><span class="id" title="definition">m1'</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(222, '0_3_39');
      "><br>
    + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#m2'"><span class="id" title="definition">m2'</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(223, '0_3_39');
      "><br>
    + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#m3'"><span class="id" title="definition">m3'</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(224, '0_3_39');
      "><br>
    + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#m4'"><span class="id" title="definition">m4'</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(225, '0_3_39');
      "><br>
    + <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#m5'"><span class="id" title="definition">m5'</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(226, '0_3_39');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_39');
      " onmouseover="
      mouseover(227, '0_3_39');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_39"><pre><span></span></pre></div>
<div class="doc" scenenumber="41">
Finally we can define our type as the 0-truncation of the coequalizer of these maps 
</div>
<div scenenumber="43" class="code">
<span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(231, '0_3_43');
      ">
  <span class="id" title="keyword">Definition</span> <a id="amal_type" class="idref" href="#amal_type"><span class="id" title="definition">amal_type</span></a> : <span class="id" title="keyword">Type</span> := <a class="idref" href="HoTT.Truncations.Core.html#Tr"><span class="id" title="definition">Tr</span></a> 0 (<a class="idref" href="HoTT.Colimits.Coeq.html#Coeq"><span class="id" title="definition">Coeq</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#map1"><span class="id" title="definition">map1</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#map2"><span class="id" title="definition">map2</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_43');
      " onmouseover="
      mouseover(232, '0_3_43');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_43"><pre><span></span></pre></div>
<div class="doc" scenenumber="45">
We can define the constructors 
</div>
<div scenenumber="47" class="code">
<span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(236, '0_3_47');
      ">
<br>
  <span class="id" title="keyword">Definition</span> <a id="amal_eta" class="idref" href="#amal_eta"><span class="id" title="definition">amal_eta</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type"><span class="id" title="definition">amal_type</span></a> := <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Colimits.Coeq.html#coeq"><span class="id" title="definition">coeq</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(237, '0_3_47');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="amal_mu_H" class="idref" href="#amal_mu_H"><span class="id" title="definition">amal_mu_H</span></a> (<a id="x:14" class="idref" href="#x:14"><span class="id" title="binder">x</span></a> <a id="y:15" class="idref" href="#y:15"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>) (<a id="h1:16" class="idref" href="#h1:16"><span class="id" title="binder">h1</span></a> <a id="h2:17" class="idref" href="#h2:17"><span class="id" title="binder">h2</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.H"><span class="id" title="variable">H</span></a>)<br>
    : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:14"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h1:16"><span class="id" title="variable">h1</span></a>) <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h2:17"><span class="id" title="variable">h2</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:15"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:14"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h1:16"><span class="id" title="variable">h1</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h2:17"><span class="id" title="variable">h2</span></a>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:15"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(238, '0_3_47');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(239, '0_3_47');
      "><br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(240, '0_3_47');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#path_Tr"><span class="id" title="definition">path_Tr</span></a>, <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(241, '0_3_47');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Coeq.html#cglue"><span class="id" title="definition">cglue</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><span class="id" title="var">h1</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><span class="id" title="var">h2</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>))))).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(242, '0_3_47');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(243, '0_3_47');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="amal_mu_K" class="idref" href="#amal_mu_K"><span class="id" title="definition">amal_mu_K</span></a> (<a id="x:18" class="idref" href="#x:18"><span class="id" title="binder">x</span></a> <a id="y:19" class="idref" href="#y:19"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>) (<a id="k1:20" class="idref" href="#k1:20"><span class="id" title="binder">k1</span></a> <a id="k2:21" class="idref" href="#k2:21"><span class="id" title="binder">k2</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.K"><span class="id" title="variable">K</span></a>)<br>
    : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:18"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k1:20"><span class="id" title="variable">k1</span></a>) <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k2:21"><span class="id" title="variable">k2</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:19"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:18"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k1:20"><span class="id" title="variable">k1</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k2:21"><span class="id" title="variable">k2</span></a>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:19"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(244, '0_3_47');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(245, '0_3_47');
      "><br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(246, '0_3_47');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#path_Tr"><span class="id" title="definition">path_Tr</span></a>, <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(247, '0_3_47');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Coeq.html#cglue"><span class="id" title="definition">cglue</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><span class="id" title="var">k1</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><span class="id" title="var">k2</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>))))).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(248, '0_3_47');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(249, '0_3_47');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="amal_tau" class="idref" href="#amal_tau"><span class="id" title="definition">amal_tau</span></a> (<a id="x:22" class="idref" href="#x:22"><span class="id" title="binder">x</span></a> <a id="y:23" class="idref" href="#y:23"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>) (<a id="z:24" class="idref" href="#z:24"><span class="id" title="binder">z</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.G"><span class="id" title="variable">G</span></a>)<br>
    : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:22"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#z:24"><span class="id" title="variable">z</span></a>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:23"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:22"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#z:24"><span class="id" title="variable">z</span></a>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:23"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(250, '0_3_47');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(251, '0_3_47');
      "><br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(252, '0_3_47');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#path_Tr"><span class="id" title="definition">path_Tr</span></a>, <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(253, '0_3_47');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Coeq.html#cglue"><span class="id" title="definition">cglue</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><span class="id" title="var">z</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)))).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(254, '0_3_47');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(255, '0_3_47');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="amal_omega_H" class="idref" href="#amal_omega_H"><span class="id" title="definition">amal_omega_H</span></a> (<a id="x:25" class="idref" href="#x:25"><span class="id" title="binder">x</span></a> <a id="y:26" class="idref" href="#y:26"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>)<br>
    : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:25"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:26"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:25"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:26"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(256, '0_3_47');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(257, '0_3_47');
      "><br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(258, '0_3_47');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#path_Tr"><span class="id" title="definition">path_Tr</span></a>, <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(259, '0_3_47');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Coeq.html#cglue"><span class="id" title="definition">cglue</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>))).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(260, '0_3_47');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(261, '0_3_47');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="amal_omega_K" class="idref" href="#amal_omega_K"><span class="id" title="definition">amal_omega_K</span></a> (<a id="x:27" class="idref" href="#x:27"><span class="id" title="binder">x</span></a> <a id="y:28" class="idref" href="#y:28"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>)<br>
    : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:27"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:28"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:27"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:28"><span class="id" title="variable">y</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(262, '0_3_47');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(263, '0_3_47');
      "><br>
    <span class="id" title="tactic">unfold</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(264, '0_3_47');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#path_Tr"><span class="id" title="definition">path_Tr</span></a>, <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(265, '0_3_47');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Colimits.Coeq.html#cglue"><span class="id" title="definition">cglue</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(266, '0_3_47');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_47');
      " onmouseover="
      mouseover(267, '0_3_47');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_47"><pre><span></span></pre></div>
<div class="doc" scenenumber="49">
Now we can derive the dependent eliminator 
</div>
<div scenenumber="51" class="code">
<span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(271, '0_3_51');
      ">
<br>
  <span class="id" title="keyword">Definition</span> <a id="amal_type_ind" class="idref" href="#amal_type_ind"><span class="id" title="definition">amal_type_ind</span></a> (<a id="P:29" class="idref" href="#P:29"><span class="id" title="binder">P</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type"><span class="id" title="definition">amal_type</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) `{<a id="H0:31" class="idref" href="#H0:31"><span class="id" title="binder">∀</span></a> <a id="H0:31" class="idref" href="#H0:31"><span class="id" title="binder">x</span></a><a id="H0:31" class="idref" href="#H0:31"><span class="id" title="binder">,</span></a> <a id="H0:31" class="idref" href="#H0:31"><span class="id" title="binder">IsHSet</span></a> <a id="H0:31" class="idref" href="#H0:31"><span class="id" title="binder">(</span></a><a id="H0:31" class="idref" href="#H0:31"><span class="id" title="binder">P</span></a> <a id="H0:31" class="idref" href="#H0:31"><span class="id" title="binder">x</span></a><a id="H0:31" class="idref" href="#H0:31"><span class="id" title="binder">)</span></a>}<br>
    (<a id="e:33" class="idref" href="#e:33"><span class="id" title="binder">e</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="w:32" class="idref" href="#w:32"><span class="id" title="binder">w</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#P:29"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#w:32"><span class="id" title="variable">w</span></a>))<br>
    (<a id="mh:38" class="idref" href="#mh:38"><span class="id" title="binder">mh</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="x:34" class="idref" href="#x:34"><span class="id" title="binder">x</span></a> <a id="y:35" class="idref" href="#y:35"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>) (<a id="h1:36" class="idref" href="#h1:36"><span class="id" title="binder">h1</span></a> <a id="h2:37" class="idref" href="#h2:37"><span class="id" title="binder">h2</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.H"><span class="id" title="variable">H</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
      <a class="idref" href="HoTT.Cubical.DPath.html#DPath"><span class="id" title="definition">DPath</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#P:29"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_mu_H"><span class="id" title="definition">amal_mu_H</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:34"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:35"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h1:36"><span class="id" title="variable">h1</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h2:37"><span class="id" title="variable">h2</span></a>) (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:33"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:34"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h1:36"><span class="id" title="variable">h1</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#::list_scope:x_'::'_x"><span class="id" title="notation">::</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h2:37"><span class="id" title="variable">h2</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:35"><span class="id" title="variable">y</span></a>)) (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:33"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:34"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h1:36"><span class="id" title="variable">h1</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h2:37"><span class="id" title="variable">h2</span></a>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:35"><span class="id" title="variable">y</span></a>)))<br>
    (<a id="mk:43" class="idref" href="#mk:43"><span class="id" title="binder">mk</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="x:39" class="idref" href="#x:39"><span class="id" title="binder">x</span></a> <a id="y:40" class="idref" href="#y:40"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>) (<a id="k1:41" class="idref" href="#k1:41"><span class="id" title="binder">k1</span></a> <a id="k2:42" class="idref" href="#k2:42"><span class="id" title="binder">k2</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.K"><span class="id" title="variable">K</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
      <a class="idref" href="HoTT.Cubical.DPath.html#DPath"><span class="id" title="definition">DPath</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#P:29"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_mu_K"><span class="id" title="definition">amal_mu_K</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:39"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:40"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k1:41"><span class="id" title="variable">k1</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k2:42"><span class="id" title="variable">k2</span></a>) (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:33"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:39"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k1:41"><span class="id" title="variable">k1</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#::list_scope:x_'::'_x"><span class="id" title="notation">::</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k2:42"><span class="id" title="variable">k2</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:40"><span class="id" title="variable">y</span></a>)) (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:33"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:39"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k1:41"><span class="id" title="variable">k1</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k2:42"><span class="id" title="variable">k2</span></a>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:40"><span class="id" title="variable">y</span></a>)))<br>
    (<a id="t:47" class="idref" href="#t:47"><span class="id" title="binder">t</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="x:44" class="idref" href="#x:44"><span class="id" title="binder">x</span></a> <a id="y:45" class="idref" href="#y:45"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>) (<a id="z:46" class="idref" href="#z:46"><span class="id" title="binder">z</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.G"><span class="id" title="variable">G</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
      <a class="idref" href="HoTT.Cubical.DPath.html#DPath"><span class="id" title="definition">DPath</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#P:29"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_tau"><span class="id" title="definition">amal_tau</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:44"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:45"><span class="id" title="variable">y</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#z:46"><span class="id" title="variable">z</span></a>) (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:33"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:44"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#z:46"><span class="id" title="variable">z</span></a>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:45"><span class="id" title="variable">y</span></a>)) (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:33"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:44"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#z:46"><span class="id" title="variable">z</span></a>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:45"><span class="id" title="variable">y</span></a>)))<br>
    (<a id="oh:50" class="idref" href="#oh:50"><span class="id" title="binder">oh</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="x:48" class="idref" href="#x:48"><span class="id" title="binder">x</span></a> <a id="y:49" class="idref" href="#y:49"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
      <a class="idref" href="HoTT.Cubical.DPath.html#DPath"><span class="id" title="definition">DPath</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#P:29"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_omega_H"><span class="id" title="definition">amal_omega_H</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:48"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:49"><span class="id" title="variable">y</span></a>) (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:33"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:48"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:49"><span class="id" title="variable">y</span></a>)) (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:33"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:48"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:49"><span class="id" title="variable">y</span></a>)))<br>
    (<a id="ok:53" class="idref" href="#ok:53"><span class="id" title="binder">ok</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="x:51" class="idref" href="#x:51"><span class="id" title="binder">x</span></a> <a id="y:52" class="idref" href="#y:52"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
      <a class="idref" href="HoTT.Cubical.DPath.html#DPath"><span class="id" title="definition">DPath</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#P:29"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_omega_K"><span class="id" title="definition">amal_omega_K</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:51"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:52"><span class="id" title="variable">y</span></a>) (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:33"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:51"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:52"><span class="id" title="variable">y</span></a>)) (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:33"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:51"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:52"><span class="id" title="variable">y</span></a>)))<br>
    : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:54" class="idref" href="#x:54"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#P:29"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:54"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(272, '0_3_51');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(273, '0_3_51');
      "><br>
    <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.Trunc_ind"><span class="id" title="definition">Trunc_ind</span></a>; [<span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>|].</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(274, '0_3_51');
      "><br>
    <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Colimits.Coeq.html#Coeq_ind"><span class="id" title="definition">Coeq_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(275, '0_3_51');
      "><br>
    1: <span class="id" title="tactic">exact</span> <span class="id" title="var">e</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(276, '0_3_51');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(277, '0_3_51');
      "><br>
    <span class="id" title="var">nrapply</span> <a class="idref" href="HoTT.Cubical.DPath.html#dp_path_transport"><span class="id" title="abbreviation">dp_path_transport</span></a><a class="idref" href="HoTT.Basics.Equivalences.html#76214fa316f18d720833e810bbfd71fb"><span class="id" title="notation">^-1</span></a>%<span class="id" title="var">equiv</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(278, '0_3_51');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span> <span class="id" title="keyword">as</span> [ [ [ [<span class="id" title="var">a</span> | <span class="id" title="var">a</span> ] | <span class="id" title="var">a</span>] | <span class="id" title="var">a</span> ] | <span class="id" title="var">a</span> ].</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(279, '0_3_51');
      "><br>
    + <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span> <span class="id" title="keyword">as</span> [[[<span class="id" title="var">x</span> <span class="id" title="var">h1</span>] <span class="id" title="var">h2</span>] <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(280, '0_3_51');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Cubical.DPath.html#dp_compose"><span class="id" title="abbreviation">dp_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(281, '0_3_51');
      "><br>
      <span class="id" title="tactic">exact</span> (<span class="id" title="var">mh</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(282, '0_3_51');
      "><br>
    + <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span> <span class="id" title="keyword">as</span> [[[<span class="id" title="var">x</span> <span class="id" title="var">k1</span>] <span class="id" title="var">k2</span>] <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(283, '0_3_51');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Cubical.DPath.html#dp_compose"><span class="id" title="abbreviation">dp_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(284, '0_3_51');
      "><br>
      <span class="id" title="tactic">exact</span> (<span class="id" title="var">mk</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">k1</span> <span class="id" title="var">k2</span>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(285, '0_3_51');
      "><br>
    + <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span> <span class="id" title="keyword">as</span> [[<span class="id" title="var">x</span> <span class="id" title="var">z</span>] <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(286, '0_3_51');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Cubical.DPath.html#dp_compose"><span class="id" title="abbreviation">dp_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(287, '0_3_51');
      "><br>
      <span class="id" title="tactic">exact</span> (<span class="id" title="var">t</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(288, '0_3_51');
      "><br>
    + <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">x</span> <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(289, '0_3_51');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Cubical.DPath.html#dp_compose"><span class="id" title="abbreviation">dp_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(290, '0_3_51');
      "><br>
      <span class="id" title="tactic">exact</span> (<span class="id" title="var">oh</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(291, '0_3_51');
      "><br>
    + <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">x</span> <span class="id" title="var">y</span>].</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(292, '0_3_51');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Cubical.DPath.html#dp_compose"><span class="id" title="abbreviation">dp_compose</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(293, '0_3_51');
      "><br>
      <span class="id" title="tactic">exact</span> (<span class="id" title="var">ok</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(294, '0_3_51');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(295, '0_3_51');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="amal_type_ind_hprop" class="idref" href="#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a> (<a id="P:55" class="idref" href="#P:55"><span class="id" title="binder">P</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type"><span class="id" title="definition">amal_type</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) `{<a id="H0:57" class="idref" href="#H0:57"><span class="id" title="binder">∀</span></a> <a id="H0:57" class="idref" href="#H0:57"><span class="id" title="binder">x</span></a><a id="H0:57" class="idref" href="#H0:57"><span class="id" title="binder">,</span></a> <a id="H0:57" class="idref" href="#H0:57"><span class="id" title="binder">IsHProp</span></a> <a id="H0:57" class="idref" href="#H0:57"><span class="id" title="binder">(</span></a><a id="H0:57" class="idref" href="#H0:57"><span class="id" title="binder">P</span></a> <a id="H0:57" class="idref" href="#H0:57"><span class="id" title="binder">x</span></a><a id="H0:57" class="idref" href="#H0:57"><span class="id" title="binder">)</span></a>}<br>
    (<a id="e:59" class="idref" href="#e:59"><span class="id" title="binder">e</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="w:58" class="idref" href="#w:58"><span class="id" title="binder">w</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#P:55"><span class="id" title="variable">P</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#w:58"><span class="id" title="variable">w</span></a>))<br>
    : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a id="x:60" class="idref" href="#x:60"><span class="id" title="binder">x</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">,</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#P:55"><span class="id" title="variable">P</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:60"><span class="id" title="variable">x</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(296, '0_3_51');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(297, '0_3_51');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind"><span class="id" title="definition">amal_type_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(298, '0_3_51');
      "><br>
    1: <span class="id" title="tactic">exact</span> <span class="id" title="var">e</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(299, '0_3_51');
      "><br>
    <span class="id" title="var">all</span>: <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Cubical.DPath.html#dp_path_transport"><span class="id" title="abbreviation">dp_path_transport</span></a>, <a class="idref" href="HoTT.Basics.Trunc.html#path_ishprop"><span class="id" title="lemma">path_ishprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(300, '0_3_51');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_51');
      " onmouseover="
      mouseover(301, '0_3_51');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_51"><pre><span></span></pre></div>
<div class="doc" scenenumber="53">
From which we can derive the non-dependent eliminator / recursion principle 
</div>
<div scenenumber="55" class="code">
<span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(305, '0_3_55');
      ">
  <span class="id" title="keyword">Definition</span> <a id="amal_type_rec" class="idref" href="#amal_type_rec"><span class="id" title="definition">amal_type_rec</span></a> (<a id="P:61" class="idref" href="#P:61"><span class="id" title="binder">P</span></a> : <span class="id" title="keyword">Type</span>) `{<a id="IsHSet0:62" class="idref" href="#IsHSet0:62"><span class="id" title="binder">IsHSet</span></a> <a id="IsHSet0:62" class="idref" href="#IsHSet0:62"><span class="id" title="binder">P</span></a>} (<a id="e:63" class="idref" href="#e:63"><span class="id" title="binder">e</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#P:61"><span class="id" title="variable">P</span></a>)<br>
    (<a id="eh:68" class="idref" href="#eh:68"><span class="id" title="binder">eh</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="x:64" class="idref" href="#x:64"><span class="id" title="binder">x</span></a> <a id="y:65" class="idref" href="#y:65"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>) (<a id="h1:66" class="idref" href="#h1:66"><span class="id" title="binder">h1</span></a> <a id="h2:67" class="idref" href="#h2:67"><span class="id" title="binder">h2</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.H"><span class="id" title="variable">H</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
      <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:63"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:64"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h1:66"><span class="id" title="variable">h1</span></a>) <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h2:67"><span class="id" title="variable">h2</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:65"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:63"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:64"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h1:66"><span class="id" title="variable">h1</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h2:67"><span class="id" title="variable">h2</span></a>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:65"><span class="id" title="variable">y</span></a>))<br>
    (<a id="ek:73" class="idref" href="#ek:73"><span class="id" title="binder">ek</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="x:69" class="idref" href="#x:69"><span class="id" title="binder">x</span></a> <a id="y:70" class="idref" href="#y:70"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>) (<a id="k1:71" class="idref" href="#k1:71"><span class="id" title="binder">k1</span></a> <a id="k2:72" class="idref" href="#k2:72"><span class="id" title="binder">k2</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.K"><span class="id" title="variable">K</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
      <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:63"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:69"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k1:71"><span class="id" title="variable">k1</span></a>) <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k2:72"><span class="id" title="variable">k2</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:70"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:63"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:69"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k1:71"><span class="id" title="variable">k1</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k2:72"><span class="id" title="variable">k2</span></a>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:70"><span class="id" title="variable">y</span></a>))<br>
    (<a id="t:77" class="idref" href="#t:77"><span class="id" title="binder">t</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="x:74" class="idref" href="#x:74"><span class="id" title="binder">x</span></a> <a id="y:75" class="idref" href="#y:75"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>) (<a id="z:76" class="idref" href="#z:76"><span class="id" title="binder">z</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.G"><span class="id" title="variable">G</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a><br>
      <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:63"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:74"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#z:76"><span class="id" title="variable">z</span></a>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:75"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:63"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:74"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#z:76"><span class="id" title="variable">z</span></a>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:75"><span class="id" title="variable">y</span></a>))<br>
    (<a id="oh:80" class="idref" href="#oh:80"><span class="id" title="binder">oh</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="x:78" class="idref" href="#x:78"><span class="id" title="binder">x</span></a> <a id="y:79" class="idref" href="#y:79"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:63"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:78"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:79"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:63"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:78"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:79"><span class="id" title="variable">y</span></a>))<br>
    (<a id="ok:83" class="idref" href="#ok:83"><span class="id" title="binder">ok</span></a> : <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">∀</span></a> <a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">(</span></a><a id="x:81" class="idref" href="#x:81"><span class="id" title="binder">x</span></a> <a id="y:82" class="idref" href="#y:82"><span class="id" title="binder">y</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a><a class="idref" href="HoTT.Basics.Notations.html#adf9957462624adc9c2c94f56add3958"><span class="id" title="notation">),</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:63"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:81"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:82"><span class="id" title="variable">y</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#e:63"><span class="id" title="variable">e</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:81"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#y:82"><span class="id" title="variable">y</span></a>))<br>
    : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type"><span class="id" title="definition">amal_type</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#P:61"><span class="id" title="variable">P</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(306, '0_3_55');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(307, '0_3_55');
      "><br>
    <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind"><span class="id" title="definition">amal_type_ind</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(308, '0_3_55');
      "><br>
    1: <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(309, '0_3_55');
      "><br>
    1: <span class="id" title="tactic">exact</span> <span class="id" title="var">e</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(310, '0_3_55');
      "><br>
    <span class="id" title="var">all</span>: <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Cubical.DPath.html#dp_const"><span class="id" title="abbreviation">dp_const</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(311, '0_3_55');
      "><br>
    1: <span class="id" title="tactic">apply</span> <span class="id" title="var">eh</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(312, '0_3_55');
      "><br>
    1: <span class="id" title="tactic">apply</span> <span class="id" title="var">ek</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(313, '0_3_55');
      "><br>
    1: <span class="id" title="tactic">apply</span> <span class="id" title="var">t</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(314, '0_3_55');
      "><br>
    1: <span class="id" title="tactic">apply</span> <span class="id" title="var">oh</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(315, '0_3_55');
      "><br>
    <span class="id" title="tactic">apply</span> <span class="id" title="var">ok</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(316, '0_3_55');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_55');
      " onmouseover="
      mouseover(317, '0_3_55');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_55"><pre><span></span></pre></div>
<div class="doc" scenenumber="57">
Now for the group structure 
<div class="doc" scenenumber="1"> </div>

 The group operation is concatenation of the underlying list. Most of the work is spent showing that it respects the path constructors. 
</div>
<div scenenumber="59" class="code">
<span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(323, '0_3_59');
      ">
  <span class="id" title="keyword">Global Instance</span> <a id="sgop_amal_type" class="idref" href="#sgop_amal_type"><span class="id" title="instance">sgop_amal_type</span></a> : <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#SgOp"><span class="id" title="class">SgOp</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type"><span class="id" title="definition">amal_type</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(324, '0_3_59');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(325, '0_3_59');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(326, '0_3_59');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_rec"><span class="id" title="definition">amal_type_rec</span></a>; <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>; <span class="id" title="var">revert</span> <span class="id" title="var">y</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(327, '0_3_59');
      "><br>
    { <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_rec"><span class="id" title="definition">amal_type_rec</span></a>; <span class="id" title="tactic">intros</span> <span class="id" title="var">y</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(328, '0_3_59');
      "><br>
      1: <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(329, '0_3_59');
      "><br>
      { <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(330, '0_3_59');
      "><br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(331, '0_3_59');
      "><br>
        1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(332, '0_3_59');
      "><br>
        <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_mu_H"><span class="id" title="definition">amal_mu_H</span></a>. }<br>
      { <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">k1</span> <span class="id" title="var">k2</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(333, '0_3_59');
      "><br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(334, '0_3_59');
      "><br>
        1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(335, '0_3_59');
      "><br>
        <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_mu_K"><span class="id" title="definition">amal_mu_K</span></a>. }<br>
      { <span class="id" title="tactic">intros</span> <span class="id" title="var">w</span> <span class="id" title="var">z</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(336, '0_3_59');
      "><br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(337, '0_3_59');
      "><br>
        1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(338, '0_3_59');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_tau"><span class="id" title="definition">amal_tau</span></a>. }<br>
      { <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(339, '0_3_59');
      "><br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(340, '0_3_59');
      "><br>
        1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(341, '0_3_59');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_omega_H"><span class="id" title="definition">amal_omega_H</span></a>. }<br>
      { <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(342, '0_3_59');
      "><br>
        <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(343, '0_3_59');
      "><br>
        1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(344, '0_3_59');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_omega_K"><span class="id" title="definition">amal_omega_K</span></a>. } }<br>
    { <span class="id" title="tactic">intros</span> <span class="id" title="var">r</span> <span class="id" title="var">y</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span>; <span class="id" title="var">revert</span> <span class="id" title="var">r</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(345, '0_3_59');
      "><br>
      <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(346, '0_3_59');
      "><br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span>;<br>
      <span class="id" title="tactic">change</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">((</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">h1</span> <a class="idref" href="HoTT.Basics.Datatypes.html#::list_scope:x_'::'_x"><span class="id" title="notation">::</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">h2</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">))</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">z</span>)<br>
        <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<span class="id" title="var">h1</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <span class="id" title="var">h2</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">z</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(347, '0_3_59');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(348, '0_3_59');
      "><br>
      1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(349, '0_3_59');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#app"><span class="id" title="definition">app</span></a> <span class="id" title="var">x</span>) <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#app"><span class="id" title="definition">app</span></a> <span class="id" title="var">x</span>) <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(350, '0_3_59');
      "><br>
      1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(351, '0_3_59');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_mu_H"><span class="id" title="definition">amal_mu_H</span></a>. }<br>
    { <span class="id" title="tactic">intros</span> <span class="id" title="var">r</span> <span class="id" title="var">y</span> <span class="id" title="var">k1</span> <span class="id" title="var">k2</span>; <span class="id" title="var">revert</span> <span class="id" title="var">r</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(352, '0_3_59');
      "><br>
      <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(353, '0_3_59');
      "><br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span>;<br>
      <span class="id" title="tactic">change</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">((</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">k1</span> <a class="idref" href="HoTT.Basics.Datatypes.html#::list_scope:x_'::'_x"><span class="id" title="notation">::</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">k2</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">))</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">z</span>)<br>
        <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<span class="id" title="var">k1</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <span class="id" title="var">k2</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">z</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(354, '0_3_59');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(355, '0_3_59');
      "><br>
      1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(356, '0_3_59');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#app"><span class="id" title="definition">app</span></a> <span class="id" title="var">x</span>) <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#app"><span class="id" title="definition">app</span></a> <span class="id" title="var">x</span>) <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(357, '0_3_59');
      "><br>
      1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(358, '0_3_59');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_mu_K"><span class="id" title="definition">amal_mu_K</span></a>. }<br>
    { <span class="id" title="tactic">intros</span> <span class="id" title="var">r</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>; <span class="id" title="var">revert</span> <span class="id" title="var">r</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(359, '0_3_59');
      "><br>
      <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(360, '0_3_59');
      "><br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">w</span>;<br>
      <span class="id" title="tactic">change</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.f"><span class="id" title="variable">f</span></a> <span class="id" title="var">z</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">w</span>)<br>
        <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.g"><span class="id" title="variable">g</span></a> <span class="id" title="var">z</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">y</span><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">w</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(361, '0_3_59');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(362, '0_3_59');
      "><br>
      1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(363, '0_3_59');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#app"><span class="id" title="definition">app</span></a> <span class="id" title="var">x</span>) <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#app"><span class="id" title="definition">app</span></a> <span class="id" title="var">x</span>) <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(364, '0_3_59');
      "><br>
      1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(365, '0_3_59');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_tau"><span class="id" title="definition">amal_tau</span></a>. }<br>
    { <span class="id" title="tactic">intros</span> <span class="id" title="var">r</span> <span class="id" title="var">z</span>; <span class="id" title="var">revert</span> <span class="id" title="var">r</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(366, '0_3_59');
      "><br>
      <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(367, '0_3_59');
      "><br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">w</span>;<br>
      <span class="id" title="tactic">change</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">z</span><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">w</span>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">z</span><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">w</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(368, '0_3_59');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(369, '0_3_59');
      "><br>
      1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(370, '0_3_59');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#app"><span class="id" title="definition">app</span></a> <span class="id" title="var">x</span>) <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(371, '0_3_59');
      "><br>
      1: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(372, '0_3_59');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_omega_H"><span class="id" title="definition">amal_omega_H</span></a>. }<br>
    { <span class="id" title="tactic">intros</span> <span class="id" title="var">r</span> <span class="id" title="var">z</span>; <span class="id" title="var">revert</span> <span class="id" title="var">r</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(373, '0_3_59');
      "><br>
      <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a>; <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(374, '0_3_59');
      "><br>
      <span class="id" title="tactic">intros</span> <span class="id" title="var">w</span>;<br>
      <span class="id" title="tactic">change</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">z</span><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">w</span>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">z</span><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">w</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(375, '0_3_59');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(376, '0_3_59');
      "><br>
      1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(377, '0_3_59');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#app"><span class="id" title="definition">app</span></a> <span class="id" title="var">x</span>) <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(378, '0_3_59');
      "><br>
      1: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(379, '0_3_59');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_omega_K"><span class="id" title="definition">amal_omega_K</span></a>. }<br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_59');
      " onmouseover="
      mouseover(380, '0_3_59');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_59"><pre><span></span></pre></div>
<div class="doc" scenenumber="61">
The identity element is the empty list 
</div>
<div scenenumber="63" class="code">
<span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(384, '0_3_63');
      ">
  <span class="id" title="keyword">Global Instance</span> <a id="monunit_amal_type" class="idref" href="#monunit_amal_type"><span class="id" title="instance">monunit_amal_type</span></a> : <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#MonUnit"><span class="id" title="class">MonUnit</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type"><span class="id" title="definition">amal_type</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(385, '0_3_63');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(386, '0_3_63');
      "><br>
    <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(387, '0_3_63');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(388, '0_3_63');
      "><br>
<br>
  <span class="id" title="keyword">Global Instance</span> <a id="negate_amal_type" class="idref" href="#negate_amal_type"><span class="id" title="instance">negate_amal_type</span></a> : <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#Negate"><span class="id" title="class">Negate</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type"><span class="id" title="definition">amal_type</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(389, '0_3_63');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(390, '0_3_63');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_rec"><span class="id" title="definition">amal_type_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(391, '0_3_63');
      "><br>
    { <span class="id" title="tactic">intros</span> <span class="id" title="var">w</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(392, '0_3_63');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse"><span class="id" title="definition">word_inverse</span></a> <span class="id" title="var">w</span>)). }</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(393, '0_3_63');
      "><br>
    { <span class="id" title="tactic">hnf</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(394, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(395, '0_3_63');
      "><br>
      1,3: <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse_ww"><span class="id" title="definition">word_inverse_ww</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="s:86" class="idref" href="#s:86"><span class="id" title="binder">s</span></a> ⇒ <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#s:84"><span class="id" title="variable">s</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">_</span>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(396, '0_3_63');
      "><br>
      1: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse_ww"><span class="id" title="definition">word_inverse_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(397, '0_3_63');
      "><br>
      { <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse_ww"><span class="id" title="definition">word_inverse_ww</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(398, '0_3_63');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(399, '0_3_63');
      "><br>
        <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="s:88" class="idref" href="#s:88"><span class="id" title="binder">s</span></a> ⇒ <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#s:87"><span class="id" title="variable">s</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(400, '0_3_63');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(401, '0_3_63');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Classes.theory.groups.html#negate_sg_op"><span class="id" title="lemma">negate_sg_op</span></a>. }<br>
      <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(402, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(403, '0_3_63');
      "><br>
      1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(404, '0_3_63');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_mu_H"><span class="id" title="definition">amal_mu_H</span></a>. }<br>
    { <span class="id" title="tactic">hnf</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">k1</span> <span class="id" title="var">k2</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(405, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(406, '0_3_63');
      "><br>
      1,3: <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse_ww"><span class="id" title="definition">word_inverse_ww</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="s:91" class="idref" href="#s:91"><span class="id" title="binder">s</span></a> ⇒ <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#s:89"><span class="id" title="variable">s</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">_</span>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(407, '0_3_63');
      "><br>
      1: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse_ww"><span class="id" title="definition">word_inverse_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(408, '0_3_63');
      "><br>
      { <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse_ww"><span class="id" title="definition">word_inverse_ww</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(409, '0_3_63');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(410, '0_3_63');
      "><br>
        <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="s:93" class="idref" href="#s:93"><span class="id" title="binder">s</span></a> ⇒ <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#s:92"><span class="id" title="variable">s</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(411, '0_3_63');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(412, '0_3_63');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Classes.theory.groups.html#negate_sg_op"><span class="id" title="lemma">negate_sg_op</span></a>. }<br>
      <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(413, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(414, '0_3_63');
      "><br>
      1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(415, '0_3_63');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_mu_K"><span class="id" title="definition">amal_mu_K</span></a>. }<br>
    { <span class="id" title="tactic">hnf</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(416, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(417, '0_3_63');
      "><br>
      1,3: <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse_ww"><span class="id" title="definition">word_inverse_ww</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="s:96" class="idref" href="#s:96"><span class="id" title="binder">s</span></a> ⇒ <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#s:94"><span class="id" title="variable">s</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">_</span>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(418, '0_3_63');
      "><br>
      1,2: <span class="id" title="var">cbn</span>; <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(419, '0_3_63');
      "><br>
      1,2: <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="s:99" class="idref" href="#s:99"><span class="id" title="binder">s</span></a> ⇒ <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#s:97"><span class="id" title="variable">s</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(420, '0_3_63');
      "><br>
      1,2: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(421, '0_3_63');
      "><br>
      1,2: <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_inv"><span class="id" title="definition">grp_homo_inv</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(422, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(423, '0_3_63');
      "><br>
      1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(424, '0_3_63');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_tau"><span class="id" title="definition">amal_tau</span></a>. }<br>
    { <span class="id" title="tactic">hnf</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">z</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(425, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(426, '0_3_63');
      "><br>
      1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse_ww"><span class="id" title="definition">word_inverse_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(427, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(428, '0_3_63');
      "><br>
      { <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="s:101" class="idref" href="#s:101"><span class="id" title="binder">s</span></a> ⇒ <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#s:100"><span class="id" title="variable">s</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">_</span>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(429, '0_3_63');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse_ww"><span class="id" title="definition">word_inverse_ww</span></a>. }<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(430, '0_3_63');
      "><br>
      1: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(431, '0_3_63');
      "><br>
      <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(432, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Classes.theory.groups.html#negate_mon_unit"><span class="id" title="lemma">negate_mon_unit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(433, '0_3_63');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_omega_H"><span class="id" title="definition">amal_omega_H</span></a>. }<br>
    { <span class="id" title="tactic">hnf</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">z</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(434, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(435, '0_3_63');
      "><br>
      1,3: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse_ww"><span class="id" title="definition">word_inverse_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(436, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(437, '0_3_63');
      "><br>
      { <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="s:103" class="idref" href="#s:103"><span class="id" title="binder">s</span></a> ⇒ <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#s:102"><span class="id" title="variable">s</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">_</span>) <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(438, '0_3_63');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse_ww"><span class="id" title="definition">word_inverse_ww</span></a>. }<br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">^</span></a> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(439, '0_3_63');
      "><br>
      1: <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(440, '0_3_63');
      "><br>
      <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(441, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Classes.theory.groups.html#negate_mon_unit"><span class="id" title="lemma">negate_mon_unit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(442, '0_3_63');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_omega_K"><span class="id" title="definition">amal_omega_K</span></a>. }<br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(443, '0_3_63');
      "><br>
<br>
  <span class="id" title="keyword">Global Instance</span> <a id="associative_sgop_m" class="idref" href="#associative_sgop_m"><span class="id" title="instance">associative_sgop_m</span></a> : <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#Associative"><span class="id" title="class">Associative</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#sg_op"><span class="id" title="definition">sg_op</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(444, '0_3_63');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(445, '0_3_63');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(446, '0_3_63');
      "><br>
    <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">z</span>; <span class="id" title="var">revert</span> <span class="id" title="var">y</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(447, '0_3_63');
      "><br>
    <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">y</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(448, '0_3_63');
      "><br>
    <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(449, '0_3_63');
      "><br>
    <span class="id" title="var">nrapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(450, '0_3_63');
      "><br>
    <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(451, '0_3_63');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(452, '0_3_63');
      "><br>
<br>
  <span class="id" title="keyword">Global Instance</span> <a id="leftidentity_sgop_amal_type" class="idref" href="#leftidentity_sgop_amal_type"><span class="id" title="instance">leftidentity_sgop_amal_type</span></a> : <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#LeftIdentity"><span class="id" title="class">LeftIdentity</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#sg_op"><span class="id" title="definition">sg_op</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(453, '0_3_63');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(454, '0_3_63');
      "><br>
    <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(455, '0_3_63');
      "><br>
    <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(456, '0_3_63');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(457, '0_3_63');
      "><br>
<br>
  <span class="id" title="keyword">Global Instance</span> <a id="rightidentity_sgop_amal_type" class="idref" href="#rightidentity_sgop_amal_type"><span class="id" title="instance">rightidentity_sgop_amal_type</span></a> : <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#RightIdentity"><span class="id" title="class">RightIdentity</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#sg_op"><span class="id" title="definition">sg_op</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(458, '0_3_63');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(459, '0_3_63');
      "><br>
    <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(460, '0_3_63');
      "><br>
    <span class="id" title="var">nrapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(461, '0_3_63');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_nil"><span class="id" title="definition">word_concat_w_nil</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(462, '0_3_63');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(463, '0_3_63');
      "><br>
<br>
  <span class="id" title="keyword">Lemma</span> <a id="amal_eta_word_concat_Vw" class="idref" href="#amal_eta_word_concat_Vw"><span class="id" title="lemma">amal_eta_word_concat_Vw</span></a> (<a id="x:104" class="idref" href="#x:104"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>) : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse"><span class="id" title="definition">word_inverse</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:104"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:104"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(464, '0_3_63');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(465, '0_3_63');
      "><br>
    <span class="id" title="tactic">induction</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">x</span> <span class="id" title="var">xs</span>].</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(466, '0_3_63');
      "><br>
    1: <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(467, '0_3_63');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">h</span>|<span class="id" title="var">k</span>].</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(468, '0_3_63');
      "><br>
    + <span class="id" title="tactic">change</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse"><span class="id" title="definition">word_inverse</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">h</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">xs</span>) <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">h</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">xs</span>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(469, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse_ww"><span class="id" title="definition">word_inverse_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(470, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(471, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_mu_H"><span class="id" title="definition">amal_mu_H</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(472, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#left_inverse"><span class="id" title="definition">left_inverse</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(473, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_omega_H"><span class="id" title="definition">amal_omega_H</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(474, '0_3_63');
      "><br>
      <span class="id" title="tactic">apply</span> <span class="id" title="var">IHxs</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(475, '0_3_63');
      "><br>
    + <span class="id" title="tactic">change</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse"><span class="id" title="definition">word_inverse</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">k</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">xs</span>) <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">k</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">xs</span>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(476, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse_ww"><span class="id" title="definition">word_inverse_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(477, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(478, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_mu_K"><span class="id" title="definition">amal_mu_K</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(479, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#left_inverse"><span class="id" title="definition">left_inverse</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(480, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_omega_K"><span class="id" title="definition">amal_omega_K</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(481, '0_3_63');
      "><br>
      <span class="id" title="tactic">apply</span> <span class="id" title="var">IHxs</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(482, '0_3_63');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(483, '0_3_63');
      "><br>
<br>
  <span class="id" title="keyword">Lemma</span> <a id="amal_eta_word_concat_wV" class="idref" href="#amal_eta_word_concat_wV"><span class="id" title="lemma">amal_eta_word_concat_wV</span></a> (<a id="x:105" class="idref" href="#x:105"><span class="id" title="binder">x</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#Words"><span class="id" title="definition">Words</span></a>) : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:105"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse"><span class="id" title="definition">word_inverse</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:105"><span class="id" title="variable">x</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(484, '0_3_63');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(485, '0_3_63');
      "><br>
    <span class="id" title="tactic">induction</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">x</span> <span class="id" title="var">xs</span>].</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(486, '0_3_63');
      "><br>
    1: <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(487, '0_3_63');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">h</span>|<span class="id" title="var">k</span>].</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(488, '0_3_63');
      "><br>
    + <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(489, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(490, '0_3_63');
      "><br>
      <span class="id" title="tactic">change</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">h</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>) <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> ((<span class="id" title="var">xs</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse"><span class="id" title="definition">word_inverse</span></a> <span class="id" title="var">xs</span>)) <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#::mc_scope:'-'_x"><span class="id" title="notation">-</span></a> <span class="id" title="var">h</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(491, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHxs</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(492, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#rightidentity_sgop_amal_type"><span class="id" title="instance">rightidentity_sgop_amal_type</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(493, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_nil"><span class="id" title="definition">word_concat_w_nil</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(494, '0_3_63');
      "><br>
      <span class="id" title="tactic">change</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">h</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#::mc_scope:'-'_x"><span class="id" title="notation">-</span></a> <span class="id" title="var">h</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(495, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(496, '0_3_63');
      "><br>
      <span class="id" title="tactic">change</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">h</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#::mc_scope:'-'_x"><span class="id" title="notation">-</span></a> <span class="id" title="var">h</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(497, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_mu_H"><span class="id" title="definition">amal_mu_H</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(498, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(499, '0_3_63');
      "><br>
      { <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>, <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(500, '0_3_63');
      "><br>
        <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="x:107" class="idref" href="#x:107"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:106"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(501, '0_3_63');
      "><br>
        <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="x:109" class="idref" href="#x:109"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:108"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(502, '0_3_63');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(503, '0_3_63');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#right_inverse"><span class="id" title="definition">right_inverse</span></a>. }<br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_omega_H"><span class="id" title="definition">amal_omega_H</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(504, '0_3_63');
      "><br>
    +  <span class="id" title="var">cbn</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(505, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(506, '0_3_63');
      "><br>
      <span class="id" title="tactic">change</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">k</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>) <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> ((<span class="id" title="var">xs</span> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_inverse"><span class="id" title="definition">word_inverse</span></a> <span class="id" title="var">xs</span>)) <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#::mc_scope:'-'_x"><span class="id" title="notation">-</span></a><span class="id" title="var">k</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(507, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHxs</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(508, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#rightidentity_sgop_amal_type"><span class="id" title="instance">rightidentity_sgop_amal_type</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(509, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_nil"><span class="id" title="definition">word_concat_w_nil</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(510, '0_3_63');
      "><br>
      <span class="id" title="tactic">change</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">k</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#::mc_scope:'-'_x"><span class="id" title="notation">-</span></a> <span class="id" title="var">k</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(511, '0_3_63');
      "><br>
      <span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_ww"><span class="id" title="definition">word_concat_w_ww</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(512, '0_3_63');
      "><br>
      <span class="id" title="tactic">change</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> (<a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">k</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#::mc_scope:'-'_x"><span class="id" title="notation">-</span></a> <span class="id" title="var">k</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>) <a class="idref" href="HoTT.Basics.Overture.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(513, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_mu_K"><span class="id" title="definition">amal_mu_K</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(514, '0_3_63');
      "><br>
      <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(515, '0_3_63');
      "><br>
      { <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>, <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(516, '0_3_63');
      "><br>
        <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="x:111" class="idref" href="#x:111"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:110"><span class="id" title="variable">x</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(517, '0_3_63');
      "><br>
        <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> (<span class="id" title="keyword">fun</span> <a id="x:113" class="idref" href="#x:113"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x:112"><span class="id" title="variable">x</span></a><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>)).</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(518, '0_3_63');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(519, '0_3_63');
      "><br>
        <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#right_inverse"><span class="id" title="definition">right_inverse</span></a>. }<br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_omega_K"><span class="id" title="definition">amal_omega_K</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(520, '0_3_63');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(521, '0_3_63');
      "><br>
<br>
  <span class="id" title="keyword">Global Instance</span> <a id="leftinverse_sgop_amal_type" class="idref" href="#leftinverse_sgop_amal_type"><span class="id" title="instance">leftinverse_sgop_amal_type</span></a> : <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#LeftInverse"><span class="id" title="class">LeftInverse</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#sg_op"><span class="id" title="definition">sg_op</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#negate"><span class="id" title="definition">negate</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(522, '0_3_63');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(523, '0_3_63');
      "><br>
    <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(524, '0_3_63');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta_word_concat_Vw"><span class="id" title="lemma">amal_eta_word_concat_Vw</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(525, '0_3_63');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(526, '0_3_63');
      "><br>
<br>
  <span class="id" title="keyword">Global Instance</span> <a id="rightinverse_sgop_amal_type" class="idref" href="#rightinverse_sgop_amal_type"><span class="id" title="instance">rightinverse_sgop_amal_type</span></a> : <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#RightInverse"><span class="id" title="class">RightInverse</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#sg_op"><span class="id" title="definition">sg_op</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#negate"><span class="id" title="definition">negate</span></a> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(527, '0_3_63');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(528, '0_3_63');
      "><br>
    <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(529, '0_3_63');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta_word_concat_wV"><span class="id" title="lemma">amal_eta_word_concat_wV</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(530, '0_3_63');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(531, '0_3_63');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="AmalgamatedFreeProduct" class="idref" href="#AmalgamatedFreeProduct"><span class="id" title="definition">AmalgamatedFreeProduct</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#Group"><span class="id" title="record">Group</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(532, '0_3_63');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(533, '0_3_63');
      "><br>
    <span class="id" title="var">snrapply</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#Build_Group"><span class="id" title="constructor">Build_Group</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type"><span class="id" title="definition">amal_type</span></a>); <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">split</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(534, '0_3_63');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_63');
      " onmouseover="
      mouseover(535, '0_3_63');
      "><br>
<br>
</span>
</div>
<div class="goal" id="goal0_3_63"><pre><span></span></pre></div>
<div class="doc" scenenumber="65">
Using foldr. It's important that we use foldr as foldl is near impossible to reason about. 
</div>
<div scenenumber="67" class="code">
<span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(539, '0_3_67');
      ">
  <span class="id" title="keyword">Definition</span> <a id="AmalgamatedFreeProduct_rec'" class="idref" href="#AmalgamatedFreeProduct_rec'"><span class="id" title="definition">AmalgamatedFreeProduct_rec'</span></a> (<a id="X:114" class="idref" href="#X:114"><span class="id" title="binder">X</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#Group"><span class="id" title="record">Group</span></a>)<br>
    (<a id="h:115" class="idref" href="#h:115"><span class="id" title="binder">h</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.H"><span class="id" title="variable">H</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#X:114"><span class="id" title="variable">X</span></a>) (<a id="k:116" class="idref" href="#k:116"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.K"><span class="id" title="variable">K</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#X:114"><span class="id" title="variable">X</span></a>)<br>
    (<a id="p:117" class="idref" href="#p:117"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h:115"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k:116"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.g"><span class="id" title="variable">g</span></a>)<br>
    : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#AmalgamatedFreeProduct"><span class="id" title="definition">AmalgamatedFreeProduct</span></a> <a class="idref" href="HoTT.Basics.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#X:114"><span class="id" title="variable">X</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(540, '0_3_67');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(541, '0_3_67');
      "><br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_rec"><span class="id" title="definition">amal_type_rec</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(542, '0_3_67');
      "><br>
    { <span class="id" title="tactic">intro</span> <span class="id" title="var">w</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(543, '0_3_67');
      "><br>
      <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Spaces.List.html#fold_right"><span class="id" title="definition">fold_right</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">w</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(544, '0_3_67');
      "><br>
      { <span class="id" title="tactic">intros</span> [<span class="id" title="var">l</span>|<span class="id" title="var">r</span>] <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(545, '0_3_67');
      "><br>
        + <span class="id" title="tactic">exact</span> (<span class="id" title="var">h</span> <span class="id" title="var">l</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <span class="id" title="var">x</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(546, '0_3_67');
      "><br>
        + <span class="id" title="tactic">exact</span> (<span class="id" title="var">k</span> <span class="id" title="var">r</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <span class="id" title="var">x</span>). }</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(547, '0_3_67');
      "><br>
      <span class="id" title="tactic">exact</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a>. }<br>
    { <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span>; <span class="id" title="tactic">hnf</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(548, '0_3_67');
      "><br>
      <span class="id" title="tactic">rewrite</span> ?<a class="idref" href="HoTT.Spaces.List.html#fold_right_app"><span class="id" title="lemma">fold_right_app</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(549, '0_3_67');
      "><br>
      <span class="id" title="var">f_ap</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(550, '0_3_67');
      "><br>
      <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(551, '0_3_67');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#simple_associativity"><span class="id" title="definition">simple_associativity</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(552, '0_3_67');
      "><br>
      <span class="id" title="var">f_ap</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(553, '0_3_67');
      "><br>
      <span class="id" title="tactic">symmetry</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(554, '0_3_67');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_op"><span class="id" title="definition">grp_homo_op</span></a> <span class="id" title="var">h</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span>). }</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(555, '0_3_67');
      "><br>
    { <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">k1</span> <span class="id" title="var">k2</span>; <span class="id" title="tactic">hnf</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(556, '0_3_67');
      "><br>
      <span class="id" title="tactic">rewrite</span> ?<a class="idref" href="HoTT.Spaces.List.html#fold_right_app"><span class="id" title="lemma">fold_right_app</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(557, '0_3_67');
      "><br>
      <span class="id" title="var">f_ap</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(558, '0_3_67');
      "><br>
      <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(559, '0_3_67');
      "><br>
      <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#simple_associativity"><span class="id" title="definition">simple_associativity</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(560, '0_3_67');
      "><br>
      <span class="id" title="var">f_ap</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(561, '0_3_67');
      "><br>
      <span class="id" title="tactic">symmetry</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(562, '0_3_67');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_op"><span class="id" title="definition">grp_homo_op</span></a> <span class="id" title="var">k</span> <span class="id" title="var">k1</span> <span class="id" title="var">k2</span>). }</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(563, '0_3_67');
      "><br>
    { <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>; <span class="id" title="tactic">hnf</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(564, '0_3_67');
      "><br>
      <span class="id" title="tactic">rewrite</span> ?<a class="idref" href="HoTT.Spaces.List.html#fold_right_app"><span class="id" title="lemma">fold_right_app</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(565, '0_3_67');
      "><br>
      <span class="id" title="var">f_ap</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="var">f_ap</span>. }<br>
    { <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>; <span class="id" title="tactic">hnf</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(566, '0_3_67');
      "><br>
      <span class="id" title="tactic">rewrite</span> ?<a class="idref" href="HoTT.Spaces.List.html#fold_right_app"><span class="id" title="lemma">fold_right_app</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(567, '0_3_67');
      "><br>
      <span class="id" title="var">f_ap</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(568, '0_3_67');
      "><span class="id" title="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(569, '0_3_67');
      "><span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_unit"><span class="id" title="definition">grp_homo_unit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(570, '0_3_67');
      "><br>
      <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#left_identity"><span class="id" title="definition">left_identity</span></a>. }<br>
    { <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>; <span class="id" title="tactic">hnf</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(571, '0_3_67');
      "><br>
      <span class="id" title="tactic">rewrite</span> ?<a class="idref" href="HoTT.Spaces.List.html#fold_right_app"><span class="id" title="lemma">fold_right_app</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(572, '0_3_67');
      "><br>
      <span class="id" title="var">f_ap</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(573, '0_3_67');
      "><span class="id" title="tactic">simpl</span>. </span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(574, '0_3_67');
      "><span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_unit"><span class="id" title="definition">grp_homo_unit</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(575, '0_3_67');
      "><br>
      <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#left_identity"><span class="id" title="definition">left_identity</span></a>. }<br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(576, '0_3_67');
      "><br>
<br>
  <span class="id" title="keyword">Global Instance</span> <a id="issemigrouppreserving_AmalgamatedFreeProduct_rec'" class="idref" href="#issemigrouppreserving_AmalgamatedFreeProduct_rec'"><span class="id" title="instance">issemigrouppreserving_AmalgamatedFreeProduct_rec'</span></a><br>
    (<a id="X:118" class="idref" href="#X:118"><span class="id" title="binder">X</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#Group"><span class="id" title="record">Group</span></a>) (<a id="h:119" class="idref" href="#h:119"><span class="id" title="binder">h</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.H"><span class="id" title="variable">H</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#X:118"><span class="id" title="variable">X</span></a>) (<a id="k:120" class="idref" href="#k:120"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.K"><span class="id" title="variable">K</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#X:118"><span class="id" title="variable">X</span></a>)<br>
    (<a id="p:121" class="idref" href="#p:121"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h:119"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k:120"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.g"><span class="id" title="variable">g</span></a>)<br>
    : <a class="idref" href="HoTT.Classes.interfaces.abstract_algebra.html#IsSemiGroupPreserving"><span class="id" title="class">IsSemiGroupPreserving</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#AmalgamatedFreeProduct_rec'"><span class="id" title="definition">AmalgamatedFreeProduct_rec'</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#X:118"><span class="id" title="variable">X</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h:119"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k:120"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#p:121"><span class="id" title="variable">p</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(577, '0_3_67');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(578, '0_3_67');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>; <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">y</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>;<br>
    <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a>; <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(579, '0_3_67');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Spaces.List.html#fold_right_app"><span class="id" title="lemma">fold_right_app</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(580, '0_3_67');
      "><br>
    <span class="id" title="tactic">set</span> (<span class="id" title="var">s</span> := (<a class="idref" href="HoTT.Spaces.List.html#fold_right"><span class="id" title="definition">fold_right</span></a> <span class="id" title="var">X</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.H"><span class="id" title="variable">H</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.K"><span class="id" title="variable">K</span></a>)<br>
     (<span class="id" title="keyword">fun</span> <a id="X0:126" class="idref" href="#X0:126"><span class="id" title="binder">X0</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.H"><span class="id" title="variable">H</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#e03f39daf98516fa530d3f6f5a1b4d92"><span class="id" title="notation">+</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.K"><span class="id" title="variable">K</span></a> ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#X0:122"><span class="id" title="variable">X0</span></a> <span class="id" title="keyword">with</span><br>
                        | <a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">l</span> ⇒ <span class="id" title="keyword">fun</span> <a id="x0:128" class="idref" href="#x0:128"><span class="id" title="binder">x0</span></a> : <span class="id" title="var">X</span> ⇒ <span class="id" title="var">h</span> <span class="id" title="var">l</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x0:124"><span class="id" title="variable">x0</span></a><br>
                        | <a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">r</span> ⇒ <span class="id" title="keyword">fun</span> <a id="x0:129" class="idref" href="#x0:129"><span class="id" title="binder">x0</span></a> : <span class="id" title="var">X</span> ⇒ <span class="id" title="var">k</span> <span class="id" title="var">r</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#x0:125"><span class="id" title="variable">x0</span></a><br>
                        <span class="id" title="keyword">end</span>) <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#mon_unit"><span class="id" title="definition">mon_unit</span></a> <span class="id" title="var">y</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(581, '0_3_67');
      "><br>
    <span class="id" title="tactic">induction</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">a</span> <span class="id" title="var">x</span>].</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(582, '0_3_67');
      "><br>
    1: <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#left_identity"><span class="id" title="definition">left_identity</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(583, '0_3_67');
      "><br>
    <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(584, '0_3_67');
      "><br>
    <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHx</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(585, '0_3_67');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#simple_associativity"><span class="id" title="definition">simple_associativity</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(586, '0_3_67');
      "><br>
  <span class="id" title="keyword">Qed</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(587, '0_3_67');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="AmalgamatedFreeProduct_rec" class="idref" href="#AmalgamatedFreeProduct_rec"><span class="id" title="definition">AmalgamatedFreeProduct_rec</span></a> (<a id="X:130" class="idref" href="#X:130"><span class="id" title="binder">X</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#Group"><span class="id" title="record">Group</span></a>)<br>
    (<a id="h:131" class="idref" href="#h:131"><span class="id" title="binder">h</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.H"><span class="id" title="variable">H</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#X:130"><span class="id" title="variable">X</span></a>) (<a id="k:132" class="idref" href="#k:132"><span class="id" title="binder">k</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.K"><span class="id" title="variable">K</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#X:130"><span class="id" title="variable">X</span></a>)<br>
    (<a id="p:133" class="idref" href="#p:133"><span class="id" title="binder">p</span></a> : <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h:131"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k:132"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.g"><span class="id" title="variable">g</span></a>)<br>
    : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#AmalgamatedFreeProduct"><span class="id" title="definition">AmalgamatedFreeProduct</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#X:130"><span class="id" title="variable">X</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(588, '0_3_67');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(589, '0_3_67');
      "><br>
    <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#Build_GroupHomomorphism"><span class="id" title="definition">Build_GroupHomomorphism</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(590, '0_3_67');
      "><br>
    1: <span class="id" title="var">srapply</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#AmalgamatedFreeProduct_rec'"><span class="id" title="definition">AmalgamatedFreeProduct_rec'</span></a> <span class="id" title="var">X</span> <span class="id" title="var">h</span> <span class="id" title="var">k</span> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(591, '0_3_67');
      "><br>
    <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(592, '0_3_67');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(593, '0_3_67');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="amal_inl" class="idref" href="#amal_inl"><span class="id" title="definition">amal_inl</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.H"><span class="id" title="variable">H</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#AmalgamatedFreeProduct"><span class="id" title="definition">AmalgamatedFreeProduct</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(594, '0_3_67');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(595, '0_3_67');
      "><br>
    <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#Build_GroupHomomorphism"><span class="id" title="definition">Build_GroupHomomorphism</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(596, '0_3_67');
      "><br>
    { <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(597, '0_3_67');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>). }</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(598, '0_3_67');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(599, '0_3_67');
      "><br>
    <span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_nil"><span class="id" title="definition">word_concat_w_nil</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <span class="id" title="var">y</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(600, '0_3_67');
      "><br>
    <span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_mu_H"><span class="id" title="definition">amal_mu_H</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(601, '0_3_67');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_nil"><span class="id" title="definition">word_concat_w_nil</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(602, '0_3_67');
      "><br>
    <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(603, '0_3_67');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(604, '0_3_67');
      "><br>
<br>
  <span class="id" title="keyword">Definition</span> <a id="amal_inr" class="idref" href="#amal_inr"><span class="id" title="definition">amal_inr</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.K"><span class="id" title="variable">K</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#AmalgamatedFreeProduct"><span class="id" title="definition">AmalgamatedFreeProduct</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(605, '0_3_67');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(606, '0_3_67');
      "><br>
    <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#Build_GroupHomomorphism"><span class="id" title="definition">Build_GroupHomomorphism</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(607, '0_3_67');
      "><br>
    { <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(608, '0_3_67');
      "><br>
      <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> <span class="id" title="var">x</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>). }</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(609, '0_3_67');
      "><br>
    <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(610, '0_3_67');
      "><br>
    <span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_nil"><span class="id" title="definition">word_concat_w_nil</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<span class="id" title="var">x</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#601809684726b80a51fcd53b156c93ba"><span class="id" title="notation">×</span></a> <span class="id" title="var">y</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(611, '0_3_67');
      "><br>
    <span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_mu_K"><span class="id" title="definition">amal_mu_K</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(612, '0_3_67');
      "><br>
    <span class="id" title="tactic">rewrite</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_nil"><span class="id" title="definition">word_concat_w_nil</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(613, '0_3_67');
      "><br>
    <span class="id" title="tactic">reflexivity</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(614, '0_3_67');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(615, '0_3_67');
      "><br>
<br>
  <span class="id" title="keyword">Theorem</span> <a id="equiv_amalgamatedfreeproduct_rec" class="idref" href="#equiv_amalgamatedfreeproduct_rec"><span class="id" title="lemma">equiv_amalgamatedfreeproduct_rec</span></a> `{<a id="H0:134" class="idref" href="#H0:134"><span class="id" title="binder">Funext</span></a>} (<a id="X:135" class="idref" href="#X:135"><span class="id" title="binder">X</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#Group"><span class="id" title="record">Group</span></a>)<br>
    : <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="h:136" class="idref" href="#h:136"><span class="id" title="binder">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.H"><span class="id" title="variable">H</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#X:135"><span class="id" title="variable">X</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">{</span></a><a id="k:137" class="idref" href="#k:137"><span class="id" title="binder">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">:</span></a> <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.K"><span class="id" title="variable">K</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#X:135"><span class="id" title="variable">X</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#h:136"><span class="id" title="variable">h</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#k:137"><span class="id" title="variable">k</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.g"><span class="id" title="variable">g</span></a> <a class="idref" href="HoTT.Basics.Overture.html#cc5e56ba3765e2d6b17e66d19b966f1d"><span class="id" title="notation">}}</span></a><br>
      <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#AmalgamatedFreeProduct"><span class="id" title="definition">AmalgamatedFreeProduct</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#X:135"><span class="id" title="variable">X</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(616, '0_3_67');
      "><br>
  <span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(617, '0_3_67');
      "><br>
    <span class="id" title="var">snrapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#equiv_adjointify"><span class="id" title="definition">equiv_adjointify</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(618, '0_3_67');
      "><br>
    1: <span class="id" title="tactic">intros</span> [<span class="id" title="var">h</span> [<span class="id" title="var">k</span> <span class="id" title="var">p</span>]]; <span class="id" title="tactic">exact</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#AmalgamatedFreeProduct_rec"><span class="id" title="definition">AmalgamatedFreeProduct_rec</span></a> <span class="id" title="var">X</span> <span class="id" title="var">h</span> <span class="id" title="var">k</span> <span class="id" title="var">p</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(619, '0_3_67');
      "><br>
    { <span class="id" title="tactic">intros</span> <span class="id" title="var">r</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(620, '0_3_67');
      "><br>
      <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_compose"><span class="id" title="definition">grp_homo_compose</span></a> <span class="id" title="var">r</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_inl"><span class="id" title="definition">amal_inl</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(621, '0_3_67');
      "><br>
      <span class="id" title="tactic">∃</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_compose"><span class="id" title="definition">grp_homo_compose</span></a> <span class="id" title="var">r</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_inr"><span class="id" title="definition">amal_inr</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(622, '0_3_67');
      "><br>
      <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(623, '0_3_67');
      "><br>
      <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Basics.Overture.html#ap"><span class="id" title="definition">ap</span></a> <span class="id" title="var">r</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(624, '0_3_67');
      "><br>
      <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(625, '0_3_67');
      "><br>
      <span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_nil"><span class="id" title="definition">word_concat_w_nil</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inl"><span class="id" title="constructor">inl</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.f"><span class="id" title="variable">f</span></a> <span class="id" title="var">x</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(626, '0_3_67');
      "><br>
      <span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#word_concat_w_nil"><span class="id" title="definition">word_concat_w_nil</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#inr"><span class="id" title="constructor">inr</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.g"><span class="id" title="variable">g</span></a> <span class="id" title="var">x</span>)<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(627, '0_3_67');
      "><br>
      <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_tau"><span class="id" title="definition">amal_tau</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <span class="id" title="var">x</span>). }</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(628, '0_3_67');
      "><br>
    { <span class="id" title="tactic">intros</span> <span class="id" title="var">r</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(629, '0_3_67');
      "><br>
      <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#equiv_path_grouphomomorphism"><span class="id" title="definition">equiv_path_grouphomomorphism</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(630, '0_3_67');
      "><br>
      <span class="id" title="var">srapply</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_type_ind_hprop"><span class="id" title="definition">amal_type_ind_hprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(631, '0_3_67');
      "><br>
      <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(632, '0_3_67');
      "><br>
      <span class="id" title="tactic">induction</span> <span class="id" title="var">x</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">a</span> <span class="id" title="var">x</span>].</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(633, '0_3_67');
      "><br>
      1: <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_unit"><span class="id" title="definition">grp_homo_unit</span></a> <span class="id" title="var">r</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(634, '0_3_67');
      "><br>
      <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> ×.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(635, '0_3_67');
      "><br>
      <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHx</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(636, '0_3_67');
      "><br>
      <span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">symmetry</span>;<br>
      <span class="id" title="var">rapply</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_op"><span class="id" title="definition">grp_homo_op</span></a> <span class="id" title="var">r</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">[</span></a><span class="id" title="var">_</span><a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#38fed80a854e180a636c2567039adf3f"><span class="id" title="notation">]</span></a>) (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_eta"><span class="id" title="definition">amal_eta</span></a> <span class="id" title="var">x</span>)). }</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(637, '0_3_67');
      "><br>
    <span class="id" title="tactic">intro</span> <span class="id" title="var">hkp</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(638, '0_3_67');
      "><br>
    <span class="id" title="tactic">simpl</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(639, '0_3_67');
      "><br>
    <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Basics.Equivalences.html#76214fa316f18d720833e810bbfd71fb"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Basics.Equivalences.html#equiv_ap'"><span class="id" title="definition">equiv_ap'</span></a> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_sigma_prod"><span class="id" title="definition">equiv_sigma_prod</span></a><br>
      (<span class="id" title="keyword">fun</span> <a id="hk:139" class="idref" href="#hk:139"><span class="id" title="binder">hk</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.H"><span class="id" title="variable">H</span></a> <span class="id" title="var">X</span> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.K"><span class="id" title="variable">K</span></a> <span class="id" title="var">X</span><br>
        ⇒ <a class="idref" href="HoTT.Basics.Datatypes.html#fst"><span class="id" title="projection">fst</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#hk:138"><span class="id" title="variable">hk</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.f"><span class="id" title="variable">f</span></a> <a class="idref" href="HoTT.Basics.Overture.html#2596316c6f2ff161cb03e25fd8914390"><span class="id" title="notation">==</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#snd"><span class="id" title="projection">snd</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#hk:138"><span class="id" title="variable">hk</span></a> <a class="idref" href="HoTT.Basics.Overture.html#::function_scope:x_'o'_x"><span class="id" title="notation">o</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct.g"><span class="id" title="variable">g</span></a>)) <span class="id" title="var">_</span> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Equivalences.html#76214fa316f18d720833e810bbfd71fb"><span class="id" title="notation">)^-1</span></a>%<span class="id" title="var">equiv</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(640, '0_3_67');
      "><br>
    <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Types.Sigma.html#path_sigma_hprop"><span class="id" title="definition">path_sigma_hprop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(641, '0_3_67');
      "><br>
    <span class="id" title="tactic">destruct</span> <span class="id" title="var">hkp</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">h</span> [<span class="id" title="var">k</span> <span class="id" title="var">p</span>]].</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(642, '0_3_67');
      "><br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Types.Prod.html#path_prod"><span class="id" title="definition">path_prod</span></a>; <span class="id" title="var">cbn</span>;<br>
    <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Algebra.Groups.Group.html#equiv_path_grouphomomorphism"><span class="id" title="definition">equiv_path_grouphomomorphism</span></a>;<br>
    <span class="id" title="tactic">intro</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Classes.interfaces.canonical_names.html#right_identity"><span class="id" title="definition">right_identity</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(643, '0_3_67');
      "><br>
  <span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(644, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">End</span> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct"><span class="id" title="section">FreeProduct</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(645, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="FreeProduct" class="idref" href="#FreeProduct"><span class="id" title="definition">FreeProduct</span></a> (<a id="G:140" class="idref" href="#G:140"><span class="id" title="binder">G</span></a> <a id="H:141" class="idref" href="#H:141"><span class="id" title="binder">H</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#Group"><span class="id" title="record">Group</span></a>) : <a class="idref" href="HoTT.Algebra.Groups.Group.html#Group"><span class="id" title="record">Group</span></a><br>
  := <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#AmalgamatedFreeProduct"><span class="id" title="definition">AmalgamatedFreeProduct</span></a> <a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_trivial"><span class="id" title="definition">grp_trivial</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#G:140"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#H:141"><span class="id" title="variable">H</span></a> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_trivial_rec"><span class="id" title="definition">grp_trivial_rec</span></a> <span class="id" title="var">_</span>) (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_trivial_rec"><span class="id" title="definition">grp_trivial_rec</span></a> <span class="id" title="var">_</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(646, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="freeproduct_inl" class="idref" href="#freeproduct_inl"><span class="id" title="definition">freeproduct_inl</span></a> {<a id="G:142" class="idref" href="#G:142"><span class="id" title="binder">G</span></a> <a id="H:143" class="idref" href="#H:143"><span class="id" title="binder">H</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#Group"><span class="id" title="record">Group</span></a>} : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#G:142"><span class="id" title="variable">G</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct"><span class="id" title="definition">FreeProduct</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#G:142"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#H:143"><span class="id" title="variable">H</span></a>)<br>
  := <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_inl"><span class="id" title="definition">amal_inl</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(647, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="freeproduct_inr" class="idref" href="#freeproduct_inr"><span class="id" title="definition">freeproduct_inr</span></a> {<a id="G:144" class="idref" href="#G:144"><span class="id" title="binder">G</span></a> <a id="H:145" class="idref" href="#H:145"><span class="id" title="binder">H</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#Group"><span class="id" title="record">Group</span></a>} : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#H:145"><span class="id" title="variable">H</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct"><span class="id" title="definition">FreeProduct</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#G:144"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#H:145"><span class="id" title="variable">H</span></a>)<br>
  := <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#amal_inr"><span class="id" title="definition">amal_inr</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(648, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="FreeProduct_rec" class="idref" href="#FreeProduct_rec"><span class="id" title="definition">FreeProduct_rec</span></a> (<a id="G:146" class="idref" href="#G:146"><span class="id" title="binder">G</span></a> <a id="H:147" class="idref" href="#H:147"><span class="id" title="binder">H</span></a> <a id="K:148" class="idref" href="#K:148"><span class="id" title="binder">K</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#Group"><span class="id" title="record">Group</span></a>)<br>
  (<a id="f:149" class="idref" href="#f:149"><span class="id" title="binder">f</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#G:146"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#K:148"><span class="id" title="variable">K</span></a>) (<a id="g:150" class="idref" href="#g:150"><span class="id" title="binder">g</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#H:147"><span class="id" title="variable">H</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#K:148"><span class="id" title="variable">K</span></a>)<br>
  : <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct"><span class="id" title="definition">FreeProduct</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#G:146"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#H:147"><span class="id" title="variable">H</span></a>) <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#K:148"><span class="id" title="variable">K</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(649, '0_3_67');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(650, '0_3_67');
      "><br>
  <span class="id" title="var">snrapply</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#AmalgamatedFreeProduct_rec"><span class="id" title="definition">AmalgamatedFreeProduct_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(651, '0_3_67');
      "><br>
  <span class="id" title="tactic">intros</span> [].</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(652, '0_3_67');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_unit"><span class="id" title="definition">grp_homo_unit</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_unit"><span class="id" title="definition">grp_homo_unit</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(653, '0_3_67');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(654, '0_3_67');
      "><br>
<br>
<span class="id" title="keyword">Definition</span> <a id="equiv_freeproduct_rec" class="idref" href="#equiv_freeproduct_rec"><span class="id" title="definition">equiv_freeproduct_rec</span></a> `{<a id="funext:151" class="idref" href="#funext:151"><span class="id" title="binder">funext</span></a> : <a class="idref" href="HoTT.Basics.Overture.html#Funext"><span class="id" title="class">Funext</span></a>} (<a id="G:152" class="idref" href="#G:152"><span class="id" title="binder">G</span></a> <a id="H:153" class="idref" href="#H:153"><span class="id" title="binder">H</span></a> <a id="K:154" class="idref" href="#K:154"><span class="id" title="binder">K</span></a> : <a class="idref" href="HoTT.Algebra.Groups.Group.html#Group"><span class="id" title="record">Group</span></a>)<br>
  : <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#G:152"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#K:154"><span class="id" title="variable">K</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a> <a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#H:153"><span class="id" title="variable">H</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#K:154"><span class="id" title="variable">K</span></a><a class="idref" href="HoTT.Basics.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">)</span></a><br>
  <a class="idref" href="HoTT.Basics.Overture.html#068136b784cb569aaadfa01f234d5c01"><span class="id" title="notation">&lt;~&gt;</span></a> <a class="idref" href="HoTT.Algebra.Groups.Group.html#GroupHomomorphism"><span class="id" title="record">GroupHomomorphism</span></a> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#FreeProduct"><span class="id" title="definition">FreeProduct</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#G:152"><span class="id" title="variable">G</span></a> <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#H:153"><span class="id" title="variable">H</span></a>) <a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#K:154"><span class="id" title="variable">K</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(655, '0_3_67');
      "><br>
<span class="id" title="keyword">Proof</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(656, '0_3_67');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.FreeProduct.html#equiv_amalgamatedfreeproduct_rec"><span class="id" title="lemma">equiv_amalgamatedfreeproduct_rec</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">K</span> <a class="idref" href="HoTT.Basics.Equivalences.html#::equiv_scope:x_'oE'_x"><span class="id" title="notation">oE</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Equivalences.html#76214fa316f18d720833e810bbfd71fb"><span class="id" title="notation">^-1</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(657, '0_3_67');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Types.Sigma.html#equiv_sigma_prod0"><span class="id" title="definition">equiv_sigma_prod0</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Equivalences.html#::equiv_scope:x_'oE'_x"><span class="id" title="notation">oE</span></a> <a class="idref" href="HoTT.Types.Sigma.html#equiv_functor_sigma_id"><span class="id" title="definition">equiv_functor_sigma_id</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <a class="idref" href="HoTT.Types.Sigma.html#equiv_sigma_contr"><span class="id" title="definition">equiv_sigma_contr</span></a> <span class="id" title="var">_</span>)).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(658, '0_3_67');
      "><br>
  <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(659, '0_3_67');
      "><br>
  <span class="id" title="var">rapply</span> <a class="idref" href="HoTT.Types.Forall.html#contr_forall"><span class="id" title="instance">contr_forall</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(660, '0_3_67');
      "><br>
  <span class="id" title="tactic">intros</span> []; <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#contr_inhab_prop"><span class="id" title="definition">contr_inhab_prop</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(661, '0_3_67');
      "><br>
  <span class="id" title="tactic">apply</span> <a class="idref" href="HoTT.Truncations.Core.html#Trunc.tr"><span class="id" title="constructor">tr</span></a>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(662, '0_3_67');
      "><br>
  <span class="id" title="tactic">refine</span> (<a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_unit"><span class="id" title="definition">grp_homo_unit</span></a> <span class="id" title="var">_</span> <a class="idref" href="HoTT.Basics.Overture.html#da4283005a63bc086811fc2e64b35356"><span class="id" title="notation">@</span></a> <a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">(</span></a><a class="idref" href="HoTT.Algebra.Groups.Group.html#grp_homo_unit"><span class="id" title="definition">grp_homo_unit</span></a> <span class="id" title="var">_</span><a class="idref" href="HoTT.Basics.Overture.html#6bc2e8b4a6e295632a90f5f35132db8d"><span class="id" title="notation">)^</span></a>).</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(663, '0_3_67');
      "><br>
<span class="id" title="keyword">Defined</span>.</span><span class="command" onmouseout="
      mouseout('0_3_67');
      " onmouseover="
      mouseover(664, '0_3_67');
      "><br>
</span>
</div>
<div class="goal" id="goal0_3_67"><pre><span></span></pre></div>
</div>
<div id="footer" scenenumber="5" class="doc">
<hr>
<a href="index.html">Index</a><hr>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>
</div></body>
</html>
